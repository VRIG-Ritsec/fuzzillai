std::array - cppreference.com cppreference.com Create account Log in Namespaces Page Discussion Variants Views View Edit History Actions std:: array From cppreference.com < cpp ‎ | container C++ Compiler support Freestanding and hosted Language Standard library Standard library headers Named requirements Feature test macros (C++20) Language support library Concepts library (C++20) Diagnostics library Memory management library Metaprogramming library (C++11) General utilities library Containers library Iterators library Ranges library (C++20) Algorithms library Strings library Text processing library Numerics library Date and time library Input/output library Filesystem library (C++17) Concurrency support library (C++11) Execution control library (C++26) Technical specifications Symbols index External libraries [edit] Containers library node-handle (C++17) Sequence array (C++11) vector vector <bool> inplace_vector (C++26) hive (C++26) deque forward_list (C++11) list Associative set multiset map multimap Unordered associative unordered_set (C++11) unordered_multiset (C++11) unordered_map (C++11) unordered_multimap (C++11) Adaptors stack queue priority_queue flat_set (C++23) flat_multiset (C++23) flat_map (C++23) flat_multimap (C++23) Views span (C++20) mdspan (C++23) Tables Iterator invalidation Member function table Non-member function table [edit] std::array Member types Member functions Element access array::at array::operator[] array::front array::back array::data Operations array::fill array::swap Iterators array::begin array::cbegin array::end array::cend array::rbegin array::crbegin array::rend array::crend Capacity array::empty array::size array::max_size Non-member functions operator== operator<=> (C++20) get (std::array) swap (std::array) to_array (C++20) operator|= operator< operator> operator<= operator>= (until C++20) (until C++20) (until C++20) (until C++20) (until C++20) Helper classes tuple_size <std::array> tuple_element <std::array> Deduction guides (C++17) [edit] Defined in header <array> template < class T, std:: size_t N > struct array ; (since C++11) std::array is a container that encapsulates fixed size arrays. This container is an aggregate type with the same semantics as a struct holding a C-style array T [ N ] as its only non-static data member. Unlike a C-style array, it doesn't decay to T * automatically. As an aggregate type, it can be initialized with aggregate-initialization given at most N initializers that are convertible to T : std :: array < int , 3 > a = { 1 , 2 , 3 } ; . The struct combines the performance and accessibility of a C-style array with the benefits of a standard container, such as knowing its own size, supporting assignment, random access iterators, etc. std::array satisfies the requirements of Container and ReversibleContainer except that default-constructed array is not empty and that the complexity of swapping is linear, satisfies the requirements of ContiguousContainer , (since C++17) and partially satisfies the requirements of SequenceContainer . There is a special case for a zero-length array ( N == 0 ). In that case, array. begin ( ) == array. end ( ) , which is some unique value. The effect of calling front ( ) or back ( ) on a zero-sized array is undefined. An array can also be used as a tuple of N elements of the same type. Contents 1 Iterator invalidation 2 Template parameters 3 Member types 4 Member functions 4.1 Implicitly-defined member functions 4.2 Element access 4.3 Iterators 4.4 Capacity 4.5 Operations 5 Non-member functions 6 Helper classes 7 Deduction guides 8 Example 9 See also [ edit ] Iterator invalidation As a rule, iterators to an array are never invalidated throughout the lifetime of the array. One should take note, however, that during swap , the iterator will continue to point to the same array element, and will thus change its value. [ edit ] Template parameters T - element type Must be MoveConstructible and MoveAssignable . N - the number of elements in the array or ​ 0 ​ . This section is incomplete Reason: Complete the descriptions of template parameters. [ edit ] Member types Member type Definition value_type T [edit] size_type std::size_t [edit] difference_type std::ptrdiff_t [edit] reference value_type & [edit] const_reference const value_type & [edit] pointer value_type * [edit] const_pointer const value_type * [edit] iterator LegacyRandomAccessIterator and LegacyContiguousIterator to value_type (until C++17) LegacyRandomAccessIterator and LegacyContiguousIterator that is a LiteralType to value_type (since C++17) (until C++20) LegacyRandomAccessIterator , contiguous_iterator , and ConstexprIterator to value_type (since C++20) [edit] const_iterator LegacyRandomAccessIterator and LegacyContiguousIterator to const value_type (until C++17) LegacyRandomAccessIterator and LegacyContiguousIterator that is a LiteralType to const value_type (since C++17) (until C++20) LegacyRandomAccessIterator , contiguous_iterator , and ConstexprIterator to const value_type (since C++20) [edit] reverse_iterator std:: reverse_iterator < iterator > [edit] const_reverse_iterator std:: reverse_iterator < const_iterator > [edit] [ edit ] Member functions Implicitly-defined member functions (constructor) (implicitly declared) initializes the array following the rules of aggregate initialization (note that default initialization may result in indeterminate values for non-class T ) (public member function) (destructor) (implicitly declared) destroys every element of the array (public member function) operator= (implicitly declared) overwrites every element of the array with the corresponding element of another array (public member function) Element access at access specified element with bounds checking (public member function) [edit] operator[] access specified element (public member function) [edit] front access the first element (public member function) [edit] back access the last element (public member function) [edit] data direct access to the underlying contiguous storage (public member function) [edit] Iterators begin cbegin returns an iterator to the beginning (public member function) [edit] end cend returns an iterator to the end (public member function) [edit] rbegin crbegin returns a reverse iterator to the beginning (public member function) [edit] rend crend returns a reverse iterator to the end (public member function) [edit] Capacity empty checks whether the container is empty (public member function) [edit] size returns the number of elements (public member function) [edit] max_size returns the maximum possible number of elements (public member function) [edit] Operations fill fill the container with specified value (public member function) [edit] swap swaps the contents (public member function) [edit] [ edit ] Non-member functions operator== operator!= operator< operator<= operator> operator>= operator<=> (C++11) (C++11) (removed in C++20) (C++11) (removed in C++20) (C++11) (removed in C++20) (C++11) (removed in C++20) (C++11) (removed in C++20) (C++20) lexicographically compares the values of two array s (function template) [edit] get (std::array) (C++11) accesses an element of an array (function template) [edit] std::swap (std::array) (C++11) specializes the std::swap algorithm (function template) [edit] to_array (C++20) creates a std::array object from a built-in array (function template) [edit] [ edit ] Helper classes std::tuple_size <std::array> (C++11) obtains the size of an array (class template specialization) [edit] std::tuple_element <std::array> (C++11) obtains the type of the elements of array (class template specialization) [edit] Deduction guides (since C++17) [ edit ] Example Run this code #include <algorithm> #include <array> #include <iostream> #include <iterator> #include <string> int main ( ) { // Construction uses aggregate initialization std :: array < int , 3 > a1 { { 1 , 2 , 3 } } ; // Double-braces required in C++11 prior to // the CWG 1270 revision (not needed in C++11 // after the revision and in C++14 and beyond) std :: array < int , 3 > a2 = { 1 , 2 , 3 } ; // Double braces never required after = // Container operations are supported std:: sort ( a1. begin ( ) , a1. end ( ) ) ; std :: ranges:: reverse_copy ( a2, std:: ostream_iterator < int > ( std:: cout , " " ) ) ; std:: cout << ' \n ' ; // Ranged for loop is supported std :: array < std:: string , 2 > a3 { "E" , " \u018E " } ; for ( const auto & s : a3 ) std:: cout << s << ' ' ; std:: cout << ' \n ' ; // Deduction guide for array creation (since C++17) [ [ maybe_unused ] ] std :: array a4 { 3.0 , 1.0 , 4.0 } ; // std::array<double, 3> // Behavior of unspecified elements is the same as with built-in arrays [ [ maybe_unused ] ] std :: array < int , 2 > a5 ; // No list init, a5[0] and a5[1] // are default initialized [ [ maybe_unused ] ] std :: array < int , 2 > a6 { } ; // List init, both elements are value // initialized, a6[0] = a6[1] = 0 [ [ maybe_unused ] ] std :: array < int , 2 > a7 { 1 } ; // List init, unspecified element is value // initialized, a7[0] = 1, a7[1] = 0 } Output: 3 2 1 E Ǝ [ edit ] See also inplace_vector (C++26) resizable, fixed capacity, inplace contiguous array (class template) [edit] vector resizable contiguous array (class template) [edit] deque double-ended queue (class template) [edit] make_array (library fundamentals TS v2) creates a std::array object whose size and optionally element type are deduced from the arguments (function template) [edit] Retrieved from " https://en.cppreference.com/mwiki/index.php?title=cpp/container/array&oldid=174050 " Category : Todo with reason Navigation Support us Recent changes FAQ Offline version Toolbox What links here Related changes Upload file Special pages Printable version Permanent link Page information In other languages Deutsch Español Français Italiano 日本語 Polski Português Русский 中文 This page was last modified on 2 August 2024, at 22:20. Privacy policy About cppreference.com Disclaimers