std::distance - cppreference.com cppreference.com Create account Log in Namespaces Page Discussion Variants Views View Edit History Actions std:: distance From cppreference.com < cpp ‎ | iterator C++ Compiler support Freestanding and hosted Language Standard library Standard library headers Named requirements Feature test macros (C++20) Language support library Concepts library (C++20) Diagnostics library Memory management library Metaprogramming library (C++11) General utilities library Containers library Iterators library Ranges library (C++20) Algorithms library Strings library Text processing library Numerics library Date and time library Input/output library Filesystem library (C++17) Concurrency support library (C++11) Execution control library (C++26) Technical specifications Symbols index External libraries [edit] Iterator library Iterator concepts indirectly_readable (C++20) indirectly_writable (C++20) weakly_incrementable (C++20) incrementable (C++20) is-integer-like is-signed-integer-like (C++20) (C++20) sentinel_for (C++20) sized_sentinel_for (C++20) input_iterator (C++20) output_iterator (C++20) input_or_output_iterator (C++20) forward_iterator (C++20) bidirectional_iterator (C++20) random_access_iterator (C++20) contiguous_iterator (C++20) Iterator primitives input_iterator_tag output_iterator_tag forward_iterator_tag bidirectional_iterator_tag random_access_iterator_tag contiguous_iterator_tag (C++20) iter_value_t iter_difference_t iter_reference_t iter_const_reference_t iter_rvalue_reference_t iter_common_reference_t (C++20) (C++20) (C++20) (C++23) (C++20) (C++20) iterator (deprecated in C++17) iterator_traits incrementable_traits (C++20) indirectly_readable_traits (C++20) Algorithm concepts and utilities Indirect callable concepts indirectly_unary_invocable indirectly_regular_unary_invocable (C++20) (C++20) indirect_unary_predicate (C++20) indirect_binary_predicate (C++20) indirect_equivalence_relation (C++20) indirect_strict_weak_order (C++20) Common algorithm requirements indirectly_movable (C++20) indirectly_movable_storable (C++20) indirectly_copyable (C++20) indirectly_copyable_storable (C++20) indirectly_swappable (C++20) indirectly_comparable (C++20) permutable (C++20) mergeable (C++20) sortable (C++20) Utilities indirect_result_t (C++20) projected (C++20) projected_value_t (C++26) Iterator adaptors reverse_iterator make_reverse_iterator (C++14) move_iterator (C++11) make_move_iterator (C++11) default_sentinel_t default_sentinel (C++20) (C++20) unreachable_sentinel_t unreachable_sentinel (C++20) (C++20) front_insert_iterator back_insert_iterator inserter insert_iterator front_inserter back_inserter move_sentinel (C++20) common_iterator (C++20) counted_iterator (C++20) basic_const_iterator (C++23) const_iterator (C++23) const_sentinel (C++23) make_const_iterator (C++23) make_const_sentinel (C++23) Stream iterators istream_iterator ostream_iterator istreambuf_iterator ostreambuf_iterator Iterator customization points ranges::iter_move (C++20) ranges::iter_swap (C++20) Iterator operations advance distance prev (C++11) next (C++11) ranges::advance (C++20) ranges::distance (C++20) ranges::prev (C++20) ranges::next (C++20) Range access begin cbegin (C++11) (C++14) rbegin crbegin (C++14) (C++14) end cend (C++11) (C++14) rend crend (C++14) (C++14) size ssize (C++17) (C++20) empty (C++17) data (C++17) [edit] Defined in header <iterator> template < class InputIt > typename std:: iterator_traits < InputIt > :: difference_type distance ( InputIt first, InputIt last ) ; (constexpr since C++17) Returns the number of hops from first to last . If InputIt is not LegacyRandomAccessIterator , the behavior is undefined if last is not reachable from first . If InputIt is LegacyRandomAccessIterator , the behavior is undefined if first and last are neither reachable from each other. Contents 1 Parameters 2 Return value 3 Complexity 4 Possible implementation 5 Example 6 Defect reports 7 See also [ edit ] Parameters first - iterator pointing to the first element last - iterator pointing to the end of the range Type requirements - InputIt must meet the requirements of LegacyInputIterator . The operation is more efficient if InputIt additionally meets the requirements of LegacyRandomAccessIterator . [ edit ] Return value The number of increments needed to go from first to last . The value may be negative if random-access iterators are used and first is reachable from last . (since C++11) [ edit ] Complexity Linear. However, if InputIt additionally meets the requirements of LegacyRandomAccessIterator , complexity is constant. [ edit ] Possible implementation See also the implementations in libstdc++ and libc++ . C++98 implementation via tag dispatch, with constexpr removed namespace detail { template < class It > constexpr // required since C++17 typename std:: iterator_traits < It > :: difference_type do_distance ( It first, It last, std:: input_iterator_tag ) { typename std:: iterator_traits < It > :: difference_type result = 0 ; while ( first ! = last ) { ++ first ; ++ result ; } return result ; } template < class It > constexpr // required since C++17 typename std:: iterator_traits < It > :: difference_type do_distance ( It first, It last, std:: random_access_iterator_tag ) { return last - first ; } } // namespace detail template < class It > constexpr // since C++17 typename std:: iterator_traits < It > :: difference_type distance ( It first, It last ) { return detail :: do_distance ( first, last, typename std:: iterator_traits < It > :: iterator_category ( ) ) ; } C++17 implementation via if constexpr template < class It > constexpr typename std:: iterator_traits < It > :: difference_type distance ( It first, It last ) { using category = typename std:: iterator_traits < It > :: iterator_category ; static_assert ( std:: is_base_of_v < std:: input_iterator_tag , category > ) ; if constexpr ( std:: is_base_of_v < std:: random_access_iterator_tag , category > ) return last - first ; else { typename std:: iterator_traits < It > :: difference_type result = 0 ; while ( first ! = last ) { ++ first ; ++ result ; } return result ; } } [ edit ] Example Run this code #include <iostream> #include <iterator> #include <vector> int main ( ) { std:: vector < int > v { 3 , 1 , 4 } ; std:: cout << "distance(first, last) = " << std :: distance ( v. begin ( ) , v. end ( ) ) << ' \n ' << "distance(last, first) = " << std :: distance ( v. end ( ) , v. begin ( ) ) << ' \n ' ; // the behavior is undefined (until LWG940) static constexpr auto il = { 3 , 1 , 4 } ; // Since C++17 `distance` can be used in constexpr context. static_assert ( std :: distance ( il. begin ( ) , il. end ( ) ) == 3 ) ; static_assert ( std :: distance ( il. end ( ) , il. begin ( ) ) == - 3 ) ; } Output: distance(first, last) = 3 distance(last, first) = -3 [ edit ] Defect reports The following behavior-changing defect reports were applied retroactively to previously published C++ standards. DR Applied to Behavior as published Correct behavior LWG 940 C++98 the wording was unclear for the case where first is reachable from last made clear [ edit ] See also advance advances an iterator by given distance (function template) [edit] count count_if returns the number of elements satisfying specific criteria (function template) [edit] ranges::distance (C++20) returns the distance between an iterator and a sentinel, or between the beginning and end of a range (algorithm function object) [edit] Retrieved from " https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/distance&oldid=182536 " Navigation Support us Recent changes FAQ Offline version Toolbox What links here Related changes Upload file Special pages Printable version Permanent link Page information In other languages Deutsch Español Français Italiano 日本語 Português Русский 中文 This page was last modified on 5 April 2025, at 23:28. Privacy policy About cppreference.com Disclaimers