std::projected - cppreference.com cppreference.com Create account Log in Namespaces Page Discussion Variants Views View Edit History Actions std:: projected From cppreference.com < cpp ‎ | iterator C++ Compiler support Freestanding and hosted Language Standard library Standard library headers Named requirements Feature test macros (C++20) Language support library Concepts library (C++20) Diagnostics library Memory management library Metaprogramming library (C++11) General utilities library Containers library Iterators library Ranges library (C++20) Algorithms library Strings library Text processing library Numerics library Date and time library Input/output library Filesystem library (C++17) Concurrency support library (C++11) Execution control library (C++26) Technical specifications Symbols index External libraries [edit] Iterator library Iterator concepts indirectly_readable (C++20) indirectly_writable (C++20) weakly_incrementable (C++20) incrementable (C++20) is-integer-like is-signed-integer-like (C++20) (C++20) sentinel_for (C++20) sized_sentinel_for (C++20) input_iterator (C++20) output_iterator (C++20) input_or_output_iterator (C++20) forward_iterator (C++20) bidirectional_iterator (C++20) random_access_iterator (C++20) contiguous_iterator (C++20) Iterator primitives input_iterator_tag output_iterator_tag forward_iterator_tag bidirectional_iterator_tag random_access_iterator_tag contiguous_iterator_tag (C++20) iter_value_t iter_difference_t iter_reference_t iter_const_reference_t iter_rvalue_reference_t iter_common_reference_t (C++20) (C++20) (C++20) (C++23) (C++20) (C++20) iterator (deprecated in C++17) iterator_traits incrementable_traits (C++20) indirectly_readable_traits (C++20) Algorithm concepts and utilities Indirect callable concepts indirectly_unary_invocable indirectly_regular_unary_invocable (C++20) (C++20) indirect_unary_predicate (C++20) indirect_binary_predicate (C++20) indirect_equivalence_relation (C++20) indirect_strict_weak_order (C++20) Common algorithm requirements indirectly_movable (C++20) indirectly_movable_storable (C++20) indirectly_copyable (C++20) indirectly_copyable_storable (C++20) indirectly_swappable (C++20) indirectly_comparable (C++20) permutable (C++20) mergeable (C++20) sortable (C++20) Utilities indirect_result_t (C++20) projected (C++20) projected_value_t (C++26) Iterator adaptors reverse_iterator make_reverse_iterator (C++14) move_iterator (C++11) make_move_iterator (C++11) default_sentinel_t default_sentinel (C++20) (C++20) unreachable_sentinel_t unreachable_sentinel (C++20) (C++20) front_insert_iterator back_insert_iterator inserter insert_iterator front_inserter back_inserter move_sentinel (C++20) common_iterator (C++20) counted_iterator (C++20) basic_const_iterator (C++23) const_iterator (C++23) const_sentinel (C++23) make_const_iterator (C++23) make_const_sentinel (C++23) Stream iterators istream_iterator ostream_iterator istreambuf_iterator ostreambuf_iterator Iterator customization points ranges::iter_move (C++20) ranges::iter_swap (C++20) Iterator operations advance distance prev (C++11) next (C++11) ranges::advance (C++20) ranges::distance (C++20) ranges::prev (C++20) ranges::next (C++20) Range access begin cbegin (C++11) (C++14) rbegin crbegin (C++14) (C++14) end cend (C++11) (C++14) rend crend (C++14) (C++14) size ssize (C++17) (C++20) empty (C++17) data (C++17) [edit] Defined in header <iterator> (1) template < std:: indirectly_readable I, std:: indirectly_regular_unary_invocable < I > Proj > struct projected { using value_type = std:: remove_cvref_t < std:: indirect_result_t < Proj & , I >> ; std:: indirect_result_t < Proj & , I > operator * ( ) const ; // not defined } ; (since C++20) (until C++26) template < std:: indirectly_readable I, std:: indirectly_regular_unary_invocable < I > Proj > using projected = /*projected-impl*/ < I, Proj > :: /*type*/ ; (since C++26) template < std:: weakly_incrementable I, class Proj > struct incrementable_traits < std :: projected < I, Proj >> { using difference_type = std:: iter_difference_t < I > ; } ; (2) (since C++20) (until C++26) Helper templates template < class I, class Proj > struct /*projected-impl*/ { struct /*type*/ { using value_type = std:: remove_cvref_t < std:: indirect_result_t < Proj & , I >> ; using difference_type = std:: iter_difference_t < I > ; // conditionally present std:: indirect_result_t < Proj & , I > operator * ( ) const ; // not defined } ; } ; (3) (since C++26) ( exposition only* ) 1) Class (until C++26) Alias (since C++26) template projected combines an indirectly_readable type I and a callable object type Proj into a new indirectly_readable type whose reference type is the result of applying Proj to the std:: iter_reference_t < I > . 2) This specialization of std::incrementable_traits makes std :: projected < I, Proj > a weakly_incrementable type when I is also a weakly_incrementable type. 3) An indirect layer used for avoiding unexpected argument-dependent lookup . For the exposition-only nested class /*type*/ , the nested type difference_type exists only if I models weakly_incrementable . projected is used only to constrain algorithms that accept callable objects and projections, and hence its operator * ( ) is not defined. Contents 1 Template parameters 2 Notes 3 Example 4 See also [ edit ] Template parameters I - an indirectly readable type Proj - projection applied to a dereferenced I [ edit ] Notes The indirect layer prevents I and Proj to be associated classes of projected . When an associated class of I or Proj is an incomplete class type, the indirect layer avoids the unnecessary attempt to inspect the definition of that type that results in hard error. [ edit ] Example Run this code #include <algorithm> #include <cassert> #include <functional> #include <iterator> template < class T > struct Holder { T t ; } ; struct Incomplete ; using P = Holder < Incomplete > * ; static_assert ( std:: equality_comparable < P > ) ; // OK static_assert ( std:: indirectly_comparable < P * , P * , std:: equal_to <>> ) ; // Error before C++26 static_assert ( std:: sortable < P * > ) ; // Error before C++26 int main ( ) { P a [ 10 ] = { } ; // ten null pointers assert ( std:: count ( a, a + 10 , nullptr ) == 10 ) ; // OK assert ( std :: ranges:: count ( a, a + 10 , nullptr ) == 10 ) ; // Error before C++26 } [ edit ] See also projected_value_t (C++26) computes the value type of an indirectly_readable type by projection (alias template) [edit] Retrieved from " https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/projected&oldid=182641 " Navigation Support us Recent changes FAQ Offline version Toolbox What links here Related changes Upload file Special pages Printable version Permanent link Page information In other languages Español 日本語 中文 This page was last modified on 14 April 2025, at 18:50. Privacy policy About cppreference.com Disclaimers