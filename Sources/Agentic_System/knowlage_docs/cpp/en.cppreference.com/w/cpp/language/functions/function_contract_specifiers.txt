Function contract specifiers (since C++26) - cppreference.com cppreference.com Create account Log in Namespaces Page Discussion Variants Views View Edit History Actions Function contract specifiers (since C++26) From cppreference.com < cpp ‎ | language ‎ | functions C++ Compiler support Freestanding and hosted Language Standard library Standard library headers Named requirements Feature test macros (C++20) Language support library Concepts library (C++20) Diagnostics library Memory management library Metaprogramming library (C++11) General utilities library Containers library Iterators library Ranges library (C++20) Algorithms library Strings library Text processing library Numerics library Date and time library Input/output library Filesystem library (C++17) Concurrency support library (C++11) Execution control library (C++26) Technical specifications Symbols index External libraries [edit] C++ language General topics Preprocessor Comments Keywords Escape sequences Flow control Conditional execution statements if switch Iteration statements (loops) for range- for (C++11) while do-while Jump statements continue - break goto - return Functions Function declaration Lambda function expression inline specifier Dynamic exception specifications ( until C++17* ) noexcept specifier (C++11) Exceptions throw -expression try block catch handler Namespaces Namespace declaration Namespace aliases Types Fundamental types Enumeration types Function types Class/struct types Union types Specifiers const / volatile decltype (C++11) auto (C++11) constexpr (C++11) consteval (C++20) constinit (C++20) Storage duration specifiers Initialization Default-initialization Value-initialization Zero-initialization Copy-initialization Direct-initialization Aggregate initialization List-initialization (C++11) Constant initialization Reference initialization Expressions Value categories Order of evaluation Operators Operator precedence Alternative representations Literals Boolean - Integer - Floating-point Character - String - nullptr (C++11) User-defined (C++11) Utilities Attributes (C++11) Types typedef declaration Type alias declaration (C++11) Casts Implicit conversions static_cast const_cast Explicit conversions dynamic_cast reinterpret_cast Memory allocation new expression delete expression Classes Class declaration Constructors this pointer Access specifiers friend specifier Class-specific function properties Virtual function override specifier (C++11) final specifier (C++11) explicit (C++11) static Special member functions Default constructor Copy constructor Move constructor (C++11) Copy assignment Move assignment (C++11) Destructor Templates Class template Function template Template specialization Parameter packs (C++11) Miscellaneous Inline assembly History of C++ [edit] Functions Declarations Function declaration Function parameter list Function definition Function contract specifiers (C++26) Default arguments Variadic arguments inline specifier Lambda expressions (C++11) Coroutines (C++20) Replacement functions Function calls Argument-Dependent Lookup (ADL) Function-call operator Function objects Overloading Overload resolution Operator overloading Address of an overload set [edit] Function contract specifiers (preconditions spelled with pre and postconditions spelled with post ) are specifiers that may be applied to the declarator of a function or of a lambda expression to introduce a function contract assertion of the respective kind to the corresponding function. They ensure the specified condition holds during execution, triggering a violation (e.g. termination) in debug builds if the condition evaluates to false or the evaluation exits via an exception, and can be ignored in release builds for performance. Contents 1 Precondition 2 Postcondition 3 Syntax 4 Keywords 5 Notes 6 Example 7 References 8 See also [ edit ] Precondition A precondition ( pre ) is a predicate that the caller must ensure holds before invoking a function or lambda, checked in debug builds to validate inputs or state. [ edit ] Postcondition A postcondition ( post ) is a predicate that the callee must ensure holds after a function or lambda completes, verified in debug builds to confirm output or state. [ edit ] Syntax pre attr ﻿ (optional) ( expr ) (1) post attr ﻿ (optional) ( result-name ﻿ (optional) predicate ) (2) attr - any number of attributes result-name - identifier : identifier - name of a result binding of the associated function predicate - boolean expression that should evaluate to true 1) Precondition 2) Postcondition [ edit ] Keywords pre , post [ edit ] Notes Feature-test macro Value Std Feature __cpp_contracts 202502L (C++26) Contracts [ edit ] Example The precondition of function normalize requires caller to pass normalizable vector. The postcondition ensures that the function normalize returns a normalized vector. Run this code #include <array> #include <cmath> #include <concepts> #include <contracts> #include <limits> #include <print> template < std:: floating_point T > constexpr auto is_normalizable ( const std:: array < T, 3 > & vector ) noexcept { const auto & [ x, y, z ] { vector } ; const auto norm { std:: hypot ( x, y, z ) } ; return std:: isfinite ( norm ) && norm > T { 0 } ; } template < std:: floating_point T > constexpr auto is_normalized ( const std:: array < T, 3 > & vector ) noexcept { const auto & [ x, y, z ] { vector } ; const auto norm { std:: hypot ( x, y, z ) } ; constexpr auto tolerance { 010 * std:: numeric_limits < T > :: epsilon ( ) } ; if ( ! is_normalizable ( norm ) ) [ [ unlikely ] ] return false ; return std :: abs ( norm - T { 1 } ) <= tolerance ; } template < std:: floating_point T > constexpr auto normalize ( std:: array < T, 3 > vector ) noexcept - > std:: array < T, 3 > pre ( is_normalizable ( vector ) ) post ( vector : is_normalized ( vector ) ) { auto & [ x, y, z ] { vector } ; const auto norm { std:: hypot ( x, y, z ) } ; x / = norm, y / = norm, z / = norm ; return vector ; } int main ( ) { const auto v = normalize < float > ( { 0.3 , 0.4 , 0.5 } ) ; std:: println ( "{}" , v ) ; const auto w = normalize < float > ( { 0 , 0 , 0 } ) ; // violates pre- and post- conditions std:: println ( "{}" , w ) ; } Possible output: [0.4242641, 0.56568545, 0.70710677] [-nan, -nan, -nan] [ edit ] References C++26 standard (ISO/IEC 14882:2026): 9.(3+ c ﻿ ) Function contract specifiers [dcl.contract] [ edit ] See also Contract assertions (C++26) specifies properties that must hold at certain points during execution [edit] contract_assert statement (C++26) verifies an internal condition during execution [edit] Retrieved from " https://en.cppreference.com/mwiki/index.php?title=cpp/language/functions/function_contract_specifiers&oldid=181313 " Navigation Support us Recent changes FAQ Offline version Toolbox What links here Related changes Upload file Special pages Printable version Permanent link Page information In other languages Deutsch Español Français Italiano 日本語 Português Русский 中文 This page was last modified on 3 March 2025, at 15:41. Privacy policy About cppreference.com Disclaimers