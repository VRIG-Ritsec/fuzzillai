std::make_shared, std::make_shared_for_overwrite - cppreference.com cppreference.com Create account Log in Namespaces Page Discussion Variants Views View Edit History Actions std:: make_shared, std:: make_shared_for_overwrite From cppreference.com < cpp ‎ | memory ‎ | shared ptr C++ Compiler support Freestanding and hosted Language Standard library Standard library headers Named requirements Feature test macros (C++20) Language support library Concepts library (C++20) Diagnostics library Memory management library Metaprogramming library (C++11) General utilities library Containers library Iterators library Ranges library (C++20) Algorithms library Strings library Text processing library Numerics library Date and time library Input/output library Filesystem library (C++17) Concurrency support library (C++11) Execution control library (C++26) Technical specifications Symbols index External libraries [edit] Memory management library voidify ( exposition only* ) Allocators allocator allocator_traits (C++11) allocation_result (C++23) scoped_allocator_adaptor (C++11) pmr::polymorphic_allocator (C++17) allocator_arg (C++11) uses_allocator (C++11) uses_allocator_construction_args (C++20) make_obj_using_allocator (C++20) uninitialized_construct_using_allocator (C++20) Uninitialized memory algorithms uninitialized_copy uninitialized_fill uninitialized_move (C++17) uninitialized_copy_n (C++11) uninitialized_fill_n uninitialized_move_n (C++17) construct_at (C++20) uninitialized_default_construct (C++17) uninitialized_value_construct (C++17) destroy (C++17) uninitialized_default_construct_n (C++17) uninitialized_value_construct_n (C++17) destroy_n (C++17) destroy_at (C++17) Constrained uninitialized memory algorithms ranges::uninitialized_copy (C++20) ranges::uninitialized_fill (C++20) ranges::uninitialized_move (C++20) ranges::uninitialized_copy_n (C++20) ranges::uninitialized_fill_n (C++20) ranges::uninitialized_move_n (C++20) ranges::construct_at (C++20) ranges::uninitialized_default_construct (C++20) ranges::uninitialized_value_construct (C++20) ranges::destroy (C++20) ranges::uninitialized_default_construct_n (C++20) ranges::uninitialized_value_construct_n (C++20) ranges::destroy_n (C++20) ranges::destroy_at (C++20) Memory resources pmr::memory_resource (C++17) pmr::get_default_resource (C++17) pmr::set_default_resource (C++17) pmr::new_delete_resource (C++17) pmr::pool_options (C++17) pmr::null_memory_resource (C++17) pmr::synchronized_pool_resource (C++17) pmr::unsynchronized_pool_resource (C++17) pmr::monotonic_buffer_resource (C++17) Explicit lifetime management start_lifetime_as (C++23) start_lifetime_as_array (C++23) Types for composite class design indirect (C++26) polymorphic (C++26) Uninitialized storage (until C++20) raw_storage_iterator ( until C++20* ) get_temporary_buffer ( until C++20* ) return_temporary_buffer ( until C++20* ) Garbage collector support (until C++23) declare_reachable (C++11) (until C++23) declare_no_pointers (C++11) (until C++23) pointer_safety (C++11) (until C++23) undeclare_reachable (C++11) (until C++23) undeclare_no_pointers (C++11) (until C++23) get_pointer_safety (C++11) (until C++23) Low level memory management operator new operator new[] operator delete operator delete[] nothrow_t nothrow new_handler set_new_handler get_new_handler (C++11) bad_alloc bad_array_new_length (C++11) align_val_t (C++17) destroying_delete_t (C++20) launder (C++17) Smart pointers unique_ptr (C++11) shared_ptr (C++11) weak_ptr (C++11) auto_ptr ( until C++17* ) owner_less (C++11) owner_less<void> (C++17) owner_hash (C++26) owner_equal (C++26) enable_shared_from_this (C++11) bad_weak_ptr (C++11) default_delete (C++11) out_ptr_t (C++23) inout_ptr_t (C++23) Miscellaneous pointer_traits (C++11) to_address (C++20) addressof (C++11) align (C++11) assume_aligned (C++20) is_sufficiently_aligned (C++26) C Library malloc calloc realloc free aligned_alloc (C++17) [edit] std::shared_ptr Member functions shared_ptr::shared_ptr shared_ptr::~shared_ptr shared_ptr::operator= Modifiers shared_ptr::reset shared_ptr::swap Observers shared_ptr::get shared_ptr::operator* shared_ptr::operator-> shared_ptr::operator[] (C++17) shared_ptr::use_count shared_ptr::unique ( until C++20* ) shared_ptr::operator bool shared_ptr::owner_before shared_ptr::owner_hash (C++26) shared_ptr::owner_equal (C++26) Non-member functions swap (std::shared_ptr) make_shared make_shared_for_overwrite (C++20) allocate_shared allocate_shared_for_overwrite (C++20) static_pointer_cast dynamic_pointer_cast const_pointer_cast reinterpret_pointer_cast (C++17) get_deleter operator== operator!= operator< operator<= operator> operator>= operator<=> (until C++20) (until C++20) (until C++20) (until C++20) (until C++20) (C++20) operator<< atomic_xxx functions ( until C++26* ) Helper classes atomic <std::shared_ptr> (C++20) hash <std::shared_ptr> Deduction guides (C++17) [edit] Defined in header <memory> template < class T, class ... Args > shared_ptr < T > make_shared ( Args && ... args ) ; (1) (since C++11) template < class T > shared_ptr < T > make_shared ( std:: size_t N ) ; (2) (since C++20) template < class T > shared_ptr < T > make_shared ( ) ; (3) (since C++20) template < class T > shared_ptr < T > make_shared ( std:: size_t N, const std:: remove_extent_t < T > & u ) ; (4) (since C++20) template < class T > shared_ptr < T > make_shared ( const std:: remove_extent_t < T > & u ) ; (5) (since C++20) template < class T > shared_ptr < T > make_shared_for_overwrite ( ) ; (6) (since C++20) template < class T > shared_ptr < T > make_shared_for_overwrite ( std:: size_t N ) ; (7) (since C++20) Allocates memory for an object and initialize the object with the supplied arguments. Returns a std::shared_ptr object managing the newly created object. 1) The object is of type T , and is constructed as if by :: new ( pv ) T ( std:: forward < Args > ( args ) ... ) , where pv is a void * pointer to storage suitable to hold an object of type T . If the object is to be destroyed, it is destroyed as if by pt - > ~T ( ) , where pt is a pointer to that object of type T . This overload participates in overload resolution only if T is not an array type. (since C++20) 2) The object is of type std:: remove_extent_t < T > [ N ] . Each element has a default initial value. This overload participates in overload resolution only if T is an unbounded array type. 3) The object is of type T . Each element has a default initial value. This overload participates in overload resolution only if T is a bounded array type. 4) The object is of type std:: remove_extent_t < T > [ N ] . Each element has the initial value u . This overload participates in overload resolution only if T is an unbounded array type. 5) The object is of type T . Each element has the initial value u . This overload participates in overload resolution only if T is a bounded array type. 6) The object is of type T . If T is not an array type, the object is constructed as if by :: new ( pv ) T , where pv is a void * pointer to storage suitable to hold an object of type T . If the object is to be destroyed, it is destroyed as if by pt - > ~T ( ) , where pt is a pointer to that object of type T . If T is a bounded array type, the initial value is unspecified for each element. This overload participates in overload resolution only if T is not an array type or is an bounded array type. 7) The object is of type std:: remove_extent_t < T > [ N ] . The initial value is unspecified for each element. This overload participates in overload resolution only if T is an unbounded array type. Contents 1 Initializing and destroying array elements 2 Parameters 3 Return value 4 Exceptions 5 Notes 6 Example 7 Defect reports 8 See also Initializing and destroying array elements Array elements of type U are initialized in ascending order of their addresses. If U is not an array type, each element is constructed as if by the following expression, where pv is a void * pointer to storage suitable to hold an object of type U : 2,3) :: new ( pv ) U ( ) 4,5) :: new ( pv ) U ( u ) 6,7) :: new ( pv ) U Otherwise, recursively initializes the elements of each element. For the next dimension: U becomes std:: remove_extent_t < U > . For overloads (4,5) , u becomes the corresponding element of u . When the lifetime of the object managed by the return std::shared_ptr ends, or when the initialization of an array element throws an exception, the initialized elements are destroyed in the reverse order of their original construction. For each array element of non-array type U to be destroyed, it is destroyed as if by pu - > ~U ( ) , where pu is a pointer to that array element of type U . (since C++20) [ edit ] Parameters args - list of arguments with which an object of T will be constructed N - array size to use u - the initial value to initialize every element of the array [ edit ] Return value std::shared_ptr to an object of type T or std:: remove_extent_t < T > [ N ] if T is an unbounded array type (since C++20) . For the returned std::shared_ptr r , r. get ( ) returns a non-null pointer and r. use_count ( ) returns 1 . [ edit ] Exceptions May throw std::bad_alloc or any exception thrown by the constructor of T . If an exception is thrown, the functions have no effect. If an exception is thrown during the construction of the array, already-initialized elements are destroyed in reverse order. (since C++20) [ edit ] Notes These functions will typically allocate more memory than sizeof ( T ) to allow for internal bookkeeping structures such as reference counts. These functions may be used as an alternative to std:: shared_ptr < T > ( new T ( args... ) ) . The trade-offs are: std:: shared_ptr < T > ( new T ( args... ) ) performs at least two allocations (one for the object T and one for the control block of the shared pointer), while std :: make_shared < T > typically performs only one allocation (the standard recommends, but does not require this; all known implementations do this). If any std::weak_ptr references the control block created by std::make_shared after the lifetime of all shared owners ended, the memory occupied by T persists until all weak owners get destroyed as well, which may be undesirable if sizeof ( T ) is large. std:: shared_ptr < T > ( new T ( args... ) ) may call a non-public constructor of T if executed in context where it is accessible, while std::make_shared requires public access to the selected constructor. Unlike the std::shared_ptr constructors, std::make_shared does not allow a custom deleter. std::make_shared uses :: new , so if any special behavior has been set up using a class-specific operator new , it will differ from std:: shared_ptr < T > ( new T ( args... ) ) . std::shared_ptr supports array types (as of C++17), but std::make_shared does not. This functionality is supported by boost::make_shared . (until C++20) code such as f ( std:: shared_ptr < int > ( new int ( 42 ) ) , g ( ) ) can cause a memory leak if g gets called after new int ( 42 ) and throws an exception, while f ( std :: make_shared < int > ( 42 ) , g ( ) ) is safe, since two function calls are never interleaved . (until C++17) A constructor enables shared_from_this with a pointer ptr of type U* means that it determines if U has an unambiguous and accessible (since C++17) base class that is a specialization of std::enable_shared_from_this , and if so, the constructor evaluates if ( ptr ! = nullptr && ptr - > weak_this ﻿ . expired ( ) ) ptr - > weak_this = std:: shared_ptr < std:: remove_cv_t < U >> ( * this, const_cast < std:: remove_cv_t < U > * > ( ptr ) ) ; . The assignment to the weak_this is not atomic and conflicts with any potentially concurrent access to the same object. This ensures that future calls to shared_from_this() would share ownership with the std::shared_ptr created by this raw pointer constructor. The test ptr - > weak_this ﻿ . expired ( ) in the code above makes sure that weak_this is not reassigned if it already indicates an owner. This test is required as of C++17. Feature-test macro Value Std Feature __cpp_lib_shared_ptr_arrays 201707L (C++20) Array support of std::make_shared ; overloads ( 2-5 ) __cpp_lib_smart_ptr_for_overwrite 202002L (C++20) Smart pointer creation with default initialization ( std::allocate_shared_for_overwrite , std::make_shared_for_overwrite , std::make_unique_for_overwrite ); overloads ( 6,7 ) [ edit ] Example Run this code #include <iostream> #include <memory> #include <type_traits> #include <vector> struct C { // constructors needed (until C++20) C ( int i ) : i ( i ) { } C ( int i, float f ) : i ( i ) , f ( f ) { } int i ; float f { } ; } ; int main ( ) { // using “auto” for the type of “sp1” auto sp1 = std :: make_shared < C > ( 1 ) ; // overload (1) static_assert ( std:: is_same_v < decltype ( sp1 ) , std:: shared_ptr < C >> ) ; std:: cout << "sp1->{ i:" << sp1 - > i << ", f:" << sp1 - > f << " } \n " ; // being explicit with the type of “sp2” std:: shared_ptr < C > sp2 = std :: make_shared < C > ( 2 , 3.0f ) ; // overload (1) static_assert ( std:: is_same_v < decltype ( sp2 ) , std:: shared_ptr < C >> ) ; static_assert ( std:: is_same_v < decltype ( sp1 ) , decltype ( sp2 ) > ) ; std:: cout << "sp2->{ i:" << sp2 - > i << ", f:" << sp2 - > f << " } \n " ; // shared_ptr to a value-initialized float[64]; overload (2): std:: shared_ptr < float [ ] > sp3 = std :: make_shared < float [ ] > ( 64 ) ; // shared_ptr to a value-initialized long[5][3][4]; overload (2): std:: shared_ptr < long [ ] [ 3 ] [ 4 ] > sp4 = std :: make_shared < long [ ] [ 3 ] [ 4 ] > ( 5 ) ; // shared_ptr to a value-initialized short[128]; overload (3): std:: shared_ptr < short [ 128 ] > sp5 = std :: make_shared < short [ 128 ] > ( ) ; // shared_ptr to a value-initialized int[7][6][5]; overload (3): std:: shared_ptr < int [ 7 ] [ 6 ] [ 5 ] > sp6 = std :: make_shared < int [ 7 ] [ 6 ] [ 5 ] > ( ) ; // shared_ptr to a double[256], where each element is 2.0; overload (4): std:: shared_ptr < double [ ] > sp7 = std :: make_shared < double [ ] > ( 256 , 2.0 ) ; // shared_ptr to a double[7][2], where each double[2] // element is {3.0, 4.0}; overload (4): std:: shared_ptr < double [ ] [ 2 ] > sp8 = std :: make_shared < double [ ] [ 2 ] > ( 7 , { 3.0 , 4.0 } ) ; // shared_ptr to a vector<int>[4], where each vector // has contents {5, 6}; overload (4): std:: shared_ptr < std:: vector < int > [ ] > sp9 = std :: make_shared < std:: vector < int > [ ] > ( 4 , { 5 , 6 } ) ; // shared_ptr to a float[512], where each element is 1.0; overload (5): std:: shared_ptr < float [ 512 ] > spA = std :: make_shared < float [ 512 ] > ( 1.0 ) ; // shared_ptr to a double[6][2], where each double[2] element // is {1.0, 2.0}; overload (5): std:: shared_ptr < double [ 6 ] [ 2 ] > spB = std :: make_shared < double [ 6 ] [ 2 ] > ( { 1.0 , 2.0 } ) ; // shared_ptr to a vector<int>[4], where each vector // has contents {5, 6}; overload (5): std:: shared_ptr < std:: vector < int > [ 4 ] > spC = std :: make_shared < std:: vector < int > [ 4 ] > ( { 5 , 6 } ) ; } Output: sp1->{ i:1, f:0 } sp2->{ i:2, f:3 } [ edit ] Defect reports The following behavior-changing defect reports were applied retroactively to previously published C++ standards. DR Applied to Behavior as published Correct behavior LWG 4024 C++20 it was unclear how the objects constructed in std::make_shared_for_overwrite are destroyed made clear [ edit ] See also (constructor) constructs new shared_ptr (public member function) [edit] allocate_shared allocate_shared_for_overwrite (C++20) creates a shared pointer that manages a new object allocated using an allocator (function template) [edit] enable_shared_from_this (C++11) allows an object to create a shared_ptr referring to itself (class template) [edit] make_unique make_unique_for_overwrite (C++14) (C++20) creates a unique pointer that manages a new object (function template) [edit] operator new operator new[] allocation functions (function) [edit] Retrieved from " https://en.cppreference.com/mwiki/index.php?title=cpp/memory/shared_ptr/make_shared&oldid=180552 " Navigation Support us Recent changes FAQ Offline version Toolbox What links here Related changes Upload file Special pages Printable version Permanent link Page information In other languages Deutsch Español Français Italiano 日本語 Português Русский 中文 This page was last modified on 12 February 2025, at 02:31. Privacy policy About cppreference.com Disclaimers