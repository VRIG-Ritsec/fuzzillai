std::ranges::range - cppreference.com cppreference.com Create account Log in Namespaces Page Discussion Variants Views View Edit History Actions std::ranges:: range From cppreference.com < cpp ‎ | ranges C++ Compiler support Freestanding and hosted Language Standard library Standard library headers Named requirements Feature test macros (C++20) Language support library Concepts library (C++20) Diagnostics library Memory management library Metaprogramming library (C++11) General utilities library Containers library Iterators library Ranges library (C++20) Algorithms library Strings library Text processing library Numerics library Date and time library Input/output library Filesystem library (C++17) Concurrency support library (C++11) Execution control library (C++26) Technical specifications Symbols index External libraries [edit] Ranges library Range access begin cbegin end cend rbegin crbegin rend crend size ssize data cdata reserve_hint (C++26) empty Range conversions std::from_range_t std::from_range (C++23) (C++23) to (C++23) Dangling iterator handling dangling borrowed_iterator_t borrowed_subrange_t Range primitives range_size_t range_difference_t range_value_t elements_of (C++23) iterator_t const_iterator_t sentinel_t const_sentinel_t (C++23) (C++23) range_reference_t range_const_reference_t range_rvalue_reference_t range_common_reference_t (C++23) Range concepts range borrowed_range common_range sized_range viewable_range view input_range output_range forward_range bidirectional_range random_access_range contiguous_range approximately_sized_range (C++26) constant_range (C++23) Views view_interface subrange Range factories empty_view views::empty single_view views::single basic_istream_view views::istream iota_view views::iota repeat_view views::repeat (C++23) (C++23) Range adaptors views::all_t views::all as_rvalue_view views::as_rvalue (C++23) (C++23) filter_view views::filter transform_view views::transform take_view views::take take_while_view views::take_while common_view views::common views::counted to_input_view views::to_input (C++26) (C++26) ref_view drop_view views::drop drop_while_view views::drop_while lazy_split_view views::lazy_split split_view views::split join_view views::join join_with_view views::join_with (C++23) (C++23) concat_view views::concat (C++26) (C++26) cache_latest_view views::cache_latest (C++26) (C++26) owning_view reverse_view views::reverse as_const_view views::as_const (C++23) (C++23) elements_view views::elements keys_view views::keys values_view views::values enumerate_view views::enumerate (C++23) (C++23) zip_view views::zip (C++23) (C++23) zip_transform_view views::zip_transform (C++23) (C++23) adjacent_view views::adjacent (C++23) (C++23) views::pairwise (C++23) adjacent_transform_view views::adjacent_transform (C++23) (C++23) views::pairwise_transform (C++23) chunk_view views::chunk (C++23) (C++23) slide_view views::slide (C++23) (C++23) chunk_by_view views::chunk_by (C++23) (C++23) stride_view views::stride (C++23) (C++23) cartesian_product_view views::cartesian_product (C++23) (C++23) Range generators std::generator (C++23) Range adaptor closure objects range_adaptor_closure (C++23) Range adaptor objects Helper items copyable-box movable-box (until C++23) (C++23) simple-view non-propagating-cache [edit] Defined in header <ranges> template < class T > concept range = requires ( T & t ) { ranges:: begin ( t ) ; // equality-preserving for forward iterators ranges:: end ( t ) ; } ; (since C++20) The range concept defines the requirements of a type that allows iteration over its elements by providing an iterator and sentinel that denote the elements of the range. Contents 1 Semantic requirements 2 Notes 3 Example 4 Defect reports [ edit ] Semantic requirements Given an expression E such that decltype ( ( E ) ) is T , T models range only if [ ranges:: begin ( E ) , ranges:: end ( E ) ) denotes a range , and both ranges:: begin ( E ) and ranges:: end ( E ) are amortized constant time and do not alter the value of E in a manner observable to equality-preserving expressions, and if the type of ranges:: begin ( E ) models forward_iterator , ranges:: begin ( E ) is equality-preserving (in other words, forward iterators support multi-pass algorithms). [ edit ] Notes A typical range class only needs to provide two functions: A member function begin() whose return type models input_or_output_iterator . A member function end() whose return type models sentinel_for <It> , where It is the return type of begin() . Alternatively, they can be non-member functions, to be found by argument-dependent lookup . [ edit ] Example Run this code #include <ranges> // A minimum range struct SimpleRange { int * begin ( ) ; int * end ( ) ; } ; static_assert ( std :: ranges :: range < SimpleRange > ) ; // Not a range: no begin/end struct NotRange { int t { } ; } ; static_assert ( ! std :: ranges :: range < NotRange > ) ; // Not a range: begin does not return an input_or_output_iterator struct NotRange2 { void * begin ( ) ; int * end ( ) ; } ; static_assert ( ! std :: ranges :: range < NotRange2 > ) ; int main ( ) { } [ edit ] Defect reports The following behavior-changing defect reports were applied retroactively to previously published C++ standards. DR Applied to Behavior as published Correct behavior LWG 3915 C++20 ranges:: begin ( t ) and ranges:: end ( t ) did not require implicit expression variations removed the redundant description Retrieved from " https://en.cppreference.com/mwiki/index.php?title=cpp/ranges/range&oldid=173903 " Navigation Support us Recent changes FAQ Offline version Toolbox What links here Related changes Upload file Special pages Printable version Permanent link Page information In other languages Español 日本語 Русский 中文 This page was last modified on 25 July 2024, at 08:54. Privacy policy About cppreference.com Disclaimers