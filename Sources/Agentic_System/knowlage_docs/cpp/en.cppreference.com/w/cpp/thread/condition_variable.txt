std::condition_variable - cppreference.com cppreference.com Create account Log in Namespaces Page Discussion Variants Views View Edit History Actions std:: condition_variable From cppreference.com < cpp ‎ | thread C++ Compiler support Freestanding and hosted Language Standard library Standard library headers Named requirements Feature test macros (C++20) Language support library Concepts library (C++20) Diagnostics library Memory management library Metaprogramming library (C++11) General utilities library Containers library Iterators library Ranges library (C++20) Algorithms library Strings library Text processing library Numerics library Date and time library Input/output library Filesystem library (C++17) Concurrency support library (C++11) Execution control library (C++26) Technical specifications Symbols index External libraries [edit] Concurrency support library Threads thread (C++11) jthread (C++20) hardware_destructive_interference_size hardware_constructive_interference_size (C++17) (C++17) this_thread namespace get_id (C++11) yield (C++11) sleep_for (C++11) sleep_until (C++11) Cooperative cancellation stop_token (C++20) inplace_stop_token (C++26) never_stop_token (C++26) stop_source (C++20) inplace_stop_source (C++26) stop_callback (C++20) inplace_stop_callback (C++26) stop_callback_for_t (C++26) stoppable_token (C++26) unstoppable_token (C++26) stoppable-source (C++26) stoppable-callback-for (C++26) Mutual exclusion mutex (C++11) recursive_mutex (C++11) shared_mutex (C++17) timed_mutex (C++11) recursive_timed_mutex (C++11) shared_timed_mutex (C++14) Generic lock management lock (C++11) lock_guard (C++11) scoped_lock (C++17) unique_lock (C++11) shared_lock (C++14) once_flag (C++11) call_once (C++11) try_lock (C++11) defer_lock try_to_lock adopt_lock defer_lock_t try_to_lock_t adopt_lock_t (C++11) (C++11) (C++11) (C++11) (C++11) (C++11) Condition variables condition_variable (C++11) condition_variable_any (C++11) notify_all_at_thread_exit (C++11) cv_status (C++11) Semaphores counting_semaphore binary_semaphore (C++20) (C++20) Latches and Barriers latch (C++20) barrier (C++20) Futures promise (C++11) future (C++11) shared_future (C++11) packaged_task (C++11) async (C++11) launch (C++11) future_status (C++11) future_error (C++11) future_category (C++11) future_errc (C++11) Safe reclamation rcu_obj_base (C++26) rcu_domain (C++26) rcu_default_domain (C++26) rcu_synchronize (C++26) rcu_barrier (C++26) rcu_retire (C++26) Hazard pointers hazard_pointer_obj_base (C++26) hazard_pointer (C++26) make_hazard_pointer (C++26) Atomic types atomic (C++11) atomic_ref (C++20) atomic_flag (C++11) Initialization of atomic types atomic_init (C++11) (deprecated in C++20) ATOMIC_VAR_INIT (C++11) (deprecated in C++20) ATOMIC_FLAG_INIT (C++11) Memory ordering memory_order (C++11) kill_dependency (C++11) (deprecated in C++26) atomic_thread_fence (C++11) atomic_signal_fence (C++11) Free functions for atomic operations atomic_store atomic_store_explicit (C++11) (C++11) atomic_load atomic_load_explicit (C++11) (C++11) atomic_exchange atomic_exchange_explicit (C++11) (C++11) atomic_compare_exchange_weak atomic_compare_exchange_weak_explicit atomic_compare_exchange_strong atomic_compare_exchange_strong_explicit (C++11) (C++11) (C++11) (C++11) atomic_fetch_add atomic_fetch_add_explicit (C++11) (C++11) atomic_fetch_sub atomic_fetch_sub_explicit (C++11) (C++11) atomic_fetch_and atomic_fetch_and_explicit (C++11) (C++11) atomic_fetch_or atomic_fetch_or_explicit (C++11) (C++11) atomic_fetch_xor atomic_fetch_xor_explicit (C++11) (C++11) atomic_fetch_max atomic_fetch_max_explicit (C++26) (C++26) atomic_fetch_min atomic_fetch_min_explicit (C++26) (C++26) atomic_is_lock_free (C++11) atomic_wait atomic_wait_explicit (C++20) (C++20) atomic_notify_one (C++20) atomic_notify_all (C++20) Free functions for atomic flags atomic_flag_test_and_set atomic_flag_test_and_set_explicit (C++11) (C++11) atomic_flag_clear atomic_flag_clear_explicit (C++11) (C++11) atomic_flag_test atomic_flag_test_explicit (C++20) (C++20) atomic_flag_wait atomic_flag_wait_explicit (C++20) (C++20) atomic_flag_notify_one (C++20) atomic_flag_notify_all (C++20) [edit] std::condition_variable Member functions condition_variable::condition_variable condition_variable::~condition_variable Notification condition_variable::notify_one condition_variable::notify_all Waiting condition_variable::wait condition_variable::wait_for condition_variable::wait_until Native handle condition_variable::native handle [edit] Defined in header <condition_variable> class condition_variable ; (since C++11) std::condition_variable is a synchronization primitive used with a std::mutex to block one or more threads until another thread both modifies a shared variable (the condition ) and notifies the std::condition_variable . The thread that intends to modify the shared variable must: Acquire a std::mutex (typically via std::lock_guard ). Modify the shared variable while the lock is owned. Call notify_one or notify_all on the std::condition_variable (can be done after releasing the lock). Even if the shared variable is atomic, it must be modified while owning the mutex to correctly publish the modification to the waiting thread. Any thread that intends to wait on a std::condition_variable must: Acquire a std:: unique_lock < std:: mutex > on the mutex used to protect the shared variable. Do one of the following: Check the condition, in case it was already updated and notified. Call wait , wait_for , or wait_until on the std::condition_variable (atomically releases the mutex and suspends thread execution until the condition variable is notified, a timeout expires, or a spurious wakeup occurs, then atomically acquires the mutex before returning). Check the condition and resume waiting if not satisfied. or: Use the predicated overload of wait , wait_for , and wait_until , which performs the same three steps. std::condition_variable works only with std:: unique_lock < std:: mutex > , which allows for maximal efficiency on some platforms. std::condition_variable_any provides a condition variable that works with any BasicLockable object, such as std::shared_lock . Condition variables permit concurrent invocation of the wait , wait_for , wait_until , notify_one and notify_all member functions. The class std::condition_variable is a StandardLayoutType . It is not CopyConstructible , MoveConstructible , CopyAssignable , or MoveAssignable . Contents 1 Nested types 2 Member functions 2.1 Notification 2.2 Waiting 2.3 Native handle 3 Example 4 See also [ edit ] Nested types Name Definition native_handle_type implementation-defined [ edit ] Member functions (constructor) constructs the object (public member function) [edit] (destructor) destructs the object (public member function) [edit] operator= [deleted] not copy-assignable (public member function) [edit] Notification notify_one notifies one waiting thread (public member function) [edit] notify_all notifies all waiting threads (public member function) [edit] Waiting wait blocks the current thread until the condition variable is awakened (public member function) [edit] wait_for blocks the current thread until the condition variable is awakened or after the specified timeout duration (public member function) [edit] wait_until blocks the current thread until the condition variable is awakened or until specified time point has been reached (public member function) [edit] Native handle native_handle returns the native handle (public member function) [edit] [ edit ] Example std::condition_variable is used in combination with a std::mutex to facilitate inter-thread communication. Run this code #include <condition_variable> #include <iostream> #include <mutex> #include <string> #include <thread> std:: mutex m ; std :: condition_variable cv ; std:: string data ; bool ready = false ; bool processed = false ; void worker_thread ( ) { // wait until main() sends data std:: unique_lock lk ( m ) ; cv. wait ( lk, [ ] { return ready ; } ) ; // after the wait, we own the lock std:: cout << "Worker thread is processing data \n " ; data + = " after processing" ; // send data back to main() processed = true ; std:: cout << "Worker thread signals data processing completed \n " ; // manual unlocking is done before notifying, to avoid waking up // the waiting thread only to block again (see notify_one for details) lk. unlock ( ) ; cv. notify_one ( ) ; } int main ( ) { std:: thread worker ( worker_thread ) ; data = "Example data" ; // send data to the worker thread { std:: lock_guard lk ( m ) ; ready = true ; std:: cout << "main() signals data ready for processing \n " ; } cv. notify_one ( ) ; // wait for the worker { std:: unique_lock lk ( m ) ; cv. wait ( lk, [ ] { return processed ; } ) ; } std:: cout << "Back in main(), data = " << data << ' \n ' ; worker. join ( ) ; } Output: main() signals data ready for processing Worker thread is processing data Worker thread signals data processing completed Back in main(), data = Example data after processing [ edit ] See also condition_variable_any (C++11) provides a condition variable associated with any lock type (class) [edit] mutex (C++11) provides basic mutual exclusion facility (class) [edit] lock_guard (C++11) implements a strictly scope-based mutex ownership wrapper (class template) [edit] unique_lock (C++11) implements movable mutex ownership wrapper (class template) [edit] Retrieved from " https://en.cppreference.com/mwiki/index.php?title=cpp/thread/condition_variable&oldid=170070 " Navigation Support us Recent changes FAQ Offline version Toolbox What links here Related changes Upload file Special pages Printable version Permanent link Page information In other languages Deutsch Español Français Italiano 日本語 Português Русский 中文 This page was last modified on 4 March 2024, at 23:17. Privacy policy About cppreference.com Disclaimers