std::recursive_mutex - cppreference.com cppreference.com Create account Log in Namespaces Page Discussion Variants Views View Edit History Actions std:: recursive_mutex From cppreference.com < cpp ‎ | thread C++ Compiler support Freestanding and hosted Language Standard library Standard library headers Named requirements Feature test macros (C++20) Language support library Concepts library (C++20) Diagnostics library Memory management library Metaprogramming library (C++11) General utilities library Containers library Iterators library Ranges library (C++20) Algorithms library Strings library Text processing library Numerics library Date and time library Input/output library Filesystem library (C++17) Concurrency support library (C++11) Execution control library (C++26) Technical specifications Symbols index External libraries [edit] Concurrency support library Threads thread (C++11) jthread (C++20) hardware_destructive_interference_size hardware_constructive_interference_size (C++17) (C++17) this_thread namespace get_id (C++11) yield (C++11) sleep_for (C++11) sleep_until (C++11) Cooperative cancellation stop_token (C++20) inplace_stop_token (C++26) never_stop_token (C++26) stop_source (C++20) inplace_stop_source (C++26) stop_callback (C++20) inplace_stop_callback (C++26) stop_callback_for_t (C++26) stoppable_token (C++26) unstoppable_token (C++26) stoppable-source (C++26) stoppable-callback-for (C++26) Mutual exclusion mutex (C++11) recursive_mutex (C++11) shared_mutex (C++17) timed_mutex (C++11) recursive_timed_mutex (C++11) shared_timed_mutex (C++14) Generic lock management lock (C++11) lock_guard (C++11) scoped_lock (C++17) unique_lock (C++11) shared_lock (C++14) once_flag (C++11) call_once (C++11) try_lock (C++11) defer_lock try_to_lock adopt_lock defer_lock_t try_to_lock_t adopt_lock_t (C++11) (C++11) (C++11) (C++11) (C++11) (C++11) Condition variables condition_variable (C++11) condition_variable_any (C++11) notify_all_at_thread_exit (C++11) cv_status (C++11) Semaphores counting_semaphore binary_semaphore (C++20) (C++20) Latches and Barriers latch (C++20) barrier (C++20) Futures promise (C++11) future (C++11) shared_future (C++11) packaged_task (C++11) async (C++11) launch (C++11) future_status (C++11) future_error (C++11) future_category (C++11) future_errc (C++11) Safe reclamation rcu_obj_base (C++26) rcu_domain (C++26) rcu_default_domain (C++26) rcu_synchronize (C++26) rcu_barrier (C++26) rcu_retire (C++26) Hazard pointers hazard_pointer_obj_base (C++26) hazard_pointer (C++26) make_hazard_pointer (C++26) Atomic types atomic (C++11) atomic_ref (C++20) atomic_flag (C++11) Initialization of atomic types atomic_init (C++11) (deprecated in C++20) ATOMIC_VAR_INIT (C++11) (deprecated in C++20) ATOMIC_FLAG_INIT (C++11) Memory ordering memory_order (C++11) kill_dependency (C++11) (deprecated in C++26) atomic_thread_fence (C++11) atomic_signal_fence (C++11) Free functions for atomic operations atomic_store atomic_store_explicit (C++11) (C++11) atomic_load atomic_load_explicit (C++11) (C++11) atomic_exchange atomic_exchange_explicit (C++11) (C++11) atomic_compare_exchange_weak atomic_compare_exchange_weak_explicit atomic_compare_exchange_strong atomic_compare_exchange_strong_explicit (C++11) (C++11) (C++11) (C++11) atomic_fetch_add atomic_fetch_add_explicit (C++11) (C++11) atomic_fetch_sub atomic_fetch_sub_explicit (C++11) (C++11) atomic_fetch_and atomic_fetch_and_explicit (C++11) (C++11) atomic_fetch_or atomic_fetch_or_explicit (C++11) (C++11) atomic_fetch_xor atomic_fetch_xor_explicit (C++11) (C++11) atomic_fetch_max atomic_fetch_max_explicit (C++26) (C++26) atomic_fetch_min atomic_fetch_min_explicit (C++26) (C++26) atomic_is_lock_free (C++11) atomic_wait atomic_wait_explicit (C++20) (C++20) atomic_notify_one (C++20) atomic_notify_all (C++20) Free functions for atomic flags atomic_flag_test_and_set atomic_flag_test_and_set_explicit (C++11) (C++11) atomic_flag_clear atomic_flag_clear_explicit (C++11) (C++11) atomic_flag_test atomic_flag_test_explicit (C++20) (C++20) atomic_flag_wait atomic_flag_wait_explicit (C++20) (C++20) atomic_flag_notify_one (C++20) atomic_flag_notify_all (C++20) [edit] std::recursive_mutex Member functions recursive_mutex::recursive_mutex recursive_mutex::~recursive_mutex Locking recursive_mutex::lock recursive_mutex::try_lock recursive_mutex::unlock Native handle recursive_mutex::native_handle [edit] Defined in header <mutex> class recursive_mutex ; (since C++11) The recursive_mutex class is a synchronization primitive that can be used to protect shared data from being simultaneously accessed by multiple threads. recursive_mutex offers exclusive, recursive ownership semantics: A calling thread owns a recursive_mutex for a period of time that starts when it successfully calls either lock or try_lock . During this period, the thread may make additional calls to lock or try_lock . The period of ownership ends when the thread makes a matching number of calls to unlock . When a thread owns a recursive_mutex , all other threads will block (for calls to lock ) or receive a false return value (for try_lock ) if they attempt to claim ownership of the recursive_mutex . The maximum number of times that a recursive_mutex may be locked is unspecified, but after that number is reached, calls to lock will throw std::system_error and calls to try_lock will return false . The behavior of a program is undefined if a recursive_mutex is destroyed while still owned by some thread. The recursive_mutex class satisfies all requirements of Mutex and StandardLayoutType . Contents 1 Member types 2 Member functions 2.1 Locking 2.2 Native handle 3 Example 4 See also [ edit ] Member types Member type Definition native_handle_type ( optional* ) implementation-defined [edit] [ edit ] Member functions (constructor) constructs the mutex (public member function) [edit] (destructor) destroys the mutex (public member function) [edit] operator= [deleted] not copy-assignable (public member function) [edit] Locking lock locks the mutex, blocks if the mutex is not available (public member function) [edit] try_lock tries to lock the mutex, returns if the mutex is not available (public member function) [edit] unlock unlocks the mutex (public member function) [edit] Native handle native_handle returns the underlying implementation-defined native handle object (public member function) [edit] [ edit ] Example One use case for recursive_mutex is protecting shared state in a class whose member functions may call each other. Run this code #include <iostream> #include <mutex> #include <thread> class X { std :: recursive_mutex m ; std:: string shared ; public : void fun1 ( ) { std:: lock_guard < std :: recursive_mutex > lk ( m ) ; shared = "fun1" ; std:: cout << "in fun1, shared variable is now " << shared << ' \n ' ; } void fun2 ( ) { std:: lock_guard < std :: recursive_mutex > lk ( m ) ; shared = "fun2" ; std:: cout << "in fun2, shared variable is now " << shared << ' \n ' ; fun1 ( ) ; // recursive lock becomes useful here std:: cout << "back in fun2, shared variable is " << shared << ' \n ' ; } } ; int main ( ) { X x ; std:: thread t1 ( & X :: fun1 , & x ) ; std:: thread t2 ( & X :: fun2 , & x ) ; t1. join ( ) ; t2. join ( ) ; } Possible output: in fun1, shared variable is now fun1 in fun2, shared variable is now fun2 in fun1, shared variable is now fun1 back in fun2, shared variable is fun1 [ edit ] See also mutex (C++11) provides basic mutual exclusion facility (class) [edit] Retrieved from " https://en.cppreference.com/mwiki/index.php?title=cpp/thread/recursive_mutex&oldid=161215 " Navigation Support us Recent changes FAQ Offline version Toolbox What links here Related changes Upload file Special pages Printable version Permanent link Page information In other languages Deutsch Español Français Italiano 日本語 Português Русский 中文 This page was last modified on 23 October 2023, at 03:46. Privacy policy About cppreference.com Disclaimers