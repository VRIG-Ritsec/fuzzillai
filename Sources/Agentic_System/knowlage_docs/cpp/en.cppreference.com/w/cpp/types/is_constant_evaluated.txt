std::is_constant_evaluated - cppreference.com cppreference.com Create account Log in Namespaces Page Discussion Variants Views View Edit History Actions std:: is_constant_evaluated From cppreference.com < cpp ‎ | types C++ Compiler support Freestanding and hosted Language Standard library Standard library headers Named requirements Feature test macros (C++20) Language support library Concepts library (C++20) Diagnostics library Memory management library Metaprogramming library (C++11) General utilities library Containers library Iterators library Ranges library (C++20) Algorithms library Strings library Text processing library Numerics library Date and time library Input/output library Filesystem library (C++17) Concurrency support library (C++11) Execution control library (C++26) Technical specifications Symbols index External libraries [edit] Utilities library Language support Type support (basic types, RTTI) Library feature-test macros (C++20) Program utilities Variadic functions initializer_list (C++11) is_constant_evaluated (C++20) is_within_lifetime (C++26) source_location (C++20) Coroutine support (C++20) Contract support (C++26) Three-way comparison three_way_comparable three_way_comparable_with (C++20) (C++20) strong_ordering (C++20) weak_ordering (C++20) partial_ordering (C++20) common_comparison_category (C++20) compare_three_way_result (C++20) compare_three_way (C++20) strong_order (C++20) weak_order (C++20) partial_order (C++20) compare_strong_order_fallback (C++20) compare_weak_order_fallback (C++20) compare_partial_order_fallback (C++20) is_eq is_lt is_lteq (C++20) (C++20) (C++20) is_neq is_gt is_gteq (C++20) (C++20) (C++20) General utilities Function objects Bit manipulation (C++20) C-style bit manipulation (C++26) bitset hash (C++11) Relational operators (deprecated in C++20) rel_ops::operator!= rel_ops::operator> rel_ops::operator<= rel_ops::operator>= Integer comparison functions cmp_equal cmp_less cmp_less_than (C++20) (C++20) (C++20) cmp_not_equal cmp_greater cmp_greater_than (C++20) (C++20) (C++20) in_range (C++20) Swap and type operations swap ranges::swap (C++20) exchange (C++14) declval (C++11) to_underlying (C++23) forward (C++11) forward_like (C++23) move (C++11) move_if_noexcept (C++11) as_const (C++17) Common vocabulary types pair tuple (C++11) optional (C++17) any (C++17) variant (C++17) tuple_size (C++11) tuple_element (C++11) apply (C++17) make_from_tuple (C++17) expected (C++23) [edit] Defined in header <type_traits> constexpr bool is_constant_evaluated ( ) noexcept ; (since C++20) Detects whether the function call occurs within a constant-evaluated context. Returns true if the evaluation of the call occurs within the evaluation of an expression or conversion that is manifestly constant-evaluated ; otherwise returns false . To determine whether initializers of following variables are manifestly constant-evaluated, compilers may first perform a trial constant evaluation: variables with reference type or const-qualified integral or enumeration type; static and thread local variables. It is not recommended to depend on the result in this case. int y = 0 ; const int a = std :: is_constant_evaluated ( ) ? y : 1 ; // Trial constant evaluation fails. The constant evaluation is discarded. // Variable a is dynamically initialized with 1 const int b = std :: is_constant_evaluated ( ) ? 2 : y ; // Constant evaluation with std::is_constant_evaluated() == true succeeds. // Variable b is statically initialized with 2 Contents 1 Parameters 2 Return value 3 Possible implementation 4 Notes 5 Example 6 See also [ edit ] Parameters (none) [ edit ] Return value true if the evaluation of the call occurs within the evaluation of an expression or conversion that is manifestly constant-evaluated; otherwise false . [ edit ] Possible implementation // This implementation requires C++23 if consteval. constexpr bool is_constant_evaluated ( ) noexcept { if consteval { return true ; } else { return false ; } } [ edit ] Notes When directly used as the condition of static_assert declaration or constexpr if statement , std :: is_constant_evaluated ( ) always returns true . Because if consteval is absent in C++20, std::is_constant_evaluated is typically implemented using a compiler extension. Feature-test macro Value Std Feature __cpp_lib_is_constant_evaluated 201811L (C++20) std::is_constant_evaluated [ edit ] Example Run this code #include <cmath> #include <iostream> #include <type_traits> constexpr double power ( double b, int x ) { if ( std :: is_constant_evaluated ( ) && ! ( b == 0.0 && x < 0 ) ) { // A constant-evaluation context: Use a constexpr-friendly algorithm. if ( x == 0 ) return 1.0 ; double r { 1.0 } ; double p { x > 0 ? b : 1.0 / b } ; for ( auto u = unsigned ( x > 0 ? x : - x ) ; u ! = 0 ; u / = 2 ) { if ( u & 1 ) r * = p ; p * = p ; } return r ; } else { // Let the code generator figure it out. return std:: pow ( b, double ( x ) ) ; } } int main ( ) { // A constant-expression context constexpr double kilo = power ( 10.0 , 3 ) ; int n = 3 ; // Not a constant expression, because n cannot be converted to an rvalue // in a constant-expression context // Equivalent to std::pow(10.0, double(n)) double mucho = power ( 10.0 , n ) ; std:: cout << kilo << " " << mucho << " \n " ; // (3) } Output: 1000 1000 [ edit ] See also constexpr specifier (C++11) specifies that the value of a variable or function can be computed at compile time [edit] consteval specifier (C++20) specifies that a function is an immediate function , that is, every call to the function must be in a constant evaluation [edit] constinit specifier (C++20) asserts that a variable has static initialization, i.e. zero initialization and constant initialization [edit] Retrieved from " https://en.cppreference.com/mwiki/index.php?title=cpp/types/is_constant_evaluated&oldid=179319 " Navigation Support us Recent changes FAQ Offline version Toolbox What links here Related changes Upload file Special pages Printable version Permanent link Page information In other languages Español 日本語 Русский 中文 This page was last modified on 6 January 2025, at 09:17. Privacy policy About cppreference.com Disclaimers