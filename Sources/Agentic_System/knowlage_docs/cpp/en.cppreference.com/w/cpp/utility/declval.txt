std::declval - cppreference.com cppreference.com Create account Log in Namespaces Page Discussion Variants Views View Edit History Actions std:: declval From cppreference.com < cpp ‎ | utility C++ Compiler support Freestanding and hosted Language Standard library Standard library headers Named requirements Feature test macros (C++20) Language support library Concepts library (C++20) Diagnostics library Memory management library Metaprogramming library (C++11) General utilities library Containers library Iterators library Ranges library (C++20) Algorithms library Strings library Text processing library Numerics library Date and time library Input/output library Filesystem library (C++17) Concurrency support library (C++11) Execution control library (C++26) Technical specifications Symbols index External libraries [edit] Utilities library Language support Type support (basic types, RTTI) Library feature-test macros (C++20) Program utilities Variadic functions initializer_list (C++11) is_constant_evaluated (C++20) is_within_lifetime (C++26) source_location (C++20) Coroutine support (C++20) Contract support (C++26) Three-way comparison three_way_comparable three_way_comparable_with (C++20) (C++20) strong_ordering (C++20) weak_ordering (C++20) partial_ordering (C++20) common_comparison_category (C++20) compare_three_way_result (C++20) compare_three_way (C++20) strong_order (C++20) weak_order (C++20) partial_order (C++20) compare_strong_order_fallback (C++20) compare_weak_order_fallback (C++20) compare_partial_order_fallback (C++20) is_eq is_lt is_lteq (C++20) (C++20) (C++20) is_neq is_gt is_gteq (C++20) (C++20) (C++20) General utilities Function objects Bit manipulation (C++20) C-style bit manipulation (C++26) bitset hash (C++11) Relational operators (deprecated in C++20) rel_ops::operator!= rel_ops::operator> rel_ops::operator<= rel_ops::operator>= Integer comparison functions cmp_equal cmp_less cmp_less_than (C++20) (C++20) (C++20) cmp_not_equal cmp_greater cmp_greater_than (C++20) (C++20) (C++20) in_range (C++20) Swap and type operations swap ranges::swap (C++20) exchange (C++14) declval (C++11) to_underlying (C++23) forward (C++11) forward_like (C++23) move (C++11) move_if_noexcept (C++11) as_const (C++17) Common vocabulary types pair tuple (C++11) optional (C++17) any (C++17) variant (C++17) tuple_size (C++11) tuple_element (C++11) apply (C++17) make_from_tuple (C++17) expected (C++23) [edit] Defined in header <utility> template < class T > typename std:: add_rvalue_reference < T > :: type declval ( ) noexcept ; (since C++11) (until C++14) (unevaluated-only) template < class T > std:: add_rvalue_reference_t < T > declval ( ) noexcept ; (since C++14) (unevaluated-only) Helper template for writing expressions that appear in unevaluated contexts , typically the operand of decltype . In unevaluated context, this helper template converts any type T (which may be an incomplete type) to an expression of that type, making it possible to use member functions of T without the need to go through constructors. std::declval can only be used in unevaluated contexts and is not required to be defined; it is an error to evaluate an expression that contains this function. Formally, the program is ill-formed if this function is odr-used . Contents 1 Parameters 2 Return value 3 Notes 4 Possible implementation 5 Example 6 See also [ edit ] Parameters (none) [ edit ] Return value Cannot be evaluated and thus never returns a value. The return type is T&& (reference collapsing rules apply) unless T is (possibly cv-qualified) void , in which case the return type is T . [ edit ] Notes std::declval is commonly used in templates where acceptable template parameters may have no constructor in common, but have the same member function whose return type is needed. [ edit ] Possible implementation template < typename T > typename std:: add_rvalue_reference < T > :: type declval ( ) noexcept { static_assert ( false , "declval not allowed in an evaluated context" ) ; } [ edit ] Example Run this code #include <iostream> #include <utility> struct Default { int foo ( ) const { return 1 ; } } ; struct NonDefault { NonDefault ( ) = delete ; int foo ( ) const { return 1 ; } } ; int main ( ) { decltype ( Default ( ) . foo ( ) ) n1 = 1 ; // type of n1 is int decltype ( std :: declval < Default > ( ) . foo ( ) ) n2 = 1 ; // same // decltype(NonDefault().foo()) n3 = n1; // error: no default constructor decltype ( std :: declval < NonDefault > ( ) . foo ( ) ) n3 = n1 ; // type of n3 is int std:: cout << "n1 = " << n1 << ' \n ' << "n2 = " << n2 << ' \n ' << "n3 = " << n3 << ' \n ' ; } Output: n1 = 1 n2 = 1 n3 = 1 [ edit ] See also decltype specifier (C++11) obtains the type of an expression or an entity [edit] result_of invoke_result (C++11) (removed in C++20) (C++17) deduces the result type of invoking a callable object with a set of arguments (class template) [edit] Retrieved from " https://en.cppreference.com/mwiki/index.php?title=cpp/utility/declval&oldid=177822 " Navigation Support us Recent changes FAQ Offline version Toolbox What links here Related changes Upload file Special pages Printable version Permanent link Page information In other languages Deutsch Español Français Italiano 日本語 Português Русский 中文 This page was last modified on 23 November 2024, at 17:19. Privacy policy About cppreference.com Disclaimers