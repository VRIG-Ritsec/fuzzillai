Expressions and operators - JavaScript | MDN Skip to main content Skip to search MDN HTML HTML: Markup language HTML reference Elements Global attributes Attributes See all… HTML guides Responsive images HTML cheatsheet Date & time formats See all… Markup languages SVG MathML XML CSS CSS: Styling language CSS reference Properties Selectors At-rules Values & units See all… CSS guides Box model Animations Flexbox Colors See all… Layout cookbook Column layouts Centering an element Card component See all… JavaScript JS JavaScript: Scripting language JS reference Standard built-in objects Expressions & operators Statements & declarations Functions See all… JS guides Control flow & error handing Loops and iteration Working with objects Using classes See all… Web APIs Web APIs: Programming interfaces Web API reference File system API Fetch API Geolocation API HTML DOM API Push API Service worker API See all… Web API guides Using the Web animation API Using the Fetch API Working with the History API Using the Web speech API Using web workers All All web technology Technologies Accessibility HTTP URI Web extensions WebAssembly WebDriver See all… Topics Media Performance Privacy Security Progressive web apps Learn Learn web development Frontend developer course Getting started Common questions Curriculum Learn HTML Introduction to HTML Getting started with HTML Learn CSS What is CSS Getting started with CSS Learn JavaScript How to use data attributes Add JavaScript to your web page Tools Discover our tools Playground HTTP Observatory Border-image generator Border-radius generator Box-shadow generator Color format converter Color mixer Shape generator About Get to know MDN better About MDN Advertise with us Community MDN on GitHub Blog Toggle sidebar Web JavaScript Guide Expressions and operators Theme OS default Light Dark English (US) Remember language Learn more Deutsch English (US) Español Français 日本語 한국어 Português (do Brasil) Русский 中文 (简体) 正體中文 (繁體) Expressions and operators Previous Next This chapter describes JavaScript's expressions and operators, including assignment, comparison, arithmetic, bitwise, logical, string, ternary and more. At a high level, an expression is a valid unit of code that resolves to a value. There are two types of expressions: those that have side effects (such as assigning values) and those that purely evaluate . The expression x = 7 is an example of the first type. This expression uses the = operator to assign the value seven to the variable x . The expression itself evaluates to 7 . The expression 3 + 4 is an example of the second type. This expression uses the + operator to add 3 and 4 together and produces a value, 7 . However, if it's not eventually part of a bigger construct (for example, a variable declaration like const z = 3 + 4 ), its result will be immediately discarded — this is usually a programmer mistake because the evaluation doesn't produce any effects. As the examples above also illustrate, all complex expressions are joined by operators , such as = and + . In this section, we will introduce the following operators: Assignment operators Comparison operators Arithmetic operators Bitwise operators Logical operators BigInt operators String operators Conditional (ternary) operator Comma operator Unary operators Relational operators These operators join operands either formed by higher-precedence operators or one of the basic expressions . A complete and detailed list of operators and expressions is also available in the reference . The precedence of operators determines the order they are applied when evaluating an expression. For example: js const x = 1 + 2 * 3; const y = 2 * 3 + 1; Despite * and + coming in different orders, both expressions would result in 7 because * has precedence over + , so the * -joined expression will always be evaluated first. You can override operator precedence by using parentheses (which creates a grouped expression — the basic expression). To see a complete table of operator precedence as well as various caveats, see the Operator Precedence Reference page. JavaScript has both binary and unary operators, and one special ternary operator, the conditional operator. A binary operator requires two operands, one before the operator and one after the operator: operand1 operator operand2 For example, 3 + 4 or x * y . This form is called an infix binary operator, because the operator is placed between two operands. All binary operators in JavaScript are infix. A unary operator requires a single operand, either before or after the operator: operator operand operand operator For example, x++ or ++x . The operator operand form is called a prefix unary operator, and the operand operator form is called a postfix unary operator. ++ and -- are the only postfix operators in JavaScript — all other operators, like ! , typeof , etc. are prefix. In this article Assignment operators Comparison operators Arithmetic operators Bitwise operators Logical operators BigInt operators String operators Conditional (ternary) operator Comma operator Unary operators Relational operators Basic expressions Assignment operators An assignment operator assigns a value to its left operand based on the value of its right operand. The simple assignment operator is equal ( = ), which assigns the value of its right operand to its left operand. That is, x = f() is an assignment expression that assigns the value of f() to x . There are also compound assignment operators that are shorthand for the operations listed in the following table: Name Shorthand operator Meaning Assignment x = f() x = f() Addition assignment x += f() x = x + f() Subtraction assignment x -= f() x = x - f() Multiplication assignment x *= f() x = x * f() Division assignment x /= f() x = x / f() Remainder assignment x %= f() x = x % f() Exponentiation assignment x **= f() x = x ** f() Left shift assignment x <<= f() x = x << f() Right shift assignment x >>= f() x = x >> f() Unsigned right shift assignment x >>>= f() x = x >>> f() Bitwise AND assignment x &= f() x = x & f() Bitwise XOR assignment x ^= f() x = x ^ f() Bitwise OR assignment x |= f() x = x | f() Logical AND assignment x &&= f() x && (x = f()) Logical OR assignment x ||= f() x || (x = f()) Nullish coalescing assignment x ??= f() x ?? (x = f()) Assigning to properties If an expression evaluates to an object , then the left-hand side of an assignment expression may make assignments to properties of that expression. For example: js const obj = {}; obj.x = 3; console.log(obj.x); // Prints 3. console.log(obj); // Prints { x: 3 }. const key = "y"; obj[key] = 5; console.log(obj[key]); // Prints 5. console.log(obj); // Prints { x: 3, y: 5 }. For more information about objects, read Working with Objects . If an expression does not evaluate to an object, then assignments to properties of that expression do not assign: js const val = 0; val.x = 3; console.log(val.x); // Prints undefined. console.log(val); // Prints 0. In strict mode , the code above throws, because one cannot assign properties to primitives. It is an error to assign values to unmodifiable properties or to properties of an expression without properties ( null or undefined ). Destructuring For more complex assignments, the destructuring syntax is a JavaScript expression that makes it possible to extract data from arrays or objects using a syntax that mirrors the construction of array and object literals. Without destructuring, it takes multiple statements to extract values from arrays and objects: js const foo = ["one", "two", "three"]; const one = foo[0]; const two = foo[1]; const three = foo[2]; With destructuring, you can extract multiple values into distinct variables using a single statement: js const [one, two, three] = foo; Evaluation and nesting In general, assignments are used within a variable declaration (i.e., with const , let , or var ) or as standalone statements. js // Declares a variable x and initializes it to the result of f(). // The result of the x = f() assignment expression is discarded. let x = f(); x = g(); // Reassigns the variable x to the result of g(). However, like other expressions, assignment expressions like x = f() evaluate into a result value. Although this result value is usually not used, it can then be used by another expression. Chaining assignments or nesting assignments in other expressions can result in surprising behavior. For this reason, some JavaScript style guides discourage chaining or nesting assignments . Nevertheless, assignment chaining and nesting may occur sometimes, so it is important to be able to understand how they work. By chaining or nesting an assignment expression, its result can itself be assigned to another variable. It can be logged, it can be put inside an array literal or function call, and so on. js let x; const y = (x = f()); // Or equivalently: const y = x = f(); console.log(y); // Logs the return value of the assignment x = f(). console.log(x = f()); // Logs the return value directly. // An assignment expression can be nested in any place // where expressions are generally allowed, // such as array literals' elements or as function calls' arguments. console.log([0, x = f(), 0]); console.log(f(0, x = f(), 0)); The evaluation result matches the expression to the right of the = sign in the "Meaning" column of the table above. That means that x = f() evaluates into whatever f() 's result is, x += f() evaluates into the resulting sum x + f() , x **= f() evaluates into the resulting power x ** f() , and so on. In the case of logical assignments, x &&= f() , x ||= f() , and x ??= f() , the return value is that of the logical operation without the assignment, so x && f() , x || f() , and x ?? f() , respectively. When chaining these expressions without parentheses or other grouping operators like array literals, the assignment expressions are grouped right to left (they are right-associative ), but they are evaluated left to right . Note that, for all assignment operators other than = itself, the resulting values are always based on the operands' values before the operation. For example, assume that the following functions f and g and the variables x and y have been declared: js function f() { console.log("F!"); return 2; } function g() { console.log("G!"); return 3; } let x, y; Consider these three examples: js y = x = f(); y = [f(), x = g()]; x[f()] = g(); Evaluation example 1 y = x = f() is equivalent to y = (x = f()) , because the assignment operator = is right-associative . However, it evaluates from left to right: The assignment expression y = x = f() starts to evaluate. The y on this assignment's left-hand side evaluates into a reference to the variable named y . The assignment expression x = f() starts to evaluate. The x on this assignment's left-hand side evaluates into a reference to the variable named x . The function call f() prints "F!" to the console and then evaluates to the number 2 . That 2 result from f() is assigned to x . The assignment expression x = f() has now finished evaluating; its result is the new value of x , which is 2 . That 2 result in turn is also assigned to y . The assignment expression y = x = f() has now finished evaluating; its result is the new value of y – which happens to be 2 . x and y are assigned to 2 , and the console has printed "F!". Evaluation example 2 y = [ f(), x = g() ] also evaluates from left to right: The assignment expression y = [ f(), x = g() ] starts to evaluate. The y on this assignment's left-hand evaluates into a reference to the variable named y . The inner array literal [ f(), x = g() ] starts to evaluate. The function call f() prints "F!" to the console and then evaluates to the number 2 . The assignment expression x = g() starts to evaluate. The x on this assignment's left-hand side evaluates into a reference to the variable named x . The function call g() prints "G!" to the console and then evaluates to the number 3 . That 3 result from g() is assigned to x . The assignment expression x = g() has now finished evaluating; its result is the new value of x , which is 3 . That 3 result becomes the next element in the inner array literal (after the 2 from the f() ). The inner array literal [ f(), x = g() ] has now finished evaluating; its result is an array with two values: [ 2, 3 ] . That [ 2, 3 ] array is now assigned to y . The assignment expression y = [ f(), x = g() ] has now finished evaluating; its result is the new value of y – which happens to be [ 2, 3 ] . x is now assigned to 3 , y is now assigned to [ 2, 3 ] , and the console has printed "F!" then "G!". Evaluation example 3 x[f()] = g() also evaluates from left to right. (This example assumes that x is already assigned to some object. For more information about objects, read Working with Objects .) The assignment expression x[f()] = g() starts to evaluate. The x[f()] property access on this assignment's left-hand starts to evaluate. The x in this property access evaluates into a reference to the variable named x . Then the function call f() prints "F!" to the console and then evaluates to the number 2 . The x[f()] property access on this assignment has now finished evaluating; its result is a variable property reference: x[2] . Then the function call g() prints "G!" to the console and then evaluates to the number 3 . That 3 is now assigned to x[2] . (This step will succeed only if x is assigned to an object .) The assignment expression x[f()] = g() has now finished evaluating; its result is the new value of x[2] – which happens to be 3 . x[2] is now assigned to 3 , and the console has printed "F!" then "G!". Avoid assignment chains Chaining assignments or nesting assignments in other expressions can result in surprising behavior. For this reason, chaining assignments in the same statement is discouraged . In particular, putting a variable chain in a const , let , or var statement often does not work. Only the outermost/leftmost variable would get declared; other variables within the assignment chain are not declared by the const / let / var statement. For example: js const z = y = x = f(); This statement seemingly declares the variables x , y , and z . However, it only actually declares the variable z . y and x are either invalid references to nonexistent variables (in strict mode ) or, worse, would implicitly create global variables for x and y in sloppy mode . Comparison operators A comparison operator compares its operands and returns a logical value based on whether the comparison is true. The operands can be numerical, string, logical, or object values. Strings are compared based on standard lexicographical ordering, using Unicode values. In most cases, if the two operands are not of the same type, JavaScript attempts to convert them to an appropriate type for the comparison. This behavior generally results in comparing the operands numerically. The sole exceptions to type conversion within comparisons involve the === and !== operators, which perform strict equality and inequality comparisons. These operators do not attempt to convert the operands to compatible types before checking equality. The following table describes the comparison operators in terms of this sample code: js const var1 = 3; const var2 = 4; Comparison operators Operator Description Examples returning true Equal ( == ) Returns true if the operands are equal. 3 == var1 "3" == var1 3 == '3' Not equal ( != ) Returns true if the operands are not equal. var1 != 4 var2 != "3" Strict equal ( === ) Returns true if the operands are equal and of the same type. See also Object.is and sameness in JS . 3 === var1 Strict not equal ( !== ) Returns true if the operands are of the same type but not equal, or are of different type. var1 !== "3" 3 !== '3' Greater than ( > ) Returns true if the left operand is greater than the right operand. var2 > var1 "12" > 2 Greater than or equal ( >= ) Returns true if the left operand is greater than or equal to the right operand. var2 >= var1 var1 >= 3 Less than ( < ) Returns true if the left operand is less than the right operand. var1 < var2 "2" < 12 Less than or equal ( <= ) Returns true if the left operand is less than or equal to the right operand. var1 <= var2 var2 <= 5 Note: => is not a comparison operator but rather is the notation for Arrow functions . Arithmetic operators An arithmetic operator takes numerical values (either literals or variables) as their operands and returns a single numerical value. The standard arithmetic operators are addition ( + ), subtraction ( - ), multiplication ( * ), and division ( / ). These operators work as they do in most other programming languages when used with floating point numbers (in particular, note that division by zero produces Infinity ). For example: js 1 / 2; // 0.5 1 / 2 === 1.0 / 2.0; // this is true In addition to the standard arithmetic operations ( + , - , * , / ), JavaScript provides the arithmetic operators listed in the following table: Arithmetic operators Operator Description Example Remainder ( % ) Binary operator. Returns the integer remainder of dividing the two operands. 12 % 5 returns 2. Increment ( ++ ) Unary operator. Adds one to its operand. If used as a prefix operator ( ++x ), returns the value of its operand after adding one; if used as a postfix operator ( x++ ), returns the value of its operand before adding one. If x is 3, then ++x sets x to 4 and returns 4, whereas x++ returns 3 and, only then, sets x to 4. Decrement ( -- ) Unary operator. Subtracts one from its operand. The return value is analogous to that for the increment operator. If x is 3, then --x sets x to 2 and returns 2, whereas x-- returns 3 and, only then, sets x to 2. Unary negation ( - ) Unary operator. Returns the negation of its operand. If x is 3, then -x returns -3. Unary plus ( + ) Unary operator. Attempts to convert the operand to a number , if it is not already. +"3" returns 3 . +true returns 1 . Exponentiation operator ( ** ) Calculates the base to the exponent power, that is, base^exponent 2 ** 3 returns 8 . 10 ** -1 returns 0.1 . Bitwise operators A bitwise operator treats their operands as a set of 32 bits (zeros and ones), rather than as decimal, hexadecimal, or octal numbers. For example, the decimal number nine has a binary representation of 1001. Bitwise operators perform their operations on such binary representations, but they return standard JavaScript numerical values. The following table summarizes JavaScript's bitwise operators. Operator Usage Description Bitwise AND a & b Returns a one in each bit position for which the corresponding bits of both operands are ones. Bitwise OR a | b Returns a zero in each bit position for which the corresponding bits of both operands are zeros. Bitwise XOR a ^ b Returns a zero in each bit position for which the corresponding bits are the same. [Returns a one in each bit position for which the corresponding bits are different.] Bitwise NOT ~ a Inverts the bits of its operand. Left shift a << b Shifts a in binary representation b bits to the left, shifting in zeros from the right. Sign-propagating right shift a >> b Shifts a in binary representation b bits to the right, discarding bits shifted off. Zero-fill right shift a >>> b Shifts a in binary representation b bits to the right, discarding bits shifted off, and shifting in zeros from the left. Bitwise logical operators Conceptually, the bitwise logical operators work as follows: The operands are converted to thirty-two-bit integers and expressed by a series of bits (zeros and ones). Numbers with more than 32 bits get their most significant bits discarded. For example, the following integer with more than 32 bits will be converted to a 32-bit integer: Before: 1110 0110 1111 1010 0000 0000 0000 0110 0000 0000 0001 After: 1010 0000 0000 0000 0110 0000 0000 0001 Each bit in the first operand is paired with the corresponding bit in the second operand: first bit to first bit, second bit to second bit, and so on. The operator is applied to each pair of bits, and the result is constructed bitwise. For example, the binary representation of nine is 1001, and the binary representation of fifteen is 1111. So, when the bitwise operators are applied to these values, the results are as follows: Expression Result Binary Description 15 & 9 9 1111 & 1001 = 1001 15 | 9 15 1111 | 1001 = 1111 15 ^ 9 6 1111 ^ 1001 = 0110 ~15 -16 ~ 0000 0000 … 0000 1111 = 1111 1111 … 1111 0000 ~9 -10 ~ 0000 0000 … 0000 1001 = 1111 1111 … 1111 0110 Note that all 32 bits are inverted using the Bitwise NOT operator, and that values with the most significant (left-most) bit set to 1 represent negative numbers (two's-complement representation). ~x evaluates to the same value that -x - 1 evaluates to. Bitwise shift operators The bitwise shift operators take two operands: the first is a quantity to be shifted, and the second specifies the number of bit positions by which the first operand is to be shifted. The direction of the shift operation is controlled by the operator used. Shift operators convert their operands to thirty-two-bit integers and return a result of either type Number or BigInt : specifically, if the type of the left operand is BigInt , they return BigInt ; otherwise, they return Number . The shift operators are listed in the following table. Bitwise shift operators Operator Description Example Left shift ( << ) This operator shifts the first operand the specified number of bits to the left. Excess bits shifted off to the left are discarded. Zero bits are shifted in from the right. 9<<2 yields 36, because 1001 shifted 2 bits to the left becomes 100100, which is 36. Sign-propagating right shift ( >> ) This operator shifts the first operand the specified number of bits to the right. Excess bits shifted off to the right are discarded. Copies of the leftmost bit are shifted in from the left. 9>>2 yields 2, because 1001 shifted 2 bits to the right becomes 10, which is 2. Likewise, -9>>2 yields -3, because the sign is preserved. Zero-fill right shift ( >>> ) This operator shifts the first operand the specified number of bits to the right. Excess bits shifted off to the right are discarded. Zero bits are shifted in from the left. 19>>>2 yields 4, because 10011 shifted 2 bits to the right becomes 100, which is 4. For non-negative numbers, zero-fill right shift and sign-propagating right shift yield the same result. Logical operators Logical operators are typically used with Boolean (logical) values; when they are, they return a Boolean value. However, the && , || , and ?? operators actually return the value of one of the specified operands, so if these operators are used with non-Boolean values, they may return a non-Boolean value. As such, they are more adequately called "value selection operators". The logical operators are described in the following table. Logical operators Operator Usage Description Logical AND ( && ) expr1 && expr2 Returns expr1 if it can be converted to false ; otherwise, returns expr2 . Thus, when used with Boolean values, && returns true if both operands are true; otherwise, returns false . Logical OR ( || ) expr1 || expr2 Returns expr1 if it can be converted to true ; otherwise, returns expr2 . Thus, when used with Boolean values, || returns true if either operand is true; if both are false, returns false . Nullish coalescing operator ( ?? ) expr1 ?? expr2 Returns expr1 if it is neither null nor undefined ; otherwise, returns expr2 . Logical NOT ( ! ) !expr Returns false if its single operand can be converted to true ; otherwise, returns true . Examples of expressions that can be converted to false are those that evaluate to null , 0 , 0n , NaN , the empty string ( "" ), or undefined . The following code shows examples of the && (logical AND) operator. js const a1 = true && true; // t && t returns true const a2 = true && false; // t && f returns false const a3 = false && true; // f && t returns false const a4 = false && 3 === 4; // f && f returns false const a5 = "Cat" && "Dog"; // t && t returns Dog const a6 = false && "Cat"; // f && t returns false const a7 = "Cat" && false; // t && f returns false The following code shows examples of the || (logical OR) operator. js const o1 = true || true; // t || t returns true const o2 = false || true; // f || t returns true const o3 = true || false; // t || f returns true const o4 = false || 3 === 4; // f || f returns false const o5 = "Cat" || "Dog"; // t || t returns Cat const o6 = false || "Cat"; // f || t returns Cat const o7 = "Cat" || false; // t || f returns Cat The following code shows examples of the ?? (nullish coalescing) operator. js const n1 = null ?? 1; // 1 const n2 = undefined ?? 2; // 2 const n3 = false ?? 3; // false const n4 = 0 ?? 4; // 0 Note how ?? works like || , but it only returns the second expression when the first one is " nullish ", i.e., null or undefined . ?? is a better alternative than || for setting defaults for values that might be null or undefined , in particular when values like '' or 0 are valid values and the default should not apply. The following code shows examples of the ! (logical NOT) operator. js const n1 = !true; // !t returns false const n2 = !false; // !f returns true const n3 = !"Cat"; // !t returns false Short-circuit evaluation As logical expressions are evaluated left to right, they are tested for possible "short-circuit" evaluation using the following rules: falsy && anything is short-circuit evaluated to the falsy value. truthy || anything is short-circuit evaluated to the truthy value. nonNullish ?? anything is short-circuit evaluated to the non-nullish value. The rules of logic guarantee that these evaluations are always correct. Note that the anything part of the above expressions is not evaluated, so any side effects of doing so do not take effect. BigInt operators Most operators that can be used between numbers can be used between BigInt values as well. js // BigInt addition const a = 1n + 2n; // 3n // Division with BigInts round towards zero const b = 1n / 2n; // 0n // Bitwise operations with BigInts do not truncate either side const c = 40000000000000000n >> 2n; // 10000000000000000n One exception is unsigned right shift ( >>> ) , which is not defined for BigInt values. This is because a BigInt does not have a fixed width, so technically it does not have a "highest bit". js const d = 8n >>> 2n; // TypeError: BigInts have no unsigned right shift, use >> instead BigInts and numbers are not mutually replaceable — you cannot mix them in calculations. js const a = 1n + 2; // TypeError: Cannot mix BigInt and other types This is because BigInt is neither a subset nor a superset of numbers. BigInts have higher precision than numbers when representing large integers, but cannot represent decimals, so implicit conversion on either side might lose precision. Use explicit conversion to signal whether you wish the operation to be a number operation or a BigInt one. js const a = Number(1n) + 2; // 3 const b = 1n + BigInt(2); // 3n You can compare BigInts with numbers. js const a = 1n > 2; // false const b = 3 > 2n; // true String operators In addition to the comparison operators, which can be used on string values, the concatenation operator (+) concatenates two string values together, returning another string that is the union of the two operand strings. For example, js console.log("my " + "string"); // console logs the string "my string". The shorthand assignment operator += can also be used to concatenate strings. For example, js let myString = "alpha"; myString += "bet"; // evaluates to "alphabet" and assigns this value to myString. Conditional (ternary) operator The conditional operator is the only JavaScript operator that takes three operands. The operator can have one of two values based on a condition. The syntax is: js condition ? val1 : val2 If condition is true, the operator has the value of val1 . Otherwise it has the value of val2 . You can use the conditional operator anywhere you would use a standard operator. For example, js const status = age >= 18 ? "adult" : "minor"; This statement assigns the value "adult" to the variable status if age is eighteen or more. Otherwise, it assigns the value "minor" to status . Comma operator The comma operator ( , ) evaluates both of its operands and returns the value of the last operand. This operator is primarily used inside a for loop, to allow multiple variables to be updated each time through the loop. It is regarded bad style to use it elsewhere, when it is not necessary. Often two separate statements can and should be used instead. For example, if a is a 2-dimensional array with 10 elements on a side, the following code uses the comma operator to update two variables at once. The code prints the values of the diagonal elements in the array: js const x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; const a = [x, x, x, x, x]; for (let i = 0, j = 9; i <= j; i++, j--) { // ^ console.log(`a[${i}][${j}]= ${a[i][j]}`); } Unary operators A unary operation is an operation with only one operand. delete The delete operator deletes an object's property. The syntax is: js delete object.property; delete object[propertyKey]; delete objectName[index]; where object is the name of an object, property is an existing property, and propertyKey is a string or symbol referring to an existing property. If the delete operator succeeds, it removes the property from the object. Trying to access it afterwards will yield undefined . The delete operator returns true if the operation is possible; it returns false if the operation is not possible. js delete Math.PI; // returns false (cannot delete non-configurable properties) const myObj = { h: 4 }; delete myObj.h; // returns true (can delete user-defined properties) Deleting array elements Since arrays are just objects, it's technically possible to delete elements from them. This is, however, regarded as a bad practice — try to avoid it. When you delete an array property, the array length is not affected and other elements are not re-indexed. To achieve that behavior, it is much better to just overwrite the element with the value undefined . To actually manipulate the array, use the various array methods such as splice . typeof The typeof operator returns a string indicating the type of the unevaluated operand. operand is the string, variable, keyword, or object for which the type is to be returned. The parentheses are optional. Suppose you define the following variables: js const myFun = () => 5 + 2; const shape = "round"; const size = 1; const foo = ["Apple", "Mango", "Orange"]; const today = new Date(); The typeof operator returns the following results for these variables: js typeof myFun; // returns "function" typeof shape; // returns "string" typeof size; // returns "number" typeof foo; // returns "object" typeof today; // returns "object" typeof doesntExist; // returns "undefined" For the keywords true and null , the typeof operator returns the following results: js typeof true; // returns "boolean" typeof null; // returns "object" For a number or string, the typeof operator returns the following results: js typeof 62; // returns "number" typeof "Hello world"; // returns "string" For property values, the typeof operator returns the type of value the property contains: js typeof document.lastModified; // returns "string" typeof window.length; // returns "number" typeof Math.LN2; // returns "number" For methods and functions, the typeof operator returns results as follows: js typeof blur; // returns "function" typeof parseInt; // returns "function" typeof shape.split; // returns "function" For predefined objects, the typeof operator returns results as follows: js typeof Date; // returns "function" typeof Function; // returns "function" typeof Math; // returns "object" typeof Option; // returns "function" typeof String; // returns "function" void The void operator specifies an expression to be evaluated without returning a value. expression is a JavaScript expression to evaluate. The parentheses surrounding the expression are optional, but it is good style to use them to avoid precedence issues. Relational operators A relational operator compares its operands and returns a Boolean value based on whether the comparison is true. in The in operator returns true if the specified property is in the specified object. The syntax is: js propNameOrNumber in objectName where propNameOrNumber is a string, numeric, or symbol expression representing a property name or array index, and objectName is the name of an object. The following examples show some uses of the in operator. js // Arrays const trees = ["redwood", "bay", "cedar", "oak", "maple"]; 0 in trees; // returns true 3 in trees; // returns true 6 in trees; // returns false "bay" in trees; // returns false // (you must specify the index number, not the value at that index) "length" in trees; // returns true (length is an Array property) // built-in objects "PI" in Math; // returns true const myString = new String("coral"); "length" in myString; // returns true // Custom objects const myCar = { make: "Honda", model: "Accord", year: 1998 }; "make" in myCar; // returns true "model" in myCar; // returns true instanceof The instanceof operator returns true if the specified object is of the specified object type. The syntax is: js object instanceof objectType where object is the object to test against objectType , and objectType is a constructor representing a type, such as Map or Array . Use instanceof when you need to confirm the type of an object at runtime. For example, when catching exceptions, you can branch to different exception-handling code depending on the type of exception thrown. For example, the following code uses instanceof to determine whether obj is a Map object. Because obj is a Map object, the statements inside the if block execute. js const obj = new Map(); if (obj instanceof Map) { // statements to execute } Basic expressions All operators eventually operate on one or more basic expressions. These basic expressions include identifiers and literals , but there are a few other kinds as well. They are briefly introduced below, and their semantics are described in detail in their respective reference sections. this The this keyword is usually used within a function. In general, when the function is attached to an object as a method, this refers to the object that the method is called on. It functions like a hidden parameter that is passed to the function. this is an expression that evaluates to the object, so you can use all the object operations we introduced. js this["propertyName"]; this.propertyName; doSomething(this); For example, suppose a function is defined as follows: js function getFullName() { return `${this.firstName} ${this.lastName}`; } We can now attach this function to an object, and it will use the properties of that object when called: js const person1 = { firstName: "Chris", lastName: "Martin", }; const person2 = { firstName: "Chester", lastName: "Bennington", }; // Attach the same function person1.getFullName = getFullName; person2.getFullName = getFullName; console.log(person1.getFullName()); // "Chris Martin" console.log(person2.getFullName()); // "Chester Bennington" Grouping operator The grouping operator ( ) controls the precedence of evaluation in expressions. For example, you can override multiplication and division first, then addition and subtraction to evaluate addition first. js const a = 1; const b = 2; const c = 3; // default precedence a + b * c; // 7 // evaluated by default like this a + (b * c); // 7 // now overriding precedence // addition before multiplication (a + b) * c; // 9 // which is equivalent to a * c + b * c; // 9 Property accessor The property accessor syntax gets property values on objects, using either dot notation or bracket notation. js object.property; object["property"]; The working with objects guide goes into more details about object properties. Optional chaining The optional chaining syntax ( ?. ) performs the chained operation on an object if it is defined and non- null , and otherwise short-circuits the operation and returns undefined . This allows you to operate on a value that may be null or undefined without causing a TypeError . js maybeObject?.property; maybeObject?.[property]; maybeFunction?.(); new You can use the new operator to create an instance of a user-defined object type or of one of the built-in object types. Use new as follows: js const objectName = new ObjectType(param1, param2, /* …, */ paramN); super The super keyword is used to call functions on an object's parent. It is useful with classes to call the parent constructor, for example. js super(args); // calls the parent constructor. super.functionOnParent(args); Previous Next Help improve MDN Was this page helpful to you? Yes No Learn how to contribute This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors . View this page on GitHub • Report a problem with this content Filter sidebar JavaScript Tutorials and guides JavaScript Guide Introduction Grammar and types Control flow and error handling Loops and iteration Functions Expressions and operators Numbers and strings Representing dates & times Regular expressions Indexed collections Keyed collections Working with objects Using classes Using promises JavaScript typed arrays Iterators and generators Resource management Internationalization JavaScript modules Intermediate Language overview JavaScript data structures Equality comparisons and sameness Enumerability and ownership of properties Closures Advanced Inheritance and the prototype chain Meta programming Memory Management References Built-in objects AggregateError Array ArrayBuffer AsyncDisposableStack AsyncFunction AsyncGenerator AsyncGeneratorFunction AsyncIterator Atomics BigInt BigInt64Array BigUint64Array Boolean DataView Date decodeURI() decodeURIComponent() DisposableStack encodeURI() encodeURIComponent() Error escape() Deprecated eval() EvalError FinalizationRegistry Float16Array Float32Array Float64Array Function Generator GeneratorFunction globalThis Infinity Int8Array Int16Array Int32Array InternalError Non-standard Intl isFinite() isNaN() Iterator JSON Map Math NaN Number Object parseFloat() parseInt() Promise Proxy RangeError ReferenceError Reflect RegExp Set SharedArrayBuffer String SuppressedError Symbol SyntaxError Temporal Experimental TypedArray TypeError Uint8Array Uint8ClampedArray Uint16Array Uint32Array undefined unescape() Deprecated URIError WeakMap WeakRef WeakSet Expressions & operators Addition (+) Addition assignment (+=) Assignment (=) async function expression async function* expression await Bitwise AND (&) Bitwise AND assignment (&=) Bitwise NOT (~) Bitwise OR (|) Bitwise OR assignment (|=) Bitwise XOR (^) Bitwise XOR assignment (^=) class expression Comma operator (,) Conditional (ternary) operator Decrement (--) delete Destructuring Division (/) Division assignment (/=) Equality (==) Exponentiation (**) Exponentiation assignment (**=) function expression function* expression Greater than (>) Greater than or equal (>=) Grouping operator ( ) import.meta import.meta.resolve() import() in Increment (++) Inequality (!=) instanceof Left shift (<<) Left shift assignment (<<=) Less than (<) Less than or equal (<=) Logical AND (&&) Logical AND assignment (&&=) Logical NOT (!) Logical OR (||) Logical OR assignment (||=) Multiplication (*) Multiplication assignment (*=) new new.target null Nullish coalescing assignment (??=) Nullish coalescing operator (??) Object initializer Operator precedence Optional chaining (?.) Property accessors Remainder (%) Remainder assignment (%=) Right shift (>>) Right shift assignment (>>=) Spread syntax (...) Strict equality (===) Strict inequality (!==) Subtraction (-) Subtraction assignment (-=) super this typeof Unary negation (-) Unary plus (+) Unsigned right shift (>>>) Unsigned right shift assignment (>>>=) void operator yield yield* Statements & declarations async function async function* await using Block statement break class const continue debugger do...while Empty statement export Expression statement for for await...of for...in for...of function function* if...else import Import attributes Labeled statement let return switch throw try...catch using var while with Deprecated Functions Arrow function expressions Default parameters get Method definitions Rest parameters set The arguments object [Symbol.iterator]() callee Deprecated length Classes constructor extends Private elements Public class fields static Static initialization blocks Regular expressions Backreference: \1, \2 Capturing group: (...) Character class escape: \d, \D, \w, \W, \s, \S Character class: [...], [^...] Character escape: \n, \u{...} Disjunction: | Input boundary assertion: ^, $ Literal character: a, b Lookahead assertion: (?=...), (?!...) Lookbehind assertion: (?<=...), (?<!...) Modifier: (?ims-ims:...) Named backreference: \k<name> Named capturing group: (?<name>...) Non-capturing group: (?:...) Quantifier: *, +, ?, {n}, {n,}, {n,m} Unicode character class escape: \p{...}, \P{...} Wildcard: . Word boundary assertion: \b, \B Errors AggregateError: No Promise in Promise.any was resolved Error: Permission denied to access property "x" InternalError: too much recursion RangeError: argument is not a valid code point RangeError: BigInt division by zero RangeError: BigInt negative exponent RangeError: form must be one of 'NFC', 'NFD', 'NFKC', or 'NFKD' RangeError: invalid array length RangeError: invalid date RangeError: precision is out of range RangeError: radix must be an integer RangeError: repeat count must be less than infinity RangeError: repeat count must be non-negative RangeError: x can't be converted to BigInt because it isn't an integer ReferenceError: "x" is not defined ReferenceError: assignment to undeclared variable "x" ReferenceError: can't access lexical declaration 'X' before initialization ReferenceError: must call super constructor before using 'this' in derived class constructor ReferenceError: super() called twice in derived class constructor SyntaxError: 'arguments'/'eval' can't be defined or assigned to in strict mode code SyntaxError: "0"-prefixed octal literals are deprecated SyntaxError: "use strict" not allowed in function with non-simple parameters SyntaxError: "x" is a reserved identifier SyntaxError: \ at end of pattern SyntaxError: a declaration in the head of a for-of loop can't have an initializer SyntaxError: applying the 'delete' operator to an unqualified name is deprecated SyntaxError: arguments is not valid in fields SyntaxError: await is only valid in async functions, async generators and modules SyntaxError: await/yield expression can't be used in parameter SyntaxError: cannot use `??` unparenthesized within `||` and `&&` expressions SyntaxError: character class escape cannot be used in class range in regular expression SyntaxError: continue must be inside loop SyntaxError: duplicate capture group name in regular expression SyntaxError: duplicate formal argument x SyntaxError: for-in loop head declarations may not have initializers SyntaxError: function statement requires a name SyntaxError: functions cannot be labelled SyntaxError: getter and setter for private name #x should either be both static or non-static SyntaxError: getter functions must have no arguments SyntaxError: identifier starts immediately after numeric literal SyntaxError: illegal character SyntaxError: import declarations may only appear at top level of a module SyntaxError: incomplete quantifier in regular expression SyntaxError: invalid assignment left-hand side SyntaxError: invalid BigInt syntax SyntaxError: invalid capture group name in regular expression SyntaxError: invalid character in class in regular expression SyntaxError: invalid class set operation in regular expression SyntaxError: invalid decimal escape in regular expression SyntaxError: invalid identity escape in regular expression SyntaxError: invalid named capture reference in regular expression SyntaxError: invalid property name in regular expression SyntaxError: invalid range in character class SyntaxError: invalid regexp group SyntaxError: invalid regular expression flag "x" SyntaxError: invalid unicode escape in regular expression SyntaxError: JSON.parse: bad parsing SyntaxError: label not found SyntaxError: missing : after property id SyntaxError: missing ) after argument list SyntaxError: missing ) after condition SyntaxError: missing ] after element list SyntaxError: missing } after function body SyntaxError: missing } after property list SyntaxError: missing = in const declaration SyntaxError: missing formal parameter SyntaxError: missing name after . operator SyntaxError: missing variable name SyntaxError: negated character class with strings in regular expression SyntaxError: new keyword cannot be used with an optional chain SyntaxError: nothing to repeat SyntaxError: numbers out of order in {} quantifier. SyntaxError: octal escape sequences can't be used in untagged template literals or in strict mode code SyntaxError: parameter after rest parameter SyntaxError: private fields can't be deleted SyntaxError: property name __proto__ appears more than once in object literal SyntaxError: raw bracket is not allowed in regular expression with unicode flag SyntaxError: redeclaration of formal parameter "x" SyntaxError: reference to undeclared private field or method #x SyntaxError: rest parameter may not have a default SyntaxError: return not in function SyntaxError: setter functions must have one argument SyntaxError: string literal contains an unescaped line break SyntaxError: super() is only valid in derived class constructors SyntaxError: tagged template cannot be used with optional chain SyntaxError: Unexpected '#' used outside of class body SyntaxError: Unexpected token SyntaxError: unlabeled break must be inside loop or switch SyntaxError: unparenthesized unary expression can't appear on the left-hand side of '**' SyntaxError: use of super property/member accesses only valid within methods or eval code within methods SyntaxError: Using //@ to indicate sourceURL pragmas is deprecated. Use //# instead TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed TypeError: 'x' is not iterable TypeError: "x" is (not) "y" TypeError: "x" is not a constructor TypeError: "x" is not a function TypeError: "x" is not a non-null object TypeError: "x" is read-only TypeError: already executing generator TypeError: BigInt value can't be serialized in JSON TypeError: calling a builtin X constructor without new is forbidden TypeError: can't access/set private field or method: object is not the right class TypeError: can't assign to property "x" on "y": not an object TypeError: can't convert BigInt to number TypeError: can't convert x to BigInt TypeError: can't define property "x": "obj" is not extensible TypeError: can't delete non-configurable array element TypeError: can't redefine non-configurable property "x" TypeError: can't set prototype of this object TypeError: can't set prototype: it would cause a prototype chain cycle TypeError: cannot use 'in' operator to search for 'x' in 'y' TypeError: class constructors must be invoked with 'new' TypeError: cyclic object value TypeError: derived class constructor returned invalid value x TypeError: getting private setter-only property TypeError: Initializing an object twice is an error with private fields/methods TypeError: invalid 'instanceof' operand 'x' TypeError: invalid Array.prototype.sort argument TypeError: invalid assignment to const "x" TypeError: Iterator/AsyncIterator constructor can't be used directly TypeError: matchAll/replaceAll must be called with a global RegExp TypeError: More arguments needed TypeError: null/undefined has no properties TypeError: property "x" is non-configurable and can't be deleted TypeError: Reduce of empty array with no initial value TypeError: setting getter-only property "x" TypeError: WeakSet key/WeakMap value 'x' must be an object or an unregistered symbol TypeError: X.prototype.y called on incompatible type URIError: malformed URI sequence Warning: -file- is being assigned a //# sourceMappingURL, but already has one Warning: unreachable code after return statement Misc JavaScript technologies overview Execution model Lexical grammar Iteration protocols Strict mode Template literals Trailing commas Deprecated features Your blueprint for a better internet. MDN About Blog Mozilla careers Advertise with us MDN Plus Product help Contribute MDN Community Community resources Writing guidelines MDN Discord MDN on GitHub Developers Web technologies Learn web development Guides Tutorials Glossary Hacks blog Website Privacy Notice Telemetry Settings Legal Community Participation Guidelines Visit Mozilla Corporation’s not-for-profit parent, the Mozilla Foundation . Portions of this content are ©1998–⁨2025⁩ by individual mozilla.org contributors. Content available under a Creative Commons license .