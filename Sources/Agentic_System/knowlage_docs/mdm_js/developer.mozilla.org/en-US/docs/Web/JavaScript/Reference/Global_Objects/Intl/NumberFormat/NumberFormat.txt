Intl.NumberFormat() constructor - JavaScript | MDN Skip to main content Skip to search MDN HTML HTML: Markup language HTML reference Elements Global attributes Attributes See all… HTML guides Responsive images HTML cheatsheet Date & time formats See all… Markup languages SVG MathML XML CSS CSS: Styling language CSS reference Properties Selectors At-rules Values & units See all… CSS guides Box model Animations Flexbox Colors See all… Layout cookbook Column layouts Centering an element Card component See all… JavaScript JS JavaScript: Scripting language JS reference Standard built-in objects Expressions & operators Statements & declarations Functions See all… JS guides Control flow & error handing Loops and iteration Working with objects Using classes See all… Web APIs Web APIs: Programming interfaces Web API reference File system API Fetch API Geolocation API HTML DOM API Push API Service worker API See all… Web API guides Using the Web animation API Using the Fetch API Working with the History API Using the Web speech API Using web workers All All web technology Technologies Accessibility HTTP URI Web extensions WebAssembly WebDriver See all… Topics Media Performance Privacy Security Progressive web apps Learn Learn web development Frontend developer course Getting started Common questions Curriculum Learn HTML Introduction to HTML Getting started with HTML Learn CSS What is CSS Getting started with CSS Learn JavaScript How to use data attributes Add JavaScript to your web page Tools Discover our tools Playground HTTP Observatory Border-image generator Border-radius generator Box-shadow generator Color format converter Color mixer Shape generator About Get to know MDN better About MDN Advertise with us Community MDN on GitHub Blog Toggle sidebar Web JavaScript Reference Standard built-in objects Intl Intl.NumberFormat Intl.NumberFormat() Theme OS default Light Dark English (US) Remember language Learn more Deutsch English (US) Français 日本語 Intl.NumberFormat() constructor Baseline Widely available * This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨September 2017⁩. * Some parts of this feature may have varying levels of support. Learn more See full compatibility Report feedback The Intl.NumberFormat() constructor creates Intl.NumberFormat objects. In this article Try it Syntax Examples Specifications Browser compatibility See also Try it const number = 123456.789; console.log( new Intl.NumberFormat("de-DE", { style: "currency", currency: "EUR" }).format( number, ), ); // Expected output: "123.456,79 €" // The Japanese yen doesn't use a minor unit console.log( new Intl.NumberFormat("ja-JP", { style: "currency", currency: "JPY" }).format( number, ), ); // Expected output: "￥123,457" // Limit to three significant digits console.log( new Intl.NumberFormat("en-IN", { maximumSignificantDigits: 3 }).format( number, ), ); // Expected output: "1,23,000" Syntax js new Intl.NumberFormat() new Intl.NumberFormat(locales) new Intl.NumberFormat(locales, options) Intl.NumberFormat() Intl.NumberFormat(locales) Intl.NumberFormat(locales, options) Note: Intl.NumberFormat() can be called with or without new . Both create a new Intl.NumberFormat instance. However, there's a special behavior when it's called without new and the this value is another Intl.NumberFormat instance; see Return value . Parameters locales Optional A string with a BCP 47 language tag or an Intl.Locale instance, or an array of such locale identifiers. The runtime's default locale is used when undefined is passed or when none of the specified locale identifiers is supported. For the general form and interpretation of the locales argument, see the parameter description on the Intl main page . The following Unicode extension key is allowed: nu See numberingSystem . This key can also be set with options (as listed below). When both are set, the options property takes precedence. options Optional An object. For ease of reading, the property list is broken into sections based on their purposes, including locale options , style options , digit options , and other options . Locale options localeMatcher The locale matching algorithm to use. Possible values are "lookup" and "best fit" ; the default is "best fit" . For information about this option, see Locale identification and negotiation . numberingSystem The numbering system to use for number formatting, such as "arab" , "hans" , "mathsans" , and so on. For a list of supported numbering system types, see Intl.supportedValuesOf() ; the default is locale dependent. This option can also be set through the nu Unicode extension key; if both are provided, this options property takes precedence. Style options Depending on the style used, some of them may be ignored, and others may be required: style The formatting style to use. "decimal" (default) For plain number formatting. "currency" For currency formatting. "percent" For percent formatting. "unit" For unit formatting. currency The currency to use in currency formatting. Possible values are the ISO 4217 currency codes, such as "USD" for the US dollar, "EUR" for the euro, or "CNY" for the Chinese RMB — see Intl.supportedValuesOf() . There is no default value; if the style is "currency" , the currency property must be provided. It is normalized to uppercase. currencyDisplay How to display the currency in currency formatting. "code" Use the ISO currency code. "symbol" (default) Use a localized currency symbol such as €. "narrowSymbol" Use a narrow format symbol ("$100" rather than "US$100"). "name" Use a localized currency name such as "dollar" . currencySign In many locales, accounting format means to wrap the number with parentheses instead of appending a minus sign. Possible values are "standard" and "accounting" ; the default is "standard" . unit The unit to use in unit formatting, Possible values are listed in Intl.supportedValuesOf() . Pairs of simple units can be concatenated with "-per-" to make a compound unit. There is no default value; if the style is "unit" , the unit property must be provided. unitDisplay The unit formatting style to use in unit formatting. Possible values are: "short" (default) E.g., 16 l . "narrow" E.g., 16l . "long" E.g., 16 litres . Digit options The following properties are also supported by Intl.PluralRules . minimumIntegerDigits The minimum number of integer digits to use. A value with a smaller number of integer digits than this number will be left-padded with zeros (to the specified length) when formatted. Possible values are from 1 to 21 ; the default is 1 . minimumFractionDigits The minimum number of fraction digits to use. Possible values are from 0 to 100 ; the default for plain number and percent formatting is 0 ; the default for currency formatting is the number of minor unit digits provided by the ISO 4217 currency code list (2 if the list doesn't provide that information). See SignificantDigits/FractionDigits default values for when this default gets applied. maximumFractionDigits The maximum number of fraction digits to use. Possible values are from 0 to 100 ; the default for plain number formatting is the larger of minimumFractionDigits and 3 ; the default for currency formatting is the larger of minimumFractionDigits and the number of minor unit digits provided by the ISO 4217 currency code list (2 if the list doesn't provide that information); the default for percent formatting is the larger of minimumFractionDigits and 0. See SignificantDigits/FractionDigits default values for when this default gets applied. minimumSignificantDigits The minimum number of significant digits to use. Possible values are from 1 to 21 ; the default is 1 . See SignificantDigits/FractionDigits default values for when this default gets applied. maximumSignificantDigits The maximum number of significant digits to use. Possible values are from 1 to 21 ; the default is 21 . See SignificantDigits/FractionDigits default values for when this default gets applied. roundingPriority Specify how rounding conflicts will be resolved if both "FractionDigits" ( minimumFractionDigits / maximumFractionDigits ) and "SignificantDigits" ( minimumSignificantDigits / maximumSignificantDigits ) are specified. Possible values are: "auto" (default) The result from the significant digits property is used. "morePrecision" The result from the property that results in more precision is used. "lessPrecision" The result from the property that results in less precision is used. The value "auto" is normalized to "morePrecision" if notation is "compact" and none of the four "FractionDigits"/"SignificantDigits" options are set. Note that for values other than auto the result with more precision is calculated from the maximumSignificantDigits and maximumFractionDigits (minimum fractional and significant digit settings are ignored). roundingIncrement Indicates the increment at which rounding should take place relative to the calculated rounding magnitude. Possible values are 1 , 2 , 5 , 10 , 20 , 25 , 50 , 100 , 200 , 250 , 500 , 1000 , 2000 , 2500 , and 5000 ; the default is 1 . It cannot be mixed with significant-digits rounding or any setting of roundingPriority other than auto . roundingMode How decimals should be rounded. Possible values are: "ceil" Round toward +∞. Positive values round up. Negative values round "more positive". "floor" Round toward -∞. Positive values round down. Negative values round "more negative". "expand" Round away from 0. The magnitude of the value is always increased by rounding. Positive values round up. Negative values round "more negative". "trunc" Round toward 0. This magnitude of the value is always reduced by rounding. Positive values round down. Negative values round "less negative". "halfCeil" Ties toward +∞. Values above the half-increment round like "ceil" (towards +∞), and below like "floor" (towards -∞). On the half-increment, values round like "ceil" . "halfFloor" Ties toward -∞. Values above the half-increment round like "ceil" (towards +∞), and below like "floor" (towards -∞). On the half-increment, values round like "floor" . "halfExpand" (default) Ties away from 0. Values above the half-increment round like "expand" (away from zero), and below like "trunc" (towards 0). On the half-increment, values round like "expand" . "halfTrunc" Ties toward 0. Values above the half-increment round like "expand" (away from zero), and below like "trunc" (towards 0). On the half-increment, values round like "trunc" . "halfEven" Ties towards the nearest even integer. Values above the half-increment round like "expand" (away from zero), and below like "trunc" (towards 0). On the half-increment values round towards the nearest even digit. These options reflect the ICU user guide , where "expand" and "trunc" map to ICU "UP" and "DOWN", respectively. The rounding modes example below demonstrates how each mode works. trailingZeroDisplay The strategy for displaying trailing zeros on whole numbers. Possible values are: "auto" (default) Keep trailing zeros according to minimumFractionDigits and minimumSignificantDigits . "stripIfInteger" Remove the fraction digits if they are all zero. This is the same as "auto" if any of the fraction digits is non-zero. SignificantDigits/FractionDigits default values For the four options above (the FractionDigits and SignificantDigits options), we mentioned their defaults; however, these defaults are not unconditionally applied . They are only applied when the property is actually going to be used, which depends on the roundingPriority and notation settings. Specifically: If roundingPriority is not "auto" , then all four options apply. If roundingPriority is "auto" and at least one SignificantDigits option is set, then the SignificantDigits options apply and the FractionDigits options are ignored. If roundingPriority is "auto" , and either at least one FractionDigits option is set or notation is not "compact" , then the FractionDigits options apply and the SignificantDigits options are ignored. If roundingPriority is "auto" , notation is "compact" , and none of the four options are set, then they are set to { minimumFractionDigits: 0, maximumFractionDigits: 0, minimumSignificantDigits: 1, maximumSignificantDigits: 2 } , regardless of the defaults mentioned above, and roundingPriority is set to "morePrecision" . Other options notation The formatting that should be displayed for the number. Possible values are: "standard" (default) Plain number formatting. "scientific" Return the order-of-magnitude for formatted number. "engineering" Return the exponent of ten when divisible by three. "compact" String representing exponent; defaults to using the "short" form. compactDisplay Only used when notation is "compact" . Possible values are "short" and "long" ; the default is "short" . useGrouping Whether to use grouping separators, such as thousands separators or thousand/lakh/crore separators. "always" Display grouping separators even if the locale prefers otherwise. "auto" Display grouping separators based on the locale preference, which may also be dependent on the currency. "min2" Display grouping separators when there are at least 2 digits in a group. true Same as "always" . false Display no grouping separators. The default is "min2" if notation is "compact" , and "auto" otherwise. The string values "true" and "false" are accepted, but are always converted to the default value. signDisplay When to display the sign for the number. Possible values are: "auto" (default) Sign display for negative numbers only, including negative zero. "always" Always display sign. "exceptZero" Sign display for positive and negative numbers, but not zero. "negative" Sign display for negative numbers only, excluding negative zero. "never" Never display sign. Return value A new Intl.NumberFormat object. Note: The text below describes behavior that is marked by the specification as "optional". It may not work in all environments. Check the browser compatibility table . Normally, Intl.NumberFormat() can be called with or without new , and a new Intl.NumberFormat instance is returned in both cases. However, if the this value is an object that is instanceof Intl.NumberFormat (doesn't necessarily mean it's created via new Intl.NumberFormat ; just that it has Intl.NumberFormat.prototype in its prototype chain), then the value of this is returned instead, with the newly created Intl.NumberFormat object hidden in a [Symbol(IntlLegacyConstructedSymbol)] property (a unique symbol that's reused between instances). js const formatter = Intl.NumberFormat.call( { __proto__: Intl.NumberFormat.prototype }, "en-US", { notation: "scientific" }, ); console.log(Object.getOwnPropertyDescriptors(formatter)); // { // [Symbol(IntlLegacyConstructedSymbol)]: { // value: NumberFormat [Intl.NumberFormat] {}, // writable: false, // enumerable: false, // configurable: false // } // } Note that there's only one actual Intl.NumberFormat instance here: the one hidden in [Symbol(IntlLegacyConstructedSymbol)] . Calling the format() and resolvedOptions() methods on formatter would correctly use the options stored in that instance, but calling all other methods (e.g., formatRange() ) would fail with "TypeError: formatRange method called on incompatible Object", because those methods don't consult the hidden instance's options. This behavior, called ChainNumberFormat , does not happen when Intl.NumberFormat() is called without new but with this set to anything else that's not an instanceof Intl.NumberFormat . If you call it directly as Intl.NumberFormat() , the this value is Intl , and a new Intl.NumberFormat instance is created normally. Exceptions RangeError Thrown in one of the following cases: A property that takes enumerated values (such as style , units , currency , and so on) is set to an invalid value. Both maximumFractionDigits and minimumFractionDigits are set, and they are set to different values. Note that depending on various formatting options, these properties can have default values. It is therefore possible to get this error even if you only set one of the properties. TypeError Thrown if the options.style property is set to "unit" or "currency", and no value has been set for the corresponding property options.unit or options.currency . Examples Basic usage In basic use without specifying a locale, a formatted string in the default locale and with default options is returned. js const amount = 3500; console.log(new Intl.NumberFormat().format(amount)); // '3,500' if in US English locale Decimal and percent formatting js const amount = 3500; new Intl.NumberFormat("en-US", { style: "decimal", }).format(amount); // '3,500' new Intl.NumberFormat("en-US", { style: "percent", }).format(amount); // '350,000%' Unit formatting If the style is 'unit' , a unit property must be provided. Optionally, unitDisplay controls the unit formatting. js const amount = 3500; new Intl.NumberFormat("en-US", { style: "unit", unit: "liter", }).format(amount); // '3,500 L' new Intl.NumberFormat("en-US", { style: "unit", unit: "liter", unitDisplay: "long", }).format(amount); // '3,500 liters' Currency formatting If the style is 'currency' , a currency property must be provided. Optionally, currencyDisplay and currencySign control the unit formatting. js const amount = -3500; new Intl.NumberFormat("en-US", { style: "currency", currency: "USD", }).format(amount); // '-$3,500.00' new Intl.NumberFormat("bn", { style: "currency", currency: "USD", currencyDisplay: "name", }).format(amount); // '-3,500.00 US dollars' new Intl.NumberFormat("bn", { style: "currency", currency: "USD", currencySign: "accounting", }).format(amount); // '($3,500.00)' Scientific, engineering or compact notations Scientific and compact notation are represented by the notation option and can be formatted like this: js new Intl.NumberFormat("en-US", { notation: "scientific", }).format(987654321); // 9.877E8 new Intl.NumberFormat("pt-PT", { notation: "scientific", }).format(987654321); // 9,877E8 new Intl.NumberFormat("en-GB", { notation: "engineering", }).format(987654321); // 987.654E6 new Intl.NumberFormat("de", { notation: "engineering", }).format(987654321); // 987,654E6 new Intl.NumberFormat("zh-CN", { notation: "compact", }).format(987654321); // 9.9亿 new Intl.NumberFormat("fr", { notation: "compact", compactDisplay: "long", }).format(987654321); // 988 millions new Intl.NumberFormat("en-GB", { notation: "compact", compactDisplay: "short", }).format(987654321); // 988M Displaying signs Display a sign for positive and negative numbers, but not zero: js new Intl.NumberFormat("en-US", { style: "percent", signDisplay: "exceptZero", }).format(0.55); // '+55%' Note that when the currency sign is "accounting", parentheses might be used instead of a minus sign: js new Intl.NumberFormat("bn", { style: "currency", currency: "USD", currencySign: "accounting", signDisplay: "always", }).format(-3500); // '($3,500.00)' FractionDigits, SignificantDigits and IntegerDigits You can specify the minimum or maximum number of fractional, integer or significant digits to display when formatting a number. Note: If both significant and fractional digit limits are specified, then the actual formatting depends on the roundingPriority . Using FractionDigits and IntegerDigits The integer and fraction digit properties indicate the number of digits to display before and after the decimal point, respectively. If the value to display has fewer integer digits than specified, it will be left-padded with zeros to the expected number. If it has fewer fractional digits, it will be right-padded with zeros. Both cases are shown below: js // Formatting adds zeros to display minimum integers and fractions console.log( new Intl.NumberFormat("en", { minimumIntegerDigits: 3, minimumFractionDigits: 4, }).format(4.33), ); // "004.3300" If a value has more fractional digits than the specified maximum number, it will be rounded. The way that it is rounded depends on the roundingMode property (more details are provided in the rounding modes section). Below the value is rounded from five fractional digits ( 4.33145 ) to two ( 4.33 ): js // Display value shortened to maximum number of digits console.log( new Intl.NumberFormat("en", { maximumFractionDigits: 2, }).format(4.33145), ); // "4.33" The minimum fractional digits have no effect if the value already has more than 2 fractional digits: js // Minimum fractions have no effect if value is higher precision. console.log( new Intl.NumberFormat("en", { minimumFractionDigits: 2, }).format(4.33145), ); // "4.331" Warning: Watch out for default values as they may affect formatting even if not specified in your code. The default maximum digit value is 3 for plain values, 2 for currency, and may have different values for other predefined types. The formatted value above is rounded to 3 digits, even though we didn't specify the maximum digits! This is because a default value of maximumFractionDigits is set when we specify minimumFractionDigits , and visa versa. The default values of maximumFractionDigits and minimumFractionDigits are 3 and 0 , respectively. You can use resolvedOptions() to inspect the formatter. js console.log( new Intl.NumberFormat("en", { maximumFractionDigits: 2, }).resolvedOptions(), ); // { // … // minimumIntegerDigits: 1, // minimumFractionDigits: 0, // maximumFractionDigits: 2, // … // } console.log( new Intl.NumberFormat("en", { minimumFractionDigits: 2, }).resolvedOptions(), ); // { // … // minimumIntegerDigits: 1, // minimumFractionDigits: 2, // maximumFractionDigits: 3, // … // } Using SignificantDigits The number of significant digits is the total number of digits including both integer and fractional parts. The maximumSignificantDigits is used to indicate the total number of digits from the original value to display. The examples below show how this works. Note in particular the last case: only the first digit is retained and the others are discarded/set to zero. js // Display 5 significant digits console.log( new Intl.NumberFormat("en", { maximumSignificantDigits: 5, }).format(54.33145), ); // "54.331" // Max 2 significant digits console.log( new Intl.NumberFormat("en", { maximumSignificantDigits: 2, }).format(54.33145), ); // "54" // Max 1 significant digits console.log( new Intl.NumberFormat("en", { maximumSignificantDigits: 1, }).format(54.33145), ); // "50" The minimumSignificantDigits ensures that at least the specified number of digits are displayed, adding zeros to the end of the value if needed. js // Minimum 10 significant digits console.log( new Intl.NumberFormat("en", { minimumSignificantDigits: 10, }).format(54.33145), ); // "54.33145000" Warning: Watch out for default values as they may affect formatting. If only one SignificantDigits property is used, then its counterpart will automatically be applied with the default value. The default maximum and minimum significant digit values are 21 and 1, respectively. Specifying significant and fractional digits at the same time The fraction digits ( minimumFractionDigits / maximumFractionDigits ) and significant digits ( minimumSignificantDigits / maximumSignificantDigits ) are both ways of controlling how many fractional and leading digits should be formatted. If both are used at the same time, it is possible for them to conflict. These conflicts are resolved using the roundingPriority property. By default, this has a value of "auto" , which means that if either minimumSignificantDigits or maximumSignificantDigits is specified, the fractional and integer digit properties will be ignored. For example, the code below formats the value of 4.33145 with maximumFractionDigits: 3 , and then maximumSignificantDigits: 2 , and then both. The value with both is the one set with maximumSignificantDigits . js console.log( new Intl.NumberFormat("en", { maximumFractionDigits: 3, }).format(4.33145), ); // "4.331" console.log( new Intl.NumberFormat("en", { maximumSignificantDigits: 2, }).format(4.33145), ); // "4.3" console.log( new Intl.NumberFormat("en", { maximumFractionDigits: 3, maximumSignificantDigits: 2, }).format(4.33145), ); // "4.3" Using resolvedOptions() to inspect the formatter, we can see that the returned object does not include maximumFractionDigits when maximumSignificantDigits or minimumSignificantDigits are specified. js console.log( new Intl.NumberFormat("en", { maximumFractionDigits: 3, maximumSignificantDigits: 2, }).resolvedOptions(), ); // { // … // minimumIntegerDigits: 1, // minimumSignificantDigits: 1, // maximumSignificantDigits: 2, // … // } console.log( new Intl.NumberFormat("en", { maximumFractionDigits: 3, minimumSignificantDigits: 2, }).resolvedOptions(), ); // { // … // minimumIntegerDigits: 1, // minimumSignificantDigits: 2, // maximumSignificantDigits: 21, // … // } In addition to "auto" , you can resolve conflicts by specifying roundingPriority as "morePrecision" or "lessPrecision" . The formatter calculates the precision using the values of maximumSignificantDigits and maximumFractionDigits . The code below shows the format being selected for the three different rounding priorities: js const maxFracNF = new Intl.NumberFormat("en", { maximumFractionDigits: 3, }); console.log(`maximumFractionDigits:3 - ${maxFracNF.format(1.23456)}`); // "maximumFractionDigits:2 - 1.235" const maxSigNS = new Intl.NumberFormat("en", { maximumSignificantDigits: 3, }); console.log(`maximumSignificantDigits:3 - ${maxSigNS.format(1.23456)}`); // "maximumSignificantDigits:3 - 1.23" const bothAuto = new Intl.NumberFormat("en", { maximumSignificantDigits: 3, maximumFractionDigits: 3, }); console.log(`auto - ${bothAuto.format(1.23456)}`); // "auto - 1.23" const bothLess = new Intl.NumberFormat("en", { roundingPriority: "lessPrecision", maximumSignificantDigits: 3, maximumFractionDigits: 3, }); console.log(`lessPrecision - ${bothLess.format(1.23456)}`); // "lessPrecision - 1.23" const bothMore = new Intl.NumberFormat("en", { roundingPriority: "morePrecision", maximumSignificantDigits: 3, maximumFractionDigits: 3, }); console.log(`morePrecision - ${bothMore.format(1.23456)}`); // "morePrecision - 1.235" Note that the algorithm can behave in an unintuitive way if a minimum value is specified without a maximum value. The example below formats the value 1 specifying minimumFractionDigits: 2 (formatting to 1.00 ) and minimumSignificantDigits: 2 (formatting to 1.0 ). Since 1.00 has more digits than 1.0 , this should be the result when prioritizing morePrecision , but in fact the opposite is true: js const bothLess = new Intl.NumberFormat("en", { roundingPriority: "lessPrecision", minimumFractionDigits: 2, minimumSignificantDigits: 2, }); console.log(`lessPrecision - ${bothLess.format(1)}`); // "lessPrecision - 1.00" const bothMore = new Intl.NumberFormat("en", { roundingPriority: "morePrecision", minimumFractionDigits: 2, minimumSignificantDigits: 2, }); console.log(`morePrecision - ${bothMore.format(1)}`); // "morePrecision - 1.0" The reason for this is that only the "maximum precision" values are used for the calculation, and the default value of maximumSignificantDigits is much higher than maximumFractionDigits . Note: The working group have proposed a modification of the algorithm where the formatter should evaluate the result of using the specified fractional and significant digits independently (taking account of both minimum and maximum values). It will then select the option that displays more fractional digits if morePrecision is set, and fewer if lessPrecision is set. This will result in more intuitive behavior for this case. Rounding modes If a value has more fractional digits than allowed by the constructor options, the formatted value will be rounded to the specified number of fractional digits. The way in which the value is rounded depends on the roundingMode property. Number formatters use halfExpand rounding by default, which rounds values "away from zero" at the half-increment (in other words, the magnitude of the value is rounded up). For a positive number, if the fractional digits to be removed are closer to the next increment (or on the half way point) then the remaining fractional digits will be rounded up, otherwise they are rounded down. This is shown below: 2.23 rounded to two significant digits is truncated to 2.2 because 2.23 is less than the half increment 2.25, while values of 2.25 and greater are rounded up to 2.3: js // Value below half-increment: round down. console.log( new Intl.NumberFormat("en", { maximumSignificantDigits: 2, }).format(2.23), ); // "2.2" // Value on or above half-increment: round up. console.log( new Intl.NumberFormat("en", { maximumSignificantDigits: 2, }).format(2.25), ); console.log( new Intl.NumberFormat("en", { maximumSignificantDigits: 2, }).format(2.28), ); // "2.3" // "2.3" A negative number on or below the half-increment point is also rounded away from zero (becomes more negative): js // Value below half-increment: round down. console.log( new Intl.NumberFormat("en", { maximumSignificantDigits: 2, }).format(-2.23), ); // "-2.2" // Value on or above half-increment: round up. console.log( new Intl.NumberFormat("en", { maximumSignificantDigits: 2, }).format(-2.25), ); console.log( new Intl.NumberFormat("en", { maximumSignificantDigits: 2, }).format(-2.28), ); // "-2.3" // "-2.3" The table below show the effect of different rounding modes for positive and negative values that are on and around the half-increment. rounding mode 2.23 2.25 2.28 -2.23 -2.25 -2.28 ceil 2.3 2.3 2.3 -2.2 -2.2 -2.2 floor 2.2 2.2 2.2 -2.3 -2.3 -2.3 expand 2.3 2.3 2.3 -2.3 -2.3 -2.3 trunc 2.2 2.2 2.2 -2.2 -2.2 -2.2 halfCeil 2.2 2.3 2.3 -2.2 -2.2 -2.3 halfFloor 2.2 2.2 2.3 -2.2 -2.3 -2.3 halfExpand 2.2 2.3 2.3 -2.2 -2.3 -2.3 halfTrunc 2.2 2.2 2.3 -2.2 -2.2 -2.3 halfEven 2.2 2.2 2.3 -2.2 -2.2 -2.3 When using halfEven , its behavior also depends on the parity (odd or even) of the last digit of the rounded number. For example, the behavior of halfEven in the table above is the same as halfTrunc , because the magnitudes of all numbers are between a smaller "even" number (2.2) and a larger "odd" number (2.3). If the numbers are between ±2.3 and ±2.4, halfEven will behave like halfExpand instead. This behavior avoids consistently under- or over-estimating half-increments in a large data sample. Using roundingIncrement Sometimes we want to round the remaining fractional digits to some other increment than the next integer. For example, currencies for which the smallest coin is 5 cents might want to round the value to increments of 5, reflecting amounts that can actually be paid in cash. This kind of rounding can be achieved with the roundingIncrement property. For example, if maximumFractionDigits is 2 and roundingIncrement is 5, then the number is rounded to the nearest 0.05: js const nf = new Intl.NumberFormat("en-US", { style: "currency", currency: "USD", maximumFractionDigits: 2, roundingIncrement: 5, }); console.log(nf.format(11.29)); // "$11.30" console.log(nf.format(11.25)); // "$11.25" console.log(nf.format(11.22)); // "$11.20" This particular pattern is referred to as "nickel rounding", where nickel is the colloquial name for a USA 5 cent coin. To round to the nearest 10 cents ("dime rounding"), you could change roundingIncrement to 10 . js const nf = new Intl.NumberFormat("en-US", { style: "currency", currency: "USD", maximumFractionDigits: 2, roundingIncrement: 10, }); console.log(nf.format(11.29)); // "$11.30" console.log(nf.format(11.25)); // "$11.30" console.log(nf.format(11.22)); // "$11.20" You can also use roundingMode to change the rounding algorithm. The example below shows how halfCeil rounding can be used to round the value "less positive" below the half-rounding increment and "more positive" if above or on the half-increment. The incremented digit is "0.05" so the half-increment is at .025 (below, this is shown at 11.225). js const nf = new Intl.NumberFormat("en-US", { style: "currency", currency: "USD", maximumFractionDigits: 2, roundingIncrement: 5, roundingMode: "halfCeil", }); console.log(nf.format(11.21)); // "$11.20" console.log(nf.format(11.22)); // "$11.20" console.log(nf.format(11.224)); // "$11.20" console.log(nf.format(11.225)); // "$11.25" console.log(nf.format(11.23)); // "$11.25" If you need to change the number of digits, remember that minimumFractionDigits and maximumFractionDigits must both be set to the same value, or a RangeError is thrown. roundingIncrement cannot be mixed with significant-digits rounding or any setting of roundingPriority other than auto . Specifications Specification ECMAScript® 2026 Internationalization API Specification # sec-intl-numberformat-constructor Browser compatibility Loading… See also Intl.NumberFormat Intl.supportedValuesOf() Intl Help improve MDN Was this page helpful to you? Yes No Learn how to contribute This page was last modified on ⁨Sep 24, 2025⁩ by MDN contributors . View this page on GitHub • Report a problem with this content Filter sidebar Standard built-in objects Intl .NumberFormat Constructor Intl .NumberFormat() Static methods supportedLocalesOf() Instance methods format() formatRange() formatRangeToParts() formatToParts() resolvedOptions() Inheritance Object/Function Static methods apply() bind() call() toString() [Symbol .hasInstance]() Static properties displayName Non-standard length name prototype arguments Non-standard Deprecated caller Non-standard Deprecated Instance methods __defineGetter__() Deprecated __defineSetter__() Deprecated __lookupGetter__() Deprecated __lookupSetter__() Deprecated hasOwnProperty() isPrototypeOf() propertyIsEnumerable() toLocaleString() toString() valueOf() Instance properties __proto__ Deprecated constructor Related pages Intl Intl .Collator Intl .DateTimeFormat Intl .DisplayNames Intl .DurationFormat Intl .ListFormat Intl .Locale Intl .PluralRules Intl .RelativeTimeFormat Intl .Segmenter Your blueprint for a better internet. MDN About Blog Mozilla careers Advertise with us MDN Plus Product help Contribute MDN Community Community resources Writing guidelines MDN Discord MDN on GitHub Developers Web technologies Learn web development Guides Tutorials Glossary Hacks blog Website Privacy Notice Telemetry Settings Legal Community Participation Guidelines Visit Mozilla Corporation’s not-for-profit parent, the Mozilla Foundation . Portions of this content are ©1998–⁨2025⁩ by individual mozilla.org contributors. Content available under a Creative Commons license .