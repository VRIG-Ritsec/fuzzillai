JSON.parse() - JavaScript | MDN Skip to main content Skip to search MDN HTML HTML: Markup language HTML reference Elements Global attributes Attributes See all… HTML guides Responsive images HTML cheatsheet Date & time formats See all… Markup languages SVG MathML XML CSS CSS: Styling language CSS reference Properties Selectors At-rules Values & units See all… CSS guides Box model Animations Flexbox Colors See all… Layout cookbook Column layouts Centering an element Card component See all… JavaScript JS JavaScript: Scripting language JS reference Standard built-in objects Expressions & operators Statements & declarations Functions See all… JS guides Control flow & error handing Loops and iteration Working with objects Using classes See all… Web APIs Web APIs: Programming interfaces Web API reference File system API Fetch API Geolocation API HTML DOM API Push API Service worker API See all… Web API guides Using the Web animation API Using the Fetch API Working with the History API Using the Web speech API Using web workers All All web technology Technologies Accessibility HTTP URI Web extensions WebAssembly WebDriver See all… Topics Media Performance Privacy Security Progressive web apps Learn Learn web development Frontend developer course Getting started Common questions Curriculum Learn HTML Introduction to HTML Getting started with HTML Learn CSS What is CSS Getting started with CSS Learn JavaScript How to use data attributes Add JavaScript to your web page Tools Discover our tools Playground HTTP Observatory Border-image generator Border-radius generator Box-shadow generator Color format converter Color mixer Shape generator About Get to know MDN better About MDN Advertise with us Community MDN on GitHub Blog Toggle sidebar Web JavaScript Reference Standard built-in objects JSON parse() Theme OS default Light Dark English (US) Remember language Learn more Deutsch English (US) Español Français 日本語 한국어 Português (do Brasil) Русский 中文 (简体) 正體中文 (繁體) JSON.parse() Baseline Widely available * This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩. * Some parts of this feature may have varying levels of support. Learn more See full compatibility Report feedback The JSON.parse() static method parses a JSON string, constructing the JavaScript value or object described by the string. An optional reviver function can be provided to perform a transformation on the resulting object before it is returned. In this article Try it Syntax Description Examples Specifications Browser compatibility See also Try it const json = '{"result":true, "count":42}'; const obj = JSON.parse(json); console.log(obj.count); // Expected output: 42 console.log(obj.result); // Expected output: true Syntax js JSON.parse(text) JSON.parse(text, reviver) Parameters text The string to parse as JSON. See the JSON object for a description of JSON syntax. reviver Optional If a function, this prescribes how each value originally produced by parsing is transformed before being returned. Non-callable values are ignored. The function is called with the following arguments: key The key associated with the value. value The value produced by parsing. context Optional A context object that holds state relevant to the current expression being revived. It is a new object for each invocation of the reviver function. It is only passed when reviving primitive values, but not when value is an object or array. It contains the following property: source The original JSON string representing this value. Return value The Object , Array , string, number, boolean, or null value corresponding to the given JSON text . Exceptions SyntaxError Thrown if the string to parse is not valid JSON. Description JSON.parse() parses a JSON string according to the JSON grammar , then evaluates the string as if it's a JavaScript expression. The only instance where a piece of JSON text represents a different value from the same JavaScript expression is when dealing with the "__proto__" key — see Object literal syntax vs. JSON . The reviver parameter If a reviver is specified, the value computed by parsing is transformed before being returned. Specifically, the computed value and all its properties (in a depth-first fashion, beginning with the most nested properties and proceeding to the original value itself) are individually run through the reviver . The reviver is called with the object containing the property being processed as this (unless you define the reviver as an arrow function, in which case there's no separate this binding) and two arguments: key and value , representing the property name as a string (even for arrays) and the property value. For primitive values, an additional context parameter is passed, which contains the source text of this value. If the reviver function returns undefined (or returns no value — for example, if execution falls off the end of the function), the property is deleted from the object. Otherwise, the property is redefined to be the return value. If the reviver only transforms some values and not others, be certain to return all untransformed values as-is — otherwise, they will be deleted from the resulting object. Similar to the replacer parameter of JSON.stringify() , for arrays and objects, reviver will be last called on the root value with an empty string as the key and the root object as the value . For other valid JSON values, reviver works similarly and is called once with an empty string as the key and the value itself as the value . If you return another value from reviver , that value will completely replace the originally parsed value. This even applies to the root value. For example: js const transformedObj = JSON.parse('[1,5,{"s":1}]', (key, value) => typeof value === "object" ? undefined : value, ); console.log(transformedObj); // undefined There is no way to work around this generically. You cannot specially handle the case where key is an empty string, because JSON objects can also contain keys that are empty strings. You need to know very precisely what kind of transformation is needed for each key when implementing the reviver. Note that reviver is run after the value is parsed. So, for example, numbers in JSON text will have already been converted to JavaScript numbers, and may lose precision in the process. One way to transfer large numbers without loss of precision is to serialize them as strings, and revive them to BigInts , or other appropriate arbitrary precision formats. You can also use the context.source property to access the original JSON source text representing the value, as shown below: js const bigJSON = '{"gross_gdp": 12345678901234567890}'; const bigObj = JSON.parse(bigJSON, (key, value, context) => { if (key === "gross_gdp") { // Ignore the value because it has already lost precision return BigInt(context.source); } return value; }); Examples Using JSON.parse() js JSON.parse("{}"); // {} JSON.parse("true"); // true JSON.parse('"foo"'); // "foo" JSON.parse('[1, 5, "false"]'); // [1, 5, "false"] JSON.parse("null"); // null Using the reviver parameter js JSON.parse( '{"p": 5}', (key, value) => typeof value === "number" ? value * 2 // return value * 2 for numbers : value, // return everything else unchanged ); // { p: 10 } JSON.parse('{"1": 1, "2": 2, "3": {"4": 4, "5": {"6": 6}}}', (key, value) => { console.log(key); return value; }); // 1 // 2 // 4 // 6 // 5 // 3 // "" Using reviver when paired with the replacer of JSON.stringify() In order for a value to properly round-trip (that is, it gets deserialized to the same original object), the serialization process must preserve the type information. For example, you can use the replacer parameter of JSON.stringify() for this purpose: js // Maps are normally serialized as objects with no properties. // We can use the replacer to specify the entries to be serialized. const map = new Map([ [1, "one"], [2, "two"], [3, "three"], ]); const jsonText = JSON.stringify(map, (key, value) => value instanceof Map ? Array.from(value.entries()) : value, ); console.log(jsonText); // [[1,"one"],[2,"two"],[3,"three"]] const map2 = JSON.parse(jsonText, (key, value) => Array.isArray(value) && value.every(Array.isArray) ? new Map(value) : value, ); console.log(map2); // Map { 1 => "one", 2 => "two", 3 => "three" } Because JSON has no syntax space for annotating type metadata, in order to revive values that are not plain objects, you have to consider one of the following: Serialize the entire object to a string and prefix it with a type tag. "Guess" based on the structure of the data (for example, an array of two-member arrays) If the shape of the payload is fixed, based on the property name (for example, all properties called registry hold Map objects). Illegal JSON When JSON.parse receives a string that does not conform to the JSON grammar, it throws a SyntaxError . Arrays and objects cannot have trailing commas in JSON: js JSON.parse("[1, 2, 3, 4, ]"); // SyntaxError: Unexpected token ] in JSON at position 13 JSON.parse('{"foo": 1, }'); // SyntaxError: Unexpected token } in JSON at position 12 JSON strings must be delimited by double (not single) quotes: js JSON.parse("{'foo': 1}"); // SyntaxError: Unexpected token ' in JSON at position 1 JSON.parse("'string'"); // SyntaxError: Unexpected token ' in JSON at position 0 If you are writing JSON inside a JavaScript string literal, you should either use single quotes to delimit the JavaScript string literal, or escape the double quotes that delimit the JSON string: js JSON.parse('{"foo": 1}'); // OK JSON.parse("{\"foo\": 1}"); // OK Specifications Specification ECMAScript® 2026 Language Specification # sec-json.parse Browser compatibility Loading… See also Polyfill of modern JSON.parse behavior (reviver's context parameter) in core-js JSON.stringify() Help improve MDN Was this page helpful to you? Yes No Learn how to contribute This page was last modified on ⁨Jul 20, 2025⁩ by MDN contributors . View this page on GitHub • Report a problem with this content Filter sidebar Standard built-in objects JSON Static methods isRawJSON() parse() rawJSON() stringify() Your blueprint for a better internet. MDN About Blog Mozilla careers Advertise with us MDN Plus Product help Contribute MDN Community Community resources Writing guidelines MDN Discord MDN on GitHub Developers Web technologies Learn web development Guides Tutorials Glossary Hacks blog Website Privacy Notice Telemetry Settings Legal Community Participation Guidelines Visit Mozilla Corporation’s not-for-profit parent, the Mozilla Foundation . Portions of this content are ©1998–⁨2025⁩ by individual mozilla.org contributors. Content available under a Creative Commons license .