JSON.stringify() - JavaScript | MDN Skip to main content Skip to search MDN HTML HTML: Markup language HTML reference Elements Global attributes Attributes See all… HTML guides Responsive images HTML cheatsheet Date & time formats See all… Markup languages SVG MathML XML CSS CSS: Styling language CSS reference Properties Selectors At-rules Values & units See all… CSS guides Box model Animations Flexbox Colors See all… Layout cookbook Column layouts Centering an element Card component See all… JavaScript JS JavaScript: Scripting language JS reference Standard built-in objects Expressions & operators Statements & declarations Functions See all… JS guides Control flow & error handing Loops and iteration Working with objects Using classes See all… Web APIs Web APIs: Programming interfaces Web API reference File system API Fetch API Geolocation API HTML DOM API Push API Service worker API See all… Web API guides Using the Web animation API Using the Fetch API Working with the History API Using the Web speech API Using web workers All All web technology Technologies Accessibility HTTP URI Web extensions WebAssembly WebDriver See all… Topics Media Performance Privacy Security Progressive web apps Learn Learn web development Frontend developer course Getting started Common questions Curriculum Learn HTML Introduction to HTML Getting started with HTML Learn CSS What is CSS Getting started with CSS Learn JavaScript How to use data attributes Add JavaScript to your web page Tools Discover our tools Playground HTTP Observatory Border-image generator Border-radius generator Box-shadow generator Color format converter Color mixer Shape generator About Get to know MDN better About MDN Advertise with us Community MDN on GitHub Blog Toggle sidebar Web JavaScript Reference Standard built-in objects JSON stringify() Theme OS default Light Dark English (US) Remember language Learn more Deutsch English (US) Español Français 日本語 한국어 Português (do Brasil) Русский 中文 (简体) JSON.stringify() Baseline Widely available This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩. Learn more See full compatibility Report feedback The JSON.stringify() static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified. In this article Try it Syntax Description Examples Specifications Browser compatibility See also Try it console.log(JSON.stringify({ x: 5, y: 6 })); // Expected output: '{"x":5,"y":6}' console.log( JSON.stringify([new Number(3), new String("false"), new Boolean(false)]), ); // Expected output: '[3,"false",false]' console.log(JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] })); // Expected output: '{"x":[10,null,null,null]}' console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5))); // Expected output: '"2006-01-02T15:04:05.000Z"' Syntax js JSON.stringify(value) JSON.stringify(value, replacer) JSON.stringify(value, replacer, space) Parameters value The value to convert to a JSON string. replacer Optional A function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g., null or not provided), all string-keyed properties of the object are included in the resulting JSON string. space Optional A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes. If this is a number, it indicates the number of space characters to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10 ). Values less than 1 indicate that no space should be used. If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array. If space is anything other than a string or number (can be either a primitive or a wrapper object) — for example, is null or not provided — no white space is used. Return value A JSON string representing the given value, or undefined. Exceptions TypeError Thrown in one of the following cases: value contains a circular reference. A BigInt value is encountered. Description JSON.stringify() converts a value to the JSON notation that the value represents. Values are stringified in the following manner: Boolean , Number , String , and BigInt (obtainable via Object() ) objects are converted to the corresponding primitive values during stringification, in accordance with the traditional conversion semantics. Symbol objects (obtainable via Object() ) are treated as plain objects. Attempting to serialize BigInt values will throw. However, if the BigInt has a toJSON() method (through monkey patching: BigInt.prototype.toJSON = ... ), that method can provide the serialization result. This constraint ensures that a proper serialization (and, very likely, its accompanying deserialization) behavior is always explicitly provided by the user. undefined , Function , and Symbol values are not valid JSON values. If any such values are encountered during conversion, they are either omitted (when found in an object) or changed to null (when found in an array). JSON.stringify() can return undefined when passing in "pure" values like JSON.stringify(() => {}) or JSON.stringify(undefined) . The numbers Infinity and NaN , as well as the value null , are all considered null . (But unlike the values in the previous point, they would never be omitted.) Arrays are serialized as arrays (enclosed by square brackets). Only array indices between 0 and length - 1 (inclusive) are serialized; other properties are ignored. The special raw JSON object created with JSON.rawJSON() is serialized as the raw JSON text it contains (by accessing its rawJSON property). For other objects: All Symbol -keyed properties will be completely ignored, even when using the replacer parameter. If the value has a toJSON() method, it's responsible to define what data will be serialized. Instead of the object being serialized, the value returned by the toJSON() method when called will be serialized. JSON.stringify() calls toJSON with one parameter, the key , which has the same semantic as the key parameter of the replacer function: if this object is a property value, the property name if it is in an array, the index in the array, as a string if JSON.stringify() was directly called on this object, an empty string All Temporal objects implement the toJSON() method, which returns a string (the same as calling toString() ). Thus, they will be serialized as strings. Similarly, Date objects implement toJSON() , which returns the same as toISOString() . Only enumerable own properties are visited. This means Map , Set , etc. will become "{}" . You can use the replacer parameter to serialize them to something more useful. Properties are visited using the same algorithm as Object.keys() , which has a well-defined order and is stable across implementations. For example, JSON.stringify on the same object will always produce the same string, and JSON.parse(JSON.stringify(obj)) would produce an object with the same key ordering as the original (assuming the object is completely JSON-serializable). The replacer parameter The replacer parameter can be either a function or an array. As an array, its elements indicate the names of the properties in the object that should be included in the resulting JSON string. Only string and number values are taken into account; symbol keys are ignored. As a function, it takes two parameters: the key and the value being stringified. The object in which the key was found is provided as the replacer 's this context. The replacer function is called for the initial object being stringified as well, in which case the key is an empty string ( "" ). It is then called for each property on the object or array being stringified. Array indices will be provided in its string form as key . The current property value will be replaced with the replacer 's return value for stringification. This means: If you return a number, string, boolean, or null , that value is directly serialized and used as the property's value. (Returning a BigInt will throw as well.) If you return a Function , Symbol , or undefined , the property is not included in the output. If you return any other object, the object is recursively stringified, calling the replacer function on each property. Note: When parsing JSON generated with replacer functions, you would likely want to use the reviver parameter to perform the reverse operation. Typically, array elements' index would never shift (even when the element is an invalid value like a function, it will become null instead of omitted). Using the replacer function allows you to control the order of the array elements by returning a different array. The space parameter The space parameter may be used to control spacing in the final string. If it is a number, successive levels in the stringification will each be indented by this many space characters. If it is a string, successive levels will be indented by this string. Each level of indentation will never be longer than 10. Number values of space are clamped to 10, and string values are truncated to 10 characters. Examples Using JSON.stringify js JSON.stringify({}); // '{}' JSON.stringify(true); // 'true' JSON.stringify("foo"); // '"foo"' JSON.stringify([1, "false", false]); // '[1,"false",false]' JSON.stringify([NaN, null, Infinity]); // '[null,null,null]' JSON.stringify({ x: 5 }); // '{"x":5}' JSON.stringify(new Date(1906, 0, 2, 15, 4, 5)); // '"1906-01-02T15:04:05.000Z"' JSON.stringify({ x: 5, y: 6 }); // '{"x":5,"y":6}' JSON.stringify([new Number(3), new String("false"), new Boolean(false)]); // '[3,"false",false]' // String-keyed array elements are not enumerable and make no sense in JSON const a = ["foo", "bar"]; a["baz"] = "quux"; // a: [ 0: 'foo', 1: 'bar', baz: 'quux' ] JSON.stringify(a); // '["foo","bar"]' JSON.stringify({ x: [10, undefined, function () {}, Symbol("")] }); // '{"x":[10,null,null,null]}' // Standard data structures JSON.stringify([ new Set([1]), new Map([[1, 2]]), new WeakSet([{ a: 1 }]), new WeakMap([[{ a: 1 }, 2]]), ]); // '[{},{},{},{}]' // TypedArray JSON.stringify([new Int8Array([1]), new Int16Array([1]), new Int32Array([1])]); // '[{"0":1},{"0":1},{"0":1}]' JSON.stringify([ new Uint8Array([1]), new Uint8ClampedArray([1]), new Uint16Array([1]), new Uint32Array([1]), ]); // '[{"0":1},{"0":1},{"0":1},{"0":1}]' JSON.stringify([new Float32Array([1]), new Float64Array([1])]); // '[{"0":1},{"0":1}]' // toJSON() JSON.stringify({ x: 5, y: 6, toJSON() { return this.x + this.y; }, }); // '11' // Symbols: JSON.stringify({ x: undefined, y: Object, z: Symbol("") }); // '{}' JSON.stringify({ [Symbol("foo")]: "foo" }); // '{}' JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]); // '{}' JSON.stringify({ [Symbol.for("foo")]: "foo" }, (k, v) => { if (typeof k === "symbol") { return "a symbol"; } }); // undefined // Non-enumerable properties: JSON.stringify( Object.create(null, { x: { value: "x", enumerable: false }, y: { value: "y", enumerable: true }, }), ); // '{"y":"y"}' // BigInt values throw JSON.stringify({ x: 2n }); // TypeError: BigInt value can't be serialized in JSON Using a function as replacer js function replacer(key, value) { // Filtering out properties if (typeof value === "string") { return undefined; } return value; } const foo = { foundation: "Mozilla", model: "box", week: 45, transport: "car", month: 7, }; JSON.stringify(foo, replacer); // '{"week":45,"month":7}' If you wish the replacer to distinguish an initial object from a key with an empty string property (since both would give the empty string as key and potentially an object as value), you will have to keep track of the iteration count (if it is beyond the first iteration, it is a genuine empty string key). js function makeReplacer() { let isInitial = true; return (key, value) => { if (isInitial) { isInitial = false; return value; } if (key === "") { // Omit all properties with name "" (except the initial object) return undefined; } return value; }; } const replacer = makeReplacer(); console.log(JSON.stringify({ "": 1, b: 2 }, replacer)); // "{"b":2}" Using an array as replacer js const foo = { foundation: "Mozilla", model: "box", week: 45, transport: "car", month: 7, }; JSON.stringify(foo, ["week", "month"]); // '{"week":45,"month":7}', only keep "week" and "month" properties Using the space parameter Indent the output with one space: js console.log(JSON.stringify({ a: 2 }, null, " ")); /* { "a": 2 } */ Using a tab character mimics standard pretty-print appearance: js console.log(JSON.stringify({ uno: 1, dos: 2 }, null, "\t")); /* { "uno": 1, "dos": 2 } */ toJSON() behavior Defining toJSON() for an object allows overriding its serialization behavior. js const obj = { data: "data", toJSON(key) { return key ? `Now I am a nested object under key '${key}'` : this; }, }; JSON.stringify(obj); // '{"data":"data"}' JSON.stringify({ obj }); // '{"obj":"Now I am a nested object under key 'obj'"}' JSON.stringify([obj]); // '["Now I am a nested object under key '0'"]' Issue with serializing circular references Since the JSON format doesn't support object references (although an IETF draft exists ), a TypeError will be thrown if one attempts to encode an object with circular references. js const circularReference = {}; circularReference.myself = circularReference; // Serializing circular references throws "TypeError: cyclic object value" JSON.stringify(circularReference); To serialize circular references, you can use a library that supports them (e.g., cycle.js by Douglas Crockford) or implement a solution yourself, which will require finding and replacing (or removing) the cyclic references by serializable values. If you are using JSON.stringify() to deep-copy an object, you may instead want to use structuredClone() , which supports circular references. JavaScript engine APIs for binary serialization, such as v8.serialize() , also support circular references. Using JSON.stringify() with localStorage In a case where you want to store an object created by your user and allow it to be restored even after the browser has been closed, the following example is a model for the applicability of JSON.stringify() : js // Creating an example of JSON const session = { screens: [], state: true, }; session.screens.push({ name: "screenA", width: 450, height: 250 }); session.screens.push({ name: "screenB", width: 650, height: 350 }); session.screens.push({ name: "screenC", width: 750, height: 120 }); session.screens.push({ name: "screenD", width: 250, height: 60 }); session.screens.push({ name: "screenE", width: 390, height: 120 }); session.screens.push({ name: "screenF", width: 1240, height: 650 }); // Converting the JSON string with JSON.stringify() // then saving with localStorage in the name of session localStorage.setItem("session", JSON.stringify(session)); // Example of how to transform the String generated through // JSON.stringify() and saved in localStorage in JSON object again const restoredSession = JSON.parse(localStorage.getItem("session")); // Now restoredSession variable contains the object that was saved // in localStorage console.log(restoredSession); Well-formed JSON.stringify() Engines implementing the well-formed JSON.stringify specification will stringify lone surrogates (any code point from U+D800 to U+DFFF) using Unicode escape sequences rather than literally (outputting lone surrogates). Before this change, such strings could not be encoded in valid UTF-8 or UTF-16: js JSON.stringify("\uD800"); // '"�"' But with this change JSON.stringify() represents lone surrogates using JSON escape sequences that can be encoded in valid UTF-8 or UTF-16: js JSON.stringify("\uD800"); // '"\\ud800"' This change should be backwards-compatible as long as you pass the result of JSON.stringify() to APIs such as JSON.parse() that will accept any valid JSON text, because they will treat Unicode escapes of lone surrogates as identical to the lone surrogates themselves. Only if you are directly interpreting the result of JSON.stringify() do you need to carefully handle JSON.stringify() 's two possible encodings of these code points. Specifications Specification ECMAScript® 2026 Language Specification # sec-json.stringify Browser compatibility Loading… See also Polyfill of modern JSON.stringify behavior (symbol, well-formed unicode, raw JSON) in core-js JSON.parse() JSON.rawJSON() Help improve MDN Was this page helpful to you? Yes No Learn how to contribute This page was last modified on ⁨Jul 10, 2025⁩ by MDN contributors . View this page on GitHub • Report a problem with this content Filter sidebar Standard built-in objects JSON Static methods isRawJSON() parse() rawJSON() stringify() Your blueprint for a better internet. MDN About Blog Mozilla careers Advertise with us MDN Plus Product help Contribute MDN Community Community resources Writing guidelines MDN Discord MDN on GitHub Developers Web technologies Learn web development Guides Tutorials Glossary Hacks blog Website Privacy Notice Telemetry Settings Legal Community Participation Guidelines Visit Mozilla Corporation’s not-for-profit parent, the Mozilla Foundation . Portions of this content are ©1998–⁨2025⁩ by individual mozilla.org contributors. Content available under a Creative Commons license .