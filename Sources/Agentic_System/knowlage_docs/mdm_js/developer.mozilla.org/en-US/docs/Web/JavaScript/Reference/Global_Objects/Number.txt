Number - JavaScript | MDN Skip to main content Skip to search MDN HTML HTML: Markup language HTML reference Elements Global attributes Attributes See all… HTML guides Responsive images HTML cheatsheet Date & time formats See all… Markup languages SVG MathML XML CSS CSS: Styling language CSS reference Properties Selectors At-rules Values & units See all… CSS guides Box model Animations Flexbox Colors See all… Layout cookbook Column layouts Centering an element Card component See all… JavaScript JS JavaScript: Scripting language JS reference Standard built-in objects Expressions & operators Statements & declarations Functions See all… JS guides Control flow & error handing Loops and iteration Working with objects Using classes See all… Web APIs Web APIs: Programming interfaces Web API reference File system API Fetch API Geolocation API HTML DOM API Push API Service worker API See all… Web API guides Using the Web animation API Using the Fetch API Working with the History API Using the Web speech API Using web workers All All web technology Technologies Accessibility HTTP URI Web extensions WebAssembly WebDriver See all… Topics Media Performance Privacy Security Progressive web apps Learn Learn web development Frontend developer course Getting started Common questions Curriculum Learn HTML Introduction to HTML Getting started with HTML Learn CSS What is CSS Getting started with CSS Learn JavaScript How to use data attributes Add JavaScript to your web page Tools Discover our tools Playground HTTP Observatory Border-image generator Border-radius generator Box-shadow generator Color format converter Color mixer Shape generator About Get to know MDN better About MDN Advertise with us Community MDN on GitHub Blog Toggle sidebar Web JavaScript Reference Standard built-in objects Number Theme OS default Light Dark English (US) Remember language Learn more Deutsch English (US) Español Français 日本語 한국어 Português (do Brasil) Русский 中文 (简体) 正體中文 (繁體) Number Baseline Widely available This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩. Learn more See full compatibility Report feedback Number values represent floating-point numbers like 37 or -9.25 . The Number constructor contains constants and methods for working with numbers. Values of other types can be converted to numbers using the Number() function. In this article Description Constructor Static properties Static methods Instance properties Instance methods Examples Specifications Browser compatibility See also Description Numbers are most commonly expressed in literal forms like 255 or 3.14159 . The lexical grammar contains a more detailed reference. js 255; // two-hundred and fifty-five 255.0; // same number 255 === 255.0; // true 255 === 0xff; // true (hexadecimal notation) 255 === 0b11111111; // true (binary notation) 255 === 0.255e3; // true (decimal exponential notation) A number literal like 37 in JavaScript code is a floating-point value, not an integer. There is no separate integer type in common everyday use. (JavaScript also has a BigInt type, but it's not designed to replace Number for everyday uses. 37 is still a number, not a BigInt.) When used as a function, Number(value) converts a string or other value to the Number type. If the value can't be converted, it returns NaN . js Number("123"); // returns the number 123 Number("123") === 123; // true Number("unicorn"); // NaN Number(undefined); // NaN Number encoding The JavaScript Number type is a double-precision 64-bit binary format IEEE 754 value, like double in Java or C#. This means it can represent fractional values, but there are some limits to the stored number's magnitude and precision. Very briefly, an IEEE 754 double-precision number uses 64 bits to represent 3 parts: 1 bit for the sign (positive or negative) 11 bits for the exponent (-1022 to 1023) 52 bits for the mantissa (representing a number between 0 and 1) The mantissa (also called significand ) is the part of the number representing the actual value (significant digits). The exponent is the power of 2 that the mantissa should be multiplied by. Thinking about it as scientific notation: Number = ( − 1 ) sign ⋅ ( 1 + mantissa ) ⋅ 2 exponent \text{Number} = ({-1})^{\text{sign}} \cdot (1 + \text{mantissa}) \cdot 2^{\text{exponent}} The mantissa is stored with 52 bits, interpreted as digits after 1.… in a binary fractional number. Therefore, the mantissa's precision is 2 -52 (obtainable via Number.EPSILON ), or about 15 to 17 decimal places; arithmetic above that level of precision is subject to rounding . The largest value a number can hold is 2 1023 × (2 - 2 -52 ) (with the exponent being 1023 and the mantissa being 0.1111… in base 2), which is obtainable via Number.MAX_VALUE . Values higher than that are replaced with the special number constant Infinity . Integers can only be represented without loss of precision in the range -2 53 + 1 to 2 53 - 1, inclusive (obtainable via Number.MIN_SAFE_INTEGER and Number.MAX_SAFE_INTEGER ), because the mantissa can only hold 53 bits (including the leading 1). More details on this are described in the ECMAScript standard . Number coercion Many built-in operations that expect numbers first coerce their arguments to numbers (which is largely why Number objects behave similarly to number primitives). The operation can be summarized as follows: Numbers are returned as-is. undefined turns into NaN . null turns into 0 . true turns into 1 ; false turns into 0 . Strings are converted by parsing them as if they contain a number literal . Parsing failure results in NaN . There are some minor differences compared to an actual number literal: Leading and trailing whitespace/line terminators are ignored. A leading 0 digit does not cause the number to become an octal literal (or get rejected in strict mode). + and - are allowed at the start of the string to indicate its sign. (In actual code, they "look like" part of the literal, but are actually separate unary operators.) However, the sign can only appear once, and must not be followed by whitespace. Infinity and -Infinity are recognized as literals. In actual code, they are global variables. Empty or whitespace-only strings are converted to 0 . Numeric separators are not allowed. BigInts throw a TypeError to prevent unintended implicit coercion causing loss of precision. Symbols throw a TypeError . Objects are first converted to a primitive by calling their [Symbol.toPrimitive]() (with "number" as hint), valueOf() , and toString() methods, in that order. The resulting primitive is then converted to a number. There are two ways to achieve nearly the same effect in JavaScript. Unary plus : +x does exactly the number coercion steps explained above to convert x . The Number() function: Number(x) uses the same algorithm to convert x , except that BigInts don't throw a TypeError , but return their number value, with possible loss of precision. Number.parseFloat() and Number.parseInt() are similar to Number() but only convert strings, and have slightly different parsing rules. For example, parseInt() doesn't recognize the decimal point, and parseFloat() doesn't recognize the 0x prefix. Integer conversion Some operations expect integers, most notably those that work with array/string indices, date/time components, and number radixes. After performing the number coercion steps above, the result is truncated to an integer (by discarding the fractional part). If the number is ±Infinity, it's returned as-is. If the number is NaN or -0 , it's returned as 0 . The result is therefore always an integer (which is not -0 ) or ±Infinity. Notably, when converted to integers, both undefined and null become 0 , because undefined is converted to NaN , which also becomes 0 . Fixed-width number conversion JavaScript has some lower-level functions that deal with the binary encoding of integer numbers, most notably bitwise operators and TypedArray objects. Bitwise operators always convert the operands to 32-bit integers. In these cases, after converting the value to a number, the number is then normalized to the given width by first truncating the fractional part and then taking the lowest bits in the integer's two's complement encoding. js new Int32Array([1.1, 1.9, -1.1, -1.9]); // Int32Array(4) [ 1, 1, -1, -1 ] new Int8Array([257, -257]); // Int8Array(2) [ 1, -1 ] // 257 = 0001 0000 0001 // = 0000 0001 (mod 2^8) // = 1 // -257 = 1110 1111 1111 // = 1111 1111 (mod 2^8) // = -1 (as signed integer) new Uint8Array([257, -257]); // Uint8Array(2) [ 1, 255 ] // -257 = 1110 1111 1111 // = 1111 1111 (mod 2^8) // = 255 (as unsigned integer) Constructor Number() Creates Number objects. When called as a function, it returns primitive values of type Number. Static properties Number.EPSILON The smallest interval between two representable numbers. Number.MAX_SAFE_INTEGER The maximum safe integer in JavaScript (2 53 - 1). Number.MAX_VALUE The largest positive representable number. Number.MIN_SAFE_INTEGER The minimum safe integer in JavaScript (-(2 53 - 1)). Number.MIN_VALUE The smallest positive representable number—that is, the positive number closest to zero (without actually being zero). Number.NaN Special " N ot a N umber" value. Number.NEGATIVE_INFINITY Special value representing negative infinity. Returned on overflow. Number.POSITIVE_INFINITY Special value representing infinity. Returned on overflow. Static methods Number.isFinite() Determine whether the passed value is a finite number. Number.isInteger() Determine whether the passed value is an integer. Number.isNaN() Determine whether the passed value is NaN . Number.isSafeInteger() Determine whether the passed value is a safe integer (number between -(2 53 - 1) and 2 53 - 1). Number.parseFloat() This is the same as the global parseFloat() function. Number.parseInt() This is the same as the global parseInt() function. Instance properties These properties are defined on Number.prototype and shared by all Number instances. Number.prototype.constructor The constructor function that created the instance object. For Number instances, the initial value is the Number constructor. Instance methods Number.prototype.toExponential() Returns a string representing the number in exponential notation. Number.prototype.toFixed() Returns a string representing the number in fixed-point notation. Number.prototype.toLocaleString() Returns a string with a language sensitive representation of this number. Overrides the Object.prototype.toLocaleString() method. Number.prototype.toPrecision() Returns a string representing the number to a specified precision in fixed-point or exponential notation. Number.prototype.toString() Returns a string representing the specified object in the specified radix ("base"). Overrides the Object.prototype.toString() method. Number.prototype.valueOf() Returns the primitive value of the specified object. Overrides the Object.prototype.valueOf() method. Examples Using the Number object to assign values to numeric variables The following example uses the Number object's properties to assign values to several numeric variables: js const biggestNum = Number.MAX_VALUE; const smallestNum = Number.MIN_VALUE; const infiniteNum = Number.POSITIVE_INFINITY; const negInfiniteNum = Number.NEGATIVE_INFINITY; const notANum = Number.NaN; Integer range for Number The following example shows the minimum and maximum integer values that can be represented as Number object. js const biggestInt = Number.MAX_SAFE_INTEGER; // (2**53 - 1) => 9007199254740991 const smallestInt = Number.MIN_SAFE_INTEGER; // -(2**53 - 1) => -9007199254740991 When parsing data that has been serialized to JSON, integer values falling outside of this range can be expected to become corrupted when JSON parser coerces them to Number type. A possible workaround is to use String instead. Larger numbers can be represented using the BigInt type. Using Number() to convert a Date object The following example converts the Date object to a numerical value using Number as a function: js const d = new Date("1995-12-17T03:24:00"); console.log(Number(d)); This logs 819199440000 . Convert numeric strings and null to numbers js Number("123"); // 123 Number("123") === 123; // true Number("12.3"); // 12.3 Number("12.00"); // 12 Number("123e-1"); // 12.3 Number(""); // 0 Number(null); // 0 Number("0x11"); // 17 Number("0b11"); // 3 Number("0o11"); // 9 Number("foo"); // NaN Number("100a"); // NaN Number("-Infinity"); // -Infinity Specifications Specification ECMAScript® 2026 Language Specification # sec-number-objects Browser compatibility Loading… See also Polyfill of modern Number behavior (with support binary and octal literals) in core-js NaN Arithmetic operators Math BigInt Help improve MDN Was this page helpful to you? Yes No Learn how to contribute This page was last modified on ⁨Jul 10, 2025⁩ by MDN contributors . View this page on GitHub • Report a problem with this content Filter sidebar Standard built-in objects Number Constructor Number() Static methods isFinite() isInteger() isNaN() isSafeInteger() parseFloat() parseInt() Static properties EPSILON MAX_SAFE_INTEGER MAX_VALUE MIN_SAFE_INTEGER MIN_VALUE NaN NEGATIVE_INFINITY POSITIVE_INFINITY Instance methods toExponential() toFixed() toLocaleString() toPrecision() toString() valueOf() Inheritance Object/Function Static methods apply() bind() call() toString() [Symbol .hasInstance]() Static properties displayName Non-standard length name prototype arguments Non-standard Deprecated caller Non-standard Deprecated Instance methods __defineGetter__() Deprecated __defineSetter__() Deprecated __lookupGetter__() Deprecated __lookupSetter__() Deprecated hasOwnProperty() isPrototypeOf() propertyIsEnumerable() toLocaleString() toString() valueOf() Instance properties __proto__ Deprecated constructor Your blueprint for a better internet. MDN About Blog Mozilla careers Advertise with us MDN Plus Product help Contribute MDN Community Community resources Writing guidelines MDN Discord MDN on GitHub Developers Web technologies Learn web development Guides Tutorials Glossary Hacks blog Website Privacy Notice Telemetry Settings Legal Community Participation Guidelines Visit Mozilla Corporation’s not-for-profit parent, the Mozilla Foundation . Portions of this content are ©1998–⁨2025⁩ by individual mozilla.org contributors. Content available under a Creative Commons license .