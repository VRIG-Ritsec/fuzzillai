Promise.resolve() - JavaScript | MDN Skip to main content Skip to search MDN HTML HTML: Markup language HTML reference Elements Global attributes Attributes See all… HTML guides Responsive images HTML cheatsheet Date & time formats See all… Markup languages SVG MathML XML CSS CSS: Styling language CSS reference Properties Selectors At-rules Values & units See all… CSS guides Box model Animations Flexbox Colors See all… Layout cookbook Column layouts Centering an element Card component See all… JavaScript JS JavaScript: Scripting language JS reference Standard built-in objects Expressions & operators Statements & declarations Functions See all… JS guides Control flow & error handing Loops and iteration Working with objects Using classes See all… Web APIs Web APIs: Programming interfaces Web API reference File system API Fetch API Geolocation API HTML DOM API Push API Service worker API See all… Web API guides Using the Web animation API Using the Fetch API Working with the History API Using the Web speech API Using web workers All All web technology Technologies Accessibility HTTP URI Web extensions WebAssembly WebDriver See all… Topics Media Performance Privacy Security Progressive web apps Learn Learn web development Frontend developer course Getting started Common questions Curriculum Learn HTML Introduction to HTML Getting started with HTML Learn CSS What is CSS Getting started with CSS Learn JavaScript How to use data attributes Add JavaScript to your web page Tools Discover our tools Playground HTTP Observatory Border-image generator Border-radius generator Box-shadow generator Color format converter Color mixer Shape generator About Get to know MDN better About MDN Advertise with us Community MDN on GitHub Blog Toggle sidebar Web JavaScript Reference Standard built-in objects Promise resolve() Theme OS default Light Dark English (US) Remember language Learn more Deutsch English (US) Español Français 日本語 한국어 Português (do Brasil) Русский 中文 (简体) 正體中文 (繁體) Promise.resolve() Baseline Widely available This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩. Learn more See full compatibility Report feedback The Promise.resolve() static method "resolves" a given value to a Promise . If the value is a promise, that promise is returned; if the value is a thenable , Promise.resolve() will call the then() method with two callbacks it prepared; otherwise the returned promise will be fulfilled with the value. This function flattens nested layers of promise-like objects (e.g., a promise that fulfills to a promise that fulfills to something) into a single layer — a promise that fulfills to a non-thenable value. In this article Try it Syntax Description Examples Specifications Browser compatibility See also Try it const promise1 = Promise.resolve(123); promise1.then((value) => { console.log(value); // Expected output: 123 }); Syntax js Promise.resolve(value) Parameters value Argument to be resolved by this Promise . Can also be a Promise or a thenable to resolve. Return value A Promise that is resolved with the given value, or the promise passed as value, if the value was a promise object. A resolved promise can be in any of the states — fulfilled, rejected, or pending. For example, resolving a rejected promise will still result in a rejected promise. Description Promise.resolve() resolves a promise, which is not the same as fulfilling or rejecting the promise. See Promise description for definitions of the terminology. In brief, Promise.resolve() returns a promise whose eventual state depends on another promise, thenable object, or other value. Note: If evaluating the value expression may synchronously throw an error, this error won't be caught and wrapped in a rejected promise by Promise.resolve() . Consider using Promise.try(() => value) in this case. Promise.resolve() is generic and supports subclassing, which means it can be called on subclasses of Promise , and the result will be a promise of the subclass type. To do so, the subclass's constructor must implement the same signature as the Promise() constructor — accepting a single executor function that can be called with the resolve and reject callbacks as parameters. Promise.resolve() special-cases native Promise instances. If value belongs to Promise or a subclass, and value.constructor === Promise , then value is directly returned by Promise.resolve() , without creating a new Promise instance. Otherwise, Promise.resolve() is essentially a shorthand for new Promise((resolve) => resolve(value)) . The bulk of the resolving logic is actually implemented by the resolve function passed by the Promise() constructor. In summary: If a non- thenable value is passed, the returned promise is already fulfilled with that value. If a thenable is passed, the returned promise will adopt the state of that thenable by calling the then method and passing a pair of resolving functions as arguments. (But because native promises directly pass through Promise.resolve() without creating a wrapper, the then method is not called on native promises.) If the resolve function receives another thenable object, it will be resolved again, so that the eventual fulfillment value of the promise will never be thenable. Examples Using the static Promise.resolve method js Promise.resolve("Success").then( (value) => { console.log(value); // "Success" }, (reason) => { // not called }, ); Resolving an array js const p = Promise.resolve([1, 2, 3]); p.then((v) => { console.log(v[0]); // 1 }); Resolving another Promise Promise.resolve() reuses existing Promise instances. If it's resolving a native promise, it returns the same promise instance without creating a wrapper. js const original = Promise.resolve(33); const cast = Promise.resolve(original); cast.then((value) => { console.log(`value: ${value}`); }); console.log(`original === cast ? ${original === cast}`); // Logs, in order: // original === cast ? true // value: 33 The inverted order of the logs is due to the fact that the then handlers are called asynchronously. See the then() reference for more information. Resolving thenables and throwing Errors js // Resolving a thenable object const p1 = Promise.resolve({ then(onFulfill, onReject) { onFulfill("fulfilled!"); }, }); console.log(p1 instanceof Promise); // true, object casted to a Promise p1.then( (v) => { console.log(v); // "fulfilled!" }, (e) => { // not called }, ); // Thenable throws // Promise rejects const p2 = Promise.resolve({ then() { throw new TypeError("Throwing"); }, }); p2.then( (v) => { // not called }, (e) => { console.error(e); // TypeError: Throwing }, ); // Thenable throws after callback // Promise resolves const p3 = Promise.resolve({ then(onFulfilled) { onFulfilled("Resolving"); throw new TypeError("Throwing"); }, }); p3.then( (v) => { console.log(v); // "Resolving" }, (e) => { // not called }, ); Nested thenables will be "deeply flattened" to a single promise. js const thenable = { then(onFulfilled, onRejected) { onFulfilled({ // The thenable is fulfilled with another thenable then(onFulfilled, onRejected) { onFulfilled(42); }, }); }, }; Promise.resolve(thenable).then((v) => { console.log(v); // 42 }); Warning: Do not call Promise.resolve() on a thenable that resolves to itself. That leads to infinite recursion, because it attempts to flatten an infinitely-nested promise. js const thenable = { then(onFulfilled, onRejected) { onFulfilled(thenable); }, }; Promise.resolve(thenable); // Will lead to infinite recursion. Calling resolve() on a non-Promise constructor Promise.resolve() is a generic method. It can be called on any constructor that implements the same signature as the Promise() constructor. For example, we can call it on a constructor that passes it console.log as resolve : js class NotPromise { constructor(executor) { // The "resolve" and "reject" functions behave nothing like the // native promise's, but Promise.resolve() calls them in the same way. executor( (value) => console.log("Resolved", value), (reason) => console.log("Rejected", reason), ); } } Promise.resolve.call(NotPromise, "foo"); // Logs "Resolved foo" The ability to flatten nested thenables is implemented by the resolve function of the Promise() constructor, so if you call it on another constructor, nested thenables may not be flattened, depending on how that constructor implements its resolve function. js const thenable = { then(onFulfilled, onRejected) { onFulfilled({ // The thenable is fulfilled with another thenable then(onFulfilled, onRejected) { onFulfilled(42); }, }); }, }; Promise.resolve.call(NotPromise, thenable); // Logs "Resolved { then: [Function: then] }" Specifications Specification ECMAScript® 2026 Language Specification # sec-promise.resolve Browser compatibility Loading… See also Promise Help improve MDN Was this page helpful to you? Yes No Learn how to contribute This page was last modified on ⁨Jul 10, 2025⁩ by MDN contributors . View this page on GitHub • Report a problem with this content Filter sidebar Standard built-in objects Promise Constructor Promise() Static methods all() allSettled() any() race() reject() resolve() try() withResolvers() Static properties [Symbol .species] Instance methods catch() finally() then() Inheritance Object/Function Static methods apply() bind() call() toString() [Symbol .hasInstance]() Static properties displayName Non-standard length name prototype arguments Non-standard Deprecated caller Non-standard Deprecated Instance methods __defineGetter__() Deprecated __defineSetter__() Deprecated __lookupGetter__() Deprecated __lookupSetter__() Deprecated hasOwnProperty() isPrototypeOf() propertyIsEnumerable() toLocaleString() toString() valueOf() Instance properties __proto__ Deprecated constructor Your blueprint for a better internet. MDN About Blog Mozilla careers Advertise with us MDN Plus Product help Contribute MDN Community Community resources Writing guidelines MDN Discord MDN on GitHub Developers Web technologies Learn web development Guides Tutorials Glossary Hacks blog Website Privacy Notice Telemetry Settings Legal Community Participation Guidelines Visit Mozilla Corporation’s not-for-profit parent, the Mozilla Foundation . Portions of this content are ©1998–⁨2025⁩ by individual mozilla.org contributors. Content available under a Creative Commons license .