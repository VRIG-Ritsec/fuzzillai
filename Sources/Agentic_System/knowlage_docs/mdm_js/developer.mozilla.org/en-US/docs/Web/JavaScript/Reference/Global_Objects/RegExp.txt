RegExp - JavaScript | MDN Skip to main content Skip to search MDN HTML HTML: Markup language HTML reference Elements Global attributes Attributes See all… HTML guides Responsive images HTML cheatsheet Date & time formats See all… Markup languages SVG MathML XML CSS CSS: Styling language CSS reference Properties Selectors At-rules Values & units See all… CSS guides Box model Animations Flexbox Colors See all… Layout cookbook Column layouts Centering an element Card component See all… JavaScript JS JavaScript: Scripting language JS reference Standard built-in objects Expressions & operators Statements & declarations Functions See all… JS guides Control flow & error handing Loops and iteration Working with objects Using classes See all… Web APIs Web APIs: Programming interfaces Web API reference File system API Fetch API Geolocation API HTML DOM API Push API Service worker API See all… Web API guides Using the Web animation API Using the Fetch API Working with the History API Using the Web speech API Using web workers All All web technology Technologies Accessibility HTTP URI Web extensions WebAssembly WebDriver See all… Topics Media Performance Privacy Security Progressive web apps Learn Learn web development Frontend developer course Getting started Common questions Curriculum Learn HTML Introduction to HTML Getting started with HTML Learn CSS What is CSS Getting started with CSS Learn JavaScript How to use data attributes Add JavaScript to your web page Tools Discover our tools Playground HTTP Observatory Border-image generator Border-radius generator Box-shadow generator Color format converter Color mixer Shape generator About Get to know MDN better About MDN Advertise with us Community MDN on GitHub Blog Toggle sidebar Web JavaScript Reference Standard built-in objects RegExp Theme OS default Light Dark English (US) Remember language Learn more Deutsch English (US) Español Français 日本語 한국어 Português (do Brasil) Русский 中文 (简体) RegExp Baseline Widely available * This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩. * Some parts of this feature may have varying levels of support. Learn more See full compatibility Report feedback The RegExp object is used for matching text with a pattern. For an introduction to regular expressions, read the Regular expressions chapter in the JavaScript guide. For detailed information of regular expression syntax, read the regular expression reference . In this article Description Constructor Static properties Static methods Instance properties Instance methods Examples Specifications Browser compatibility See also Description Literal notation and constructor There are two ways to create a RegExp object: a literal notation and a constructor . The literal notation takes a pattern between two slashes, followed by optional flags , after the second slash. The constructor function takes either a string or a RegExp object as its first parameter and a string of optional flags as its second parameter. The following three expressions create the same regular expression object: js const re = /ab+c/i; // literal notation // OR const re = new RegExp("ab+c", "i"); // constructor with string pattern as first argument // OR const re = new RegExp(/ab+c/, "i"); // constructor with regular expression literal as first argument Before regular expressions can be used, they have to be compiled. This process allows them to perform matches more efficiently. More about the process can be found in dotnet docs . The literal notation results in compilation of the regular expression when the expression is evaluated. On the other hand, the constructor of the RegExp object, new RegExp('ab+c') , results in runtime compilation of the regular expression. Use a string as the first argument to the RegExp() constructor when you want to build the regular expression from dynamic input . Flags in constructor The expression new RegExp(/ab+c/, flags) will create a new RegExp using the source of the first parameter and the flags provided by the second. When using the constructor function, the normal string escape rules (preceding special characters with \ when included in a string) are necessary. For example, the following are equivalent: js const re = /\w+/; // OR const re = new RegExp("\\w+"); Special handling for regexes Note: Whether something is a "regex" can be duck-typed . It doesn't have to be a RegExp ! Some built-in methods would treat regexes specially. They decide whether x is a regex through multiple steps : x must be an object (not a primitive). If x[Symbol.match] is not undefined , check if it's truthy . Otherwise, if x[Symbol.match] is undefined , check if x had been created with the RegExp constructor. (This step should rarely happen, since if x is a RegExp object that have not been tampered with, it should have a Symbol.match property.) Note that in most cases, it would go through the Symbol.match check, which means: An actual RegExp object whose Symbol.match property's value is falsy but not undefined (even with everything else intact, like exec and [Symbol.replace]() ) can be used as if it's not a regex. A non- RegExp object with a Symbol.match property will be treated as if it's a regex. This choice was made because [Symbol.match]() is the most indicative property that something is intended to be used for matching. ( exec could also be used, but because it's not a symbol property, there would be too many false positives.) The places that treat regexes specially include: String.prototype.endsWith() , startsWith() , and includes() throw a TypeError if the first argument is a regex. String.prototype.matchAll() and replaceAll() check whether the global flag is set if the first argument is a regex before invoking its [Symbol.matchAll]() or [Symbol.replace]() method. The RegExp() constructor directly returns the pattern argument only if pattern is a regex (among a few other conditions). If pattern is a regex, it would also interrogate pattern 's source and flags properties instead of coercing pattern to a string. For example, String.prototype.endsWith() would coerce all inputs to strings, but it would throw if the argument is a regex, because it's only designed to match strings, and using a regex is likely a developer mistake. js "foobar".endsWith({ toString: () => "bar" }); // true "foobar".endsWith(/bar/); // TypeError: First argument to String.prototype.endsWith must not be a regular expression You can get around the check by setting [Symbol.match] to a falsy value that's not undefined . This would mean that the regex cannot be used for String.prototype.match() (since without [Symbol.match] , match() would construct a new RegExp object with the two enclosing slashes added by re.toString() ), but it can be used for virtually everything else. js const re = /bar/g; re[Symbol.match] = false; "/bar/g".endsWith(re); // true re.exec("bar"); // [ 'bar', index: 0, input: 'bar', groups: undefined ] "bar & bar".replace(re, "foo"); // 'foo & foo' Perl-like RegExp properties Note that several of the RegExp properties have both long and short (Perl-like) names. Both names always refer to the same value. (Perl is the programming language from which JavaScript modeled its regular expressions.) See also deprecated RegExp properties . Constructor RegExp() Creates a new RegExp object. Static properties RegExp.$1 , …, RegExp.$9 Deprecated Static read-only properties that contain parenthesized substring matches. RegExp.input ( $_ ) Deprecated A static property that contains the last string against which a regular expression was successfully matched. RegExp.lastMatch ( $& ) Deprecated A static read-only property that contains the last matched substring. RegExp.lastParen ( $+ ) Deprecated A static read-only property that contains the last parenthesized substring match. RegExp.leftContext ( $` ) Deprecated A static read-only property that contains the substring preceding the most recent match. RegExp.rightContext ( $' ) Deprecated A static read-only property that contains the substring following the most recent match. RegExp[Symbol.species] The constructor function that is used to create derived objects. Static methods RegExp.escape() Escapes any potential regex syntax characters in a string, and returns a new string that can be safely used as a literal pattern for the RegExp() constructor. Instance properties These properties are defined on RegExp.prototype and shared by all RegExp instances. RegExp.prototype.constructor The constructor function that created the instance object. For RegExp instances, the initial value is the RegExp constructor. RegExp.prototype.dotAll Whether . matches newlines or not. RegExp.prototype.flags A string that contains the flags of the RegExp object. RegExp.prototype.global Whether to test the regular expression against all possible matches in a string, or only against the first. RegExp.prototype.hasIndices Whether the regular expression result exposes the start and end indices of captured substrings. RegExp.prototype.ignoreCase Whether to ignore case while attempting a match in a string. RegExp.prototype.multiline Whether or not to search in strings across multiple lines. RegExp.prototype.source The text of the pattern. RegExp.prototype.sticky Whether or not the search is sticky. RegExp.prototype.unicode Whether or not Unicode features are enabled. RegExp.prototype.unicodeSets Whether or not the v flag, an upgrade to the u mode, is enabled. These properties are own properties of each RegExp instance. lastIndex The index at which to start the next match. Instance methods RegExp.prototype.compile() Deprecated (Re-)compiles a regular expression during execution of a script. RegExp.prototype.exec() Executes a search for a match in its string parameter. RegExp.prototype.test() Tests for a match in its string parameter. RegExp.prototype.toString() Returns a string representing the specified object. Overrides the Object.prototype.toString() method. RegExp.prototype[Symbol.match]() Performs match to given string and returns match result. RegExp.prototype[Symbol.matchAll]() Returns all matches of the regular expression against a string. RegExp.prototype[Symbol.replace]() Replaces matches in given string with new substring. RegExp.prototype[Symbol.search]() Searches the match in given string and returns the index the pattern found in the string. RegExp.prototype[Symbol.split]() Splits given string into an array by separating the string into substrings. Examples Using a regular expression to change data format The following script uses the String.prototype.replace() method to match a name in the format first last and output it in the format last, first . In the replacement text, the script uses $1 and $2 to indicate the results of the corresponding matching parentheses in the regular expression pattern. js const re = /(\w+)\s(\w+)/; const str = "Maria Cruz"; const newStr = str.replace(re, "$2, $1"); console.log(newStr); This displays "Cruz, Maria" . Using regular expression to split lines with different line endings/ends of line/line breaks The default line ending varies depending on the platform (Unix, Windows, etc.). The line splitting provided in this example works on all platforms. js const text = "Some text\nAnd some more\r\nAnd yet\nThis is the end"; const lines = text.split(/\r?\n/); console.log(lines); // [ 'Some text', 'And some more', 'And yet', 'This is the end' ] Note that the order of the patterns in the regular expression matters. Using regular expression on multiple lines By default, the . character does not match newlines. To make it match newlines, use the s flag ( dotAll mode). js const s = "Please yes\nmake my day!"; s.match(/yes.*day/); // Returns null s.match(/yes.*day/s); // Returns ["yes\nmake my day"] Using a regular expression with the sticky flag The sticky flag indicates that the regular expression performs sticky matching in the target string by attempting to match starting at RegExp.prototype.lastIndex . js const str = "#foo#"; const regex = /foo/y; regex.lastIndex = 1; regex.test(str); // true regex.lastIndex = 5; regex.test(str); // false (lastIndex is taken into account with sticky flag) regex.lastIndex; // 0 (reset after match failure) The difference between the sticky flag and the global flag With the sticky flag y , the next match has to happen at the lastIndex position, while with the global flag g , the match can happen at the lastIndex position or later: js const re = /\d/y; let r; while ((r = re.exec("123 456"))) { console.log(r, "AND re.lastIndex", re.lastIndex); } // [ '1', index: 0, input: '123 456', groups: undefined ] AND re.lastIndex 1 // [ '2', index: 1, input: '123 456', groups: undefined ] AND re.lastIndex 2 // [ '3', index: 2, input: '123 456', groups: undefined ] AND re.lastIndex 3 // … and no more match. With the global flag g , all 6 digits would be matched, not just 3. Regular expression and Unicode characters \w and \W only matches ASCII based characters; for example, a to z , A to Z , 0 to 9 , and _ . To match characters from other languages such as Cyrillic or Hebrew, use \uHHHH , where HHHH is the character's Unicode value in hexadecimal. This example demonstrates how one can separate out Unicode characters from a word. js const text = "Образец text на русском языке"; const regex = /[\u0400-\u04ff]+/g; const match = regex.exec(text); console.log(match[0]); // 'Образец' console.log(regex.lastIndex); // 7 const match2 = regex.exec(text); console.log(match2[0]); // 'на' (did not log 'text') console.log(regex.lastIndex); // 15 // and so on The Unicode property escapes feature provides a simpler way to target particular Unicode ranges, by allowing for statements like \p{scx=Cyrl} (to match any Cyrillic letter), or \p{L}/u (to match a letter from any language). Extracting subdomain name from URL js const url = "http://xxx.domain.com"; console.log(/^https?:\/\/(.+?)\./.exec(url)[1]); // 'xxx' Note: Instead of using regular expressions for parsing URLs, it is usually better to use the browsers built-in URL parser by using the URL API . Building a regular expression from dynamic inputs js const breakfasts = ["bacon", "eggs", "oatmeal", "toast", "cereal"]; const order = "Let me get some bacon and eggs, please"; order.match(new RegExp(`\\b(${breakfasts.join("|")})\\b`, "g")); // Returns ['bacon', 'eggs'] Specifications Specification ECMAScript® 2026 Language Specification # sec-regexp-regular-expression-objects Browser compatibility Loading… Firefox-specific notes Starting with Firefox 34, in the case of a capturing group with quantifiers preventing its exercise, the matched text for a capturing group is now undefined instead of an empty string: js // Firefox 33 or older "x".replace(/x(.)?/g, (m, group) => { console.log(`group: ${JSON.stringify(group)}`); }); // group: "" // Firefox 34 or newer "x".replace(/x(.)?/g, (m, group) => { console.log(`group: ${group}`); }); // group: undefined Note that due to web compatibility, RegExp.$N will still return an empty string instead of undefined ( bug 1053944 ). See also Polyfill of many modern RegExp features ( dotAll , sticky flags, named capture groups, etc.) in core-js Regular expressions guide Regular expressions String.prototype.match() String.prototype.replace() String.prototype.split() Help improve MDN Was this page helpful to you? Yes No Learn how to contribute This page was last modified on ⁨Jul 10, 2025⁩ by MDN contributors . View this page on GitHub • Report a problem with this content Filter sidebar Standard built-in objects RegExp Constructor RegExp() Static methods escape() Static properties $1, …, $9 Deprecated input ($_) Deprecated lastMatch ($&) Deprecated lastParen ($+) Deprecated leftContext ($`) Deprecated rightContext ($') Deprecated [Symbol .species] Instance methods compile() Deprecated exec() test() toString() [Symbol .match]() [Symbol .matchAll]() [Symbol .replace]() [Symbol .search]() [Symbol .split]() Instance properties lastIndex dotAll flags global hasIndices ignoreCase multiline source sticky unicode unicodeSets Inheritance Object/Function Static methods apply() bind() call() toString() [Symbol .hasInstance]() Static properties displayName Non-standard length name prototype arguments Non-standard Deprecated caller Non-standard Deprecated Instance methods __defineGetter__() Deprecated __defineSetter__() Deprecated __lookupGetter__() Deprecated __lookupSetter__() Deprecated hasOwnProperty() isPrototypeOf() propertyIsEnumerable() toLocaleString() toString() valueOf() Instance properties __proto__ Deprecated constructor Your blueprint for a better internet. MDN About Blog Mozilla careers Advertise with us MDN Plus Product help Contribute MDN Community Community resources Writing guidelines MDN Discord MDN on GitHub Developers Web technologies Learn web development Guides Tutorials Glossary Hacks blog Website Privacy Notice Telemetry Settings Legal Community Participation Guidelines Visit Mozilla Corporation’s not-for-profit parent, the Mozilla Foundation . Portions of this content are ©1998–⁨2025⁩ by individual mozilla.org contributors. Content available under a Creative Commons license .