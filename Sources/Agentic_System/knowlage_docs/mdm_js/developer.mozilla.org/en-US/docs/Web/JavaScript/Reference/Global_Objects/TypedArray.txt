TypedArray - JavaScript | MDN Skip to main content Skip to search MDN HTML HTML: Markup language HTML reference Elements Global attributes Attributes See all… HTML guides Responsive images HTML cheatsheet Date & time formats See all… Markup languages SVG MathML XML CSS CSS: Styling language CSS reference Properties Selectors At-rules Values & units See all… CSS guides Box model Animations Flexbox Colors See all… Layout cookbook Column layouts Centering an element Card component See all… JavaScript JS JavaScript: Scripting language JS reference Standard built-in objects Expressions & operators Statements & declarations Functions See all… JS guides Control flow & error handing Loops and iteration Working with objects Using classes See all… Web APIs Web APIs: Programming interfaces Web API reference File system API Fetch API Geolocation API HTML DOM API Push API Service worker API See all… Web API guides Using the Web animation API Using the Fetch API Working with the History API Using the Web speech API Using web workers All All web technology Technologies Accessibility HTTP URI Web extensions WebAssembly WebDriver See all… Topics Media Performance Privacy Security Progressive web apps Learn Learn web development Frontend developer course Getting started Common questions Curriculum Learn HTML Introduction to HTML Getting started with HTML Learn CSS What is CSS Getting started with CSS Learn JavaScript How to use data attributes Add JavaScript to your web page Tools Discover our tools Playground HTTP Observatory Border-image generator Border-radius generator Box-shadow generator Color format converter Color mixer Shape generator About Get to know MDN better About MDN Advertise with us Community MDN on GitHub Blog Toggle sidebar Web JavaScript Reference Standard built-in objects TypedArray Theme OS default Light Dark English (US) Remember language Learn more Deutsch English (US) Español Français 日本語 한국어 Русский 中文 (简体) TypedArray Baseline Widely available * This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩. * Some parts of this feature may have varying levels of support. Learn more See full compatibility Report feedback A TypedArray object describes an array-like view of an underlying binary data buffer . There is no global property named TypedArray , nor is there a directly visible TypedArray constructor. Instead, there are a number of different global properties, whose values are typed array constructors for specific element types, listed below. On the following pages you will find common properties and methods that can be used with any typed array containing elements of any type. In this article Description Constructor Static properties Static methods Instance properties Instance methods Examples Specifications Browser compatibility See also Description The TypedArray constructor (often referred to as %TypedArray% to indicate its "intrinsicness", since it does not correspond to any global exposed to a JavaScript program) serves as the common superclass of all TypedArray subclasses. Think about %TypedArray% as an "abstract class" providing a common interface of utility methods for all typed array subclasses. This constructor is not directly exposed: there is no global TypedArray property. It is only accessible through Object.getPrototypeOf(Int8Array) and similar. When creating an instance of a TypedArray subclass (e.g., Int8Array ), an array buffer is created internally in memory or, if an ArrayBuffer object is given as constructor argument, that ArrayBuffer is used instead. The buffer address is saved as an internal property of the instance and all the methods of %TypedArray%.prototype will set and get values based on that array buffer address. TypedArray objects Type Value Range Size in bytes Web IDL type Int8Array -128 to 127 1 byte Uint8Array 0 to 255 1 octet Uint8ClampedArray 0 to 255 1 octet Int16Array -32768 to 32767 2 short Uint16Array 0 to 65535 2 unsigned short Int32Array -2147483648 to 2147483647 4 long Uint32Array 0 to 4294967295 4 unsigned long Float16Array -65504 to 65504 2 N/A Float32Array -3.4e38 to 3.4e38 4 unrestricted float Float64Array -1.8e308 to 1.8e308 8 unrestricted double BigInt64Array -2 63 to 2 63 - 1 8 bigint BigUint64Array 0 to 2 64 - 1 8 bigint Value encoding and normalization All typed arrays operate on ArrayBuffer s, where you can observe the exact byte representation of each element, so how the numbers are encoded in binary format is significant. Unsigned integer arrays ( Uint8Array , Uint16Array , Uint32Array , and BigUint64Array ) store the number directly in binary. Signed integer arrays ( Int8Array , Int16Array , Int32Array , and BigInt64Array ) store the number using two's complement . Floating-point arrays ( Float16Array , Float32Array , and Float64Array ) store the number using IEEE 754 floating-point format. The Number reference has more information about the exact format. JavaScript numbers use double precision floating point format by default, which is the same as Float64Array . Float32Array uses 23 (instead of 52) bits for the mantissa and 8 (instead of 11) bits for the exponent. Float16Array uses 10 bits for the mantissa and 5 bits for the exponent. Note that the spec requires all NaN values to use the same bit encoding, but the exact bit pattern is implementation-dependent. Uint8ClampedArray is a special case. It stores the number in binary like Uint8Array does, but when you store a number outside the range, it clamps the number to the range 0 to 255 by mathematical value, instead of truncating the most significant bits. All typed arrays except Int8Array , Uint8Array , and Uint8ClampedArray store each element using multiple bytes. These bytes can either be ordered from most significant to least significant (big-endian) or from least significant to most significant (little-endian). See Endianness for more explanation. Typed arrays always use the platform's native byte order. If you want to specify the endianness when writing and reading from buffers, you should use a DataView instead. When writing to these typed arrays, values that are outside the representable range are normalized. All integer arrays (except Uint8ClampedArray ) use fixed-width number conversion , which first truncates the decimal part of the number and then takes the lowest bits. Uint8ClampedArray first clamps the number to the range 0 to 255 (values greater than 255 become 255 and values less than 0 become 0). It then rounds (instead of flooring) the result to the nearest integer, with half-to-even; meaning if the number is exactly between two integers, it rounds to the nearest even integer. For example, 0.5 becomes 0 , 1.5 becomes 2 , and 2.5 becomes 2 . Float16Array and Float32Array perform a "round to even" to convert 64-bit floating point numbers to 32-bit and 16-bit. This is the same algorithm as provided by Math.fround() and Math.f16round() . Behavior when viewing a resizable buffer When a TypedArray is created as a view of a resizable buffer , resizing the underlying buffer will have different effects on the size of the TypedArray depending on whether the TypedArray is constructed as length-tracking. If a typed array is created without a specific size by omitting the third parameter or passing undefined , the typed array will become length-tracking , and will automatically resize to fit the underlying buffer as the latter is resized: js const buffer = new ArrayBuffer(8, { maxByteLength: 16 }); const float32 = new Float32Array(buffer); console.log(float32.byteLength); // 8 console.log(float32.length); // 2 buffer.resize(12); console.log(float32.byteLength); // 12 console.log(float32.length); // 3 If a typed array is created with a specific size using the third length parameter, it won't resize to contain the buffer as the latter is grown: js const buffer = new ArrayBuffer(8, { maxByteLength: 16 }); const float32 = new Float32Array(buffer, 0, 2); console.log(float32.byteLength); // 8 console.log(float32.length); // 2 console.log(float32[0]); // 0, the initial value buffer.resize(12); console.log(float32.byteLength); // 8 console.log(float32.length); // 2 console.log(float32[0]); // 0, the initial value When a buffer is shrunk, the viewing typed array may become out of bounds, in which case the typed array's observed size will decrease to 0. This is the only case where a non-length-tracking typed array's length may change. js const buffer = new ArrayBuffer(8, { maxByteLength: 16 }); const float32 = new Float32Array(buffer, 0, 2); buffer.resize(7); console.log(float32.byteLength); // 0 console.log(float32.length); // 0 console.log(float32[0]); // undefined If you then grow the buffer again to bring the typed array back in bounds, the typed array's size will be restored to its original value. js buffer.resize(8); console.log(float32.byteLength); // 8 console.log(float32.length); // 2 console.log(float32[0]); // 0 - back in bounds again! The same can happen for length-tracking typed arrays as well, if the buffer is shrunk beyond the byteOffset . js const buffer = new ArrayBuffer(8, { maxByteLength: 16 }); const float32 = new Float32Array(buffer, 4); // float32 is length-tracking, but it only extends from the 4th byte // to the end of the buffer, so if the buffer is resized to be shorter // than 4 bytes, the typed array will become out of bounds buffer.resize(3); console.log(float32.byteLength); // 0 Constructor This object cannot be instantiated directly — attempting to construct it with new throws a TypeError . js new (Object.getPrototypeOf(Int8Array))(); // TypeError: Abstract class TypedArray not directly constructable Instead, you create an instance of a typed array of a particular type, such as an Int8Array or a BigInt64Array . These objects all have a common syntax for their constructors: js new TypedArray() new TypedArray(length) new TypedArray(typedArray) new TypedArray(object) new TypedArray(buffer) new TypedArray(buffer, byteOffset) new TypedArray(buffer, byteOffset, length) Where TypedArray is a constructor for one of the concrete types. Note: All TypedArray subclasses' constructors can only be constructed with new . Attempting to call one without new throws a TypeError . Parameters typedArray When called with an instance of a TypedArray subclass, the typedArray gets copied into a new typed array. For a non- bigint TypedArray constructor, the typedArray parameter can only be of one of the non- bigint types (such as Int32Array ). Similarly, for a bigint TypedArray constructor ( BigInt64Array or BigUint64Array ), the typedArray parameter can only be of one of the bigint types. Each value in typedArray is converted to the corresponding type of the constructor before being copied into the new array. The length of the new typed array will be same as the length of the typedArray argument. object When called with an object that's not a TypedArray instance, a new typed array is created in the same way as the TypedArray.from() method. length Optional When called with a non-object, the parameter will be treated as a number specifying the length of the typed array. An internal array buffer is created in memory, of size length multiplied by BYTES_PER_ELEMENT bytes, filled with zeros. Omitting all parameters is equivalent to using 0 as length . buffer , byteOffset Optional , length Optional When called with an ArrayBuffer or SharedArrayBuffer instance, and optionally a byteOffset and a length argument, a new typed array view is created that views the specified buffer. The byteOffset (in bytes) and length (in number of elements, each occupying BYTES_PER_ELEMENT bytes) parameters specify the memory range that will be exposed by the typed array view. If both are omitted, all of buffer is viewed; if only length is omitted, the remainder of buffer starting from byteOffset is viewed. If length is omitted, the typed array becomes length-tracking . Exceptions All TypeArray subclass constructors operate in the same way. They would all throw the following exceptions: TypeError Thrown in one of the following cases: A typedArray is passed but it is a bigint type while the current constructor is not, or vice versa. A typedArray is passed but the buffer it's viewing is detached, or a detached buffer is directly passed. RangeError Thrown in one of the following cases: The new typed array's length is too large. The length of buffer (if the length parameter is not specified) or byteOffset is not an integral multiple of the new typed array's element size. byteOffset is not a valid array index (an integer between 0 and 2 53 - 1). When creating a view from a buffer, the bounds are outside the buffer. In other words, byteOffset + length * TypedArray.BYTES_PER_ELEMENT > buffer.byteLength . Static properties These properties are defined on the TypedArray constructor object and are thus shared by all TypedArray subclass constructors. TypedArray[Symbol.species] The constructor function used to create derived objects. All TypedArray subclasses also have the following static properties: TypedArray.BYTES_PER_ELEMENT Returns a number value of the element size for the different TypedArray objects. Static methods These methods are defined on the TypedArray constructor object and are thus shared by all TypedArray subclass constructors. TypedArray.from() Creates a new TypedArray from an array-like or iterable object. See also Array.from() . TypedArray.of() Creates a new TypedArray with a variable number of arguments. See also Array.of() . Instance properties These properties are defined on TypedArray.prototype and shared by all TypedArray subclass instances. TypedArray.prototype.buffer Returns the ArrayBuffer referenced by the typed array. TypedArray.prototype.byteLength Returns the length (in bytes) of the typed array. TypedArray.prototype.byteOffset Returns the offset (in bytes) of the typed array from the start of its ArrayBuffer . TypedArray.prototype.constructor The constructor function that created the instance object. TypedArray.prototype.constructor is the hidden TypedArray constructor function, but each typed array subclass also defines its own constructor property. TypedArray.prototype.length Returns the number of elements held in the typed array. TypedArray.prototype[Symbol.toStringTag] The initial value of the TypedArray.prototype[Symbol.toStringTag] property is a getter that returns the same string as the typed array constructor's name. It returns undefined if the this value is not one of the typed array subclasses. This property is used in Object.prototype.toString() . However, because TypedArray also has its own toString() method, this property is not used unless you call Object.prototype.toString.call() with a typed array as thisArg . All TypedArray subclasses also have the following instance properties: TypedArray.prototype.BYTES_PER_ELEMENT Returns a number value of the element size for the different TypedArray objects. Instance methods These methods are defined on the TypedArray prototype object and are thus shared by all TypedArray subclass instances. TypedArray.prototype.at() Takes an integer value and returns the item at that index. This method allows for negative integers, which count back from the last item. TypedArray.prototype.copyWithin() Copies a sequence of array elements within the array. See also Array.prototype.copyWithin() . TypedArray.prototype.entries() Returns a new array iterator object that contains the key/value pairs for each index in the array. See also Array.prototype.entries() . TypedArray.prototype.every() Returns false if it finds one element in the array that does not satisfy the provided testing function. Otherwise, it returns true . See also Array.prototype.every() . TypedArray.prototype.fill() Fills all the elements of an array from a start index to an end index with a static value. See also Array.prototype.fill() . TypedArray.prototype.filter() Creates a new array with all of the elements of this array for which the provided filtering function returns true . See also Array.prototype.filter() . TypedArray.prototype.find() Returns the first element in the array that satisfies a provided testing function, or undefined if no appropriate element is found. See also Array.prototype.find() . TypedArray.prototype.findIndex() Returns the first index value in the array that has an element that satisfies a provided testing function, or -1 if no appropriate element was found. See also Array.prototype.findIndex() . TypedArray.prototype.findLast() Returns the value of the last element in the array that satisfies a provided testing function, or undefined if no appropriate element is found. See also Array.prototype.findLast() . TypedArray.prototype.findLastIndex() Returns the index of the last element in the array that satisfies a provided testing function, or -1 if no appropriate element was found. See also Array.prototype.findLastIndex() . TypedArray.prototype.forEach() Calls a function for each element in the array. See also Array.prototype.forEach() . TypedArray.prototype.includes() Determines whether a typed array includes a certain element, returning true or false as appropriate. See also Array.prototype.includes() . TypedArray.prototype.indexOf() Returns the first (least) index of an element within the array equal to the specified value, or -1 if none is found. See also Array.prototype.indexOf() . TypedArray.prototype.join() Joins all elements of an array into a string. See also Array.prototype.join() . TypedArray.prototype.keys() Returns a new array iterator that contains the keys for each index in the array. See also Array.prototype.keys() . TypedArray.prototype.lastIndexOf() Returns the last (greatest) index of an element within the array equal to the specified value, or -1 if none is found. See also Array.prototype.lastIndexOf() . TypedArray.prototype.map() Creates a new array with the results of calling a provided function on every element in this array. See also Array.prototype.map() . TypedArray.prototype.reduce() Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value. See also Array.prototype.reduce() . TypedArray.prototype.reduceRight() Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value. See also Array.prototype.reduceRight() . TypedArray.prototype.reverse() Reverses the order of the elements of an array — the first becomes the last, and the last becomes the first. See also Array.prototype.reverse() . TypedArray.prototype.set() Stores multiple values in the typed array, reading input values from a specified array. TypedArray.prototype.slice() Extracts a section of an array and returns a new array. See also Array.prototype.slice() . TypedArray.prototype.some() Returns true if it finds one element in the array that satisfies the provided testing function. Otherwise, it returns false . See also Array.prototype.some() . TypedArray.prototype.sort() Sorts the elements of an array in place and returns the array. See also Array.prototype.sort() . TypedArray.prototype.subarray() Returns a new TypedArray from the given start and end element index. TypedArray.prototype.toLocaleString() Returns a localized string representing the array and its elements. See also Array.prototype.toLocaleString() . TypedArray.prototype.toReversed() Returns a new array with the elements in reversed order, without modifying the original array. TypedArray.prototype.toSorted() Returns a new array with the elements sorted in ascending order, without modifying the original array. TypedArray.prototype.toString() Returns a string representing the array and its elements. See also Array.prototype.toString() . TypedArray.prototype.values() Returns a new array iterator object that contains the values for each index in the array. See also Array.prototype.values() . TypedArray.prototype.with() Returns a new array with the element at the given index replaced with the given value, without modifying the original array. TypedArray.prototype[Symbol.iterator]() Returns a new array iterator object that contains the values for each index in the array. Examples Property access You can reference elements in the array using standard array index syntax (that is, using bracket notation). However, getting or setting indexed properties on typed arrays will not search in the prototype chain for this property, even when the indices are out of bound. Indexed properties will consult the ArrayBuffer and will never look at object properties. You can still use named properties, just like with all objects. js // Setting and getting using standard array syntax const int16 = new Int16Array(2); int16[0] = 42; console.log(int16[0]); // 42 // Indexed properties on prototypes are not consulted (Fx 25) Int8Array.prototype[20] = "foo"; new Int8Array(32)[20]; // 0 // even when out of bound Int8Array.prototype[20] = "foo"; new Int8Array(8)[20]; // undefined // or with negative integers Int8Array.prototype[-1] = "foo"; new Int8Array(8)[-1]; // undefined // Named properties are allowed, though (Fx 30) Int8Array.prototype.foo = "bar"; new Int8Array(32).foo; // "bar" Cannot be frozen TypedArray s that aren't empty cannot be frozen, as their underlying ArrayBuffer could be mutated through another TypedArray view of the buffer. This would mean that the object would never genuinely be frozen. js const i8 = Int8Array.of(1, 2, 3); Object.freeze(i8); // TypeError: Cannot freeze array buffer views with elements ByteOffset must be aligned When constructing a TypedArray as a view onto an ArrayBuffer , the byteOffset argument must be aligned to its element size; in other words, the offset must be a multiple of BYTES_PER_ELEMENT . js const i32 = new Int32Array(new ArrayBuffer(4), 1); // RangeError: start offset of Int32Array should be a multiple of 4 js const i32 = new Int32Array(new ArrayBuffer(4), 0); ByteLength must be aligned Like the byteOffset parameter, the byteLength property of an ArrayBuffer passed to a TypedArray 's constructor must be a multiple of the constructor's BYTES_PER_ELEMENT . js const i32 = new Int32Array(new ArrayBuffer(3)); // RangeError: byte length of Int32Array should be a multiple of 4 js const i32 = new Int32Array(new ArrayBuffer(4)); Specifications Specification ECMAScript® 2026 Language Specification # sec-typedarray-objects Browser compatibility Loading… See also Polyfill of typed arrays in core-js JavaScript typed arrays guide ArrayBuffer DataView TextDecoder Help improve MDN Was this page helpful to you? Yes No Learn how to contribute This page was last modified on ⁨Sep 28, 2025⁩ by MDN contributors . View this page on GitHub • Report a problem with this content Filter sidebar Standard built-in objects TypedArray Static methods from() of() Static properties BYTES_PER_ELEMENT [Symbol .species] Instance methods at() copyWithin() entries() every() fill() filter() find() findIndex() findLast() findLastIndex() forEach() includes() indexOf() join() keys() lastIndexOf() map() reduce() reduceRight() reverse() set() slice() some() sort() subarray() toLocaleString() toReversed() toSorted() toString() values() with() [Symbol .iterator]() Instance properties buffer byteLength byteOffset length Inheritance Object/Function Static methods apply() bind() call() toString() [Symbol .hasInstance]() Static properties displayName Non-standard length name prototype arguments Non-standard Deprecated caller Non-standard Deprecated Instance methods __defineGetter__() Deprecated __defineSetter__() Deprecated __lookupGetter__() Deprecated __lookupSetter__() Deprecated hasOwnProperty() isPrototypeOf() propertyIsEnumerable() toLocaleString() toString() valueOf() Instance properties __proto__ Deprecated constructor Related pages BigInt64Array BigUint64Array Float16Array Float32Array Float64Array Int8Array Int16Array Int32Array Uint8Array Uint8ClampedArray Uint16Array Uint32Array Your blueprint for a better internet. MDN About Blog Mozilla careers Advertise with us MDN Plus Product help Contribute MDN Community Community resources Writing guidelines MDN Discord MDN on GitHub Developers Web technologies Learn web development Guides Tutorials Glossary Hacks blog Website Privacy Notice Telemetry Settings Legal Community Participation Guidelines Visit Mozilla Corporation’s not-for-profit parent, the Mozilla Foundation . Portions of this content are ©1998–⁨2025⁩ by individual mozilla.org contributors. Content available under a Creative Commons license .