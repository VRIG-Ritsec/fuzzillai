WeakRef - JavaScript | MDN Skip to main content Skip to search MDN HTML HTML: Markup language HTML reference Elements Global attributes Attributes See all… HTML guides Responsive images HTML cheatsheet Date & time formats See all… Markup languages SVG MathML XML CSS CSS: Styling language CSS reference Properties Selectors At-rules Values & units See all… CSS guides Box model Animations Flexbox Colors See all… Layout cookbook Column layouts Centering an element Card component See all… JavaScript JS JavaScript: Scripting language JS reference Standard built-in objects Expressions & operators Statements & declarations Functions See all… JS guides Control flow & error handing Loops and iteration Working with objects Using classes See all… Web APIs Web APIs: Programming interfaces Web API reference File system API Fetch API Geolocation API HTML DOM API Push API Service worker API See all… Web API guides Using the Web animation API Using the Fetch API Working with the History API Using the Web speech API Using web workers All All web technology Technologies Accessibility HTTP URI Web extensions WebAssembly WebDriver See all… Topics Media Performance Privacy Security Progressive web apps Learn Learn web development Frontend developer course Getting started Common questions Curriculum Learn HTML Introduction to HTML Getting started with HTML Learn CSS What is CSS Getting started with CSS Learn JavaScript How to use data attributes Add JavaScript to your web page Tools Discover our tools Playground HTTP Observatory Border-image generator Border-radius generator Box-shadow generator Color format converter Color mixer Shape generator About Get to know MDN better About MDN Advertise with us Community MDN on GitHub Blog Toggle sidebar Web JavaScript Reference Standard built-in objects WeakRef Theme OS default Light Dark English (US) Remember language Learn more Deutsch English (US) Français 日本語 中文 (简体) WeakRef Baseline Widely available * This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨April 2021⁩. * Some parts of this feature may have varying levels of support. Learn more See full compatibility Report feedback A WeakRef object lets you hold a weak reference to another object, without preventing that object from getting garbage-collected. In this article Description Constructor Instance properties Instance methods Examples Specifications Browser compatibility See also Description A WeakRef object contains a weak reference to an object, which is called its target or referent . A weak reference to an object is a reference that does not prevent the object from being reclaimed by the garbage collector. In contrast, a normal (or strong ) reference keeps an object in memory. When an object no longer has any strong references to it, the JavaScript engine's garbage collector may destroy the object and reclaim its memory. If that happens, you can't get the object from a weak reference anymore. Because non-registered symbols are also garbage collectable, they can also be used as the target of a WeakRef object. However, the use case of this is limited. Avoid where possible Correct use of WeakRef takes careful thought, and it's best avoided if possible. It's also important to avoid relying on any specific behaviors not guaranteed by the specification. When, how, and whether garbage collection occurs is down to the implementation of any given JavaScript engine. Any behavior you observe in one engine may be different in another engine, in another version of the same engine, or even in a slightly different situation with the same version of the same engine. Garbage collection is a hard problem that JavaScript engine implementers are constantly refining and improving their solutions to. Here are some specific points included by the authors in the proposal that introduced WeakRef : Garbage collectors are complicated. If an application or library depends on GC cleaning up a WeakRef or calling a finalizer [cleanup callback] in a timely, predictable manner, it's likely to be disappointed: the cleanup may happen much later than expected, or not at all. Sources of variability include: One object might be garbage-collected much sooner than another object, even if they become unreachable at the same time, e.g., due to generational collection. Garbage collection work can be split up over time using incremental and concurrent techniques. Various runtime heuristics can be used to balance memory usage, responsiveness. The JavaScript engine may hold references to things which look like they are unreachable (e.g., in closures, or inline caches). Different JavaScript engines may do these things differently, or the same engine may change its algorithms across versions. Complex factors may lead to objects being held alive for unexpected amounts of time, such as use with certain APIs. Notes on WeakRefs If your code has just created a WeakRef for a target object, or has gotten a target object from a WeakRef 's deref method, that target object will not be reclaimed until the end of the current JavaScript job (including any promise reaction jobs that run at the end of a script job). That is, you can only "see" an object get reclaimed between turns of the event loop. This is primarily to avoid making the behavior of any given JavaScript engine's garbage collector apparent in code — because if it were, people would write code relying on that behavior, which would break when the garbage collector's behavior changed. (Garbage collection is a hard problem; JavaScript engine implementers are constantly refining and improving how it works.) If multiple WeakRef s have the same target, they're consistent with one another. The result of calling deref on one of them will match the result of calling deref on another of them (in the same job), you won't get the target object from one of them but undefined from another. If the target of a WeakRef is also in a FinalizationRegistry , the WeakRef 's target is cleared at the same time or before any cleanup callback associated with the registry is called; if your cleanup callback calls deref on a WeakRef for the object, it will receive undefined . You cannot change the target of a WeakRef , it will always only ever be the original target object or undefined when that target has been reclaimed. A WeakRef might never return undefined from deref , even if nothing strongly holds the target, because the garbage collector may never decide to reclaim the object. Constructor WeakRef() Creates a new WeakRef object. Instance properties These properties are defined on WeakRef.prototype and shared by all WeakRef instances. WeakRef.prototype.constructor Optional The constructor function that created the instance object. For WeakRef instances, the initial value is the WeakRef constructor. Note: This property is marked as "normative optional" in the specification, which means a conforming implementation may not expose the constructor property. This prevents arbitrary code from obtaining the WeakRef constructor and being able to observe garbage collection. However, all major engines do expose it by default. WeakRef.prototype[Symbol.toStringTag] The initial value of the [Symbol.toStringTag] property is the string "WeakRef" . This property is used in Object.prototype.toString() . Instance methods WeakRef.prototype.deref() Returns the WeakRef object's target object, or undefined if the target object has been reclaimed. Examples Using a WeakRef object This example starts a counter shown in a DOM element, stopping when the element doesn't exist anymore: js class Counter { constructor(element) { // Remember a weak reference to the DOM element this.ref = new WeakRef(element); this.start(); } start() { if (this.timer) { return; } this.count = 0; const tick = () => { // Get the element from the weak reference, if it still exists const element = this.ref.deref(); if (element) { element.textContent = ++this.count; } else { // The element doesn't exist anymore console.log("The element is gone."); this.stop(); this.ref = null; } }; tick(); this.timer = setInterval(tick, 1000); } stop() { if (this.timer) { clearInterval(this.timer); this.timer = 0; } } } const counter = new Counter(document.getElementById("counter")); setTimeout(() => { document.getElementById("counter").remove(); }, 5000); Specifications Specification ECMAScript® 2026 Language Specification # sec-weak-ref-objects Browser compatibility Loading… See also FinalizationRegistry WeakSet WeakMap Help improve MDN Was this page helpful to you? Yes No Learn how to contribute This page was last modified on ⁨Jul 10, 2025⁩ by MDN contributors . View this page on GitHub • Report a problem with this content Filter sidebar Standard built-in objects WeakRef Constructor WeakRef() Instance methods deref() Inheritance Object/Function Static methods apply() bind() call() toString() [Symbol .hasInstance]() Static properties displayName Non-standard length name prototype arguments Non-standard Deprecated caller Non-standard Deprecated Instance methods __defineGetter__() Deprecated __defineSetter__() Deprecated __lookupGetter__() Deprecated __lookupSetter__() Deprecated hasOwnProperty() isPrototypeOf() propertyIsEnumerable() toLocaleString() toString() valueOf() Instance properties __proto__ Deprecated constructor Your blueprint for a better internet. MDN About Blog Mozilla careers Advertise with us MDN Plus Product help Contribute MDN Community Community resources Writing guidelines MDN Discord MDN on GitHub Developers Web technologies Learn web development Guides Tutorials Glossary Hacks blog Website Privacy Notice Telemetry Settings Legal Community Participation Guidelines Visit Mozilla Corporation’s not-for-profit parent, the Mozilla Foundation . Portions of this content are ©1998–⁨2025⁩ by individual mozilla.org contributors. Content available under a Creative Commons license .