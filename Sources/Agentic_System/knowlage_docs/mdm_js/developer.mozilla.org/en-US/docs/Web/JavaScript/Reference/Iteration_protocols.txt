Iteration protocols - JavaScript | MDN Skip to main content Skip to search MDN HTML HTML: Markup language HTML reference Elements Global attributes Attributes See all… HTML guides Responsive images HTML cheatsheet Date & time formats See all… Markup languages SVG MathML XML CSS CSS: Styling language CSS reference Properties Selectors At-rules Values & units See all… CSS guides Box model Animations Flexbox Colors See all… Layout cookbook Column layouts Centering an element Card component See all… JavaScript JS JavaScript: Scripting language JS reference Standard built-in objects Expressions & operators Statements & declarations Functions See all… JS guides Control flow & error handing Loops and iteration Working with objects Using classes See all… Web APIs Web APIs: Programming interfaces Web API reference File system API Fetch API Geolocation API HTML DOM API Push API Service worker API See all… Web API guides Using the Web animation API Using the Fetch API Working with the History API Using the Web speech API Using web workers All All web technology Technologies Accessibility HTTP URI Web extensions WebAssembly WebDriver See all… Topics Media Performance Privacy Security Progressive web apps Learn Learn web development Frontend developer course Getting started Common questions Curriculum Learn HTML Introduction to HTML Getting started with HTML Learn CSS What is CSS Getting started with CSS Learn JavaScript How to use data attributes Add JavaScript to your web page Tools Discover our tools Playground HTTP Observatory Border-image generator Border-radius generator Box-shadow generator Color format converter Color mixer Shape generator About Get to know MDN better About MDN Advertise with us Community MDN on GitHub Blog Toggle sidebar Web JavaScript Reference Iteration protocols Theme OS default Light Dark English (US) Remember language Learn more Deutsch English (US) Español Français 日本語 한국어 Português (do Brasil) Русский 中文 (简体) 正體中文 (繁體) Iteration protocols Iteration protocols aren't new built-ins or syntax, but protocols . These protocols can be implemented by any object by following some conventions. There are two protocols: The iterable protocol and the iterator protocol . In this article The iterable protocol The iterator protocol The async iterator and async iterable protocols Interactions between the language and iteration protocols Error handling Examples Specifications See also The iterable protocol The iterable protocol allows JavaScript objects to define or customize their iteration behavior, such as what values are looped over in a for...of construct. Some built-in types are built-in iterables with a default iteration behavior, such as Array or Map , while other types (such as Object ) are not. In order to be iterable , an object must implement the [Symbol.iterator]() method, meaning that the object (or one of the objects up its prototype chain ) must have a property with a [Symbol.iterator] key which is available via constant Symbol.iterator : [Symbol.iterator]() A zero-argument function that returns an object, conforming to the iterator protocol . Whenever an object needs to be iterated (such as at the beginning of a for...of loop), its [Symbol.iterator]() method is called with no arguments, and the returned iterator is used to obtain the values to be iterated. Note that when this zero-argument function is called, it is invoked as a method on the iterable object. Therefore inside of the function, the this keyword can be used to access the properties of the iterable object, to decide what to provide during the iteration. This function can be an ordinary function, or it can be a generator function, so that when invoked, an iterator object is returned. Inside of this generator function, each entry can be provided by using yield . The iterator protocol The iterator protocol defines a standard way to produce a sequence of values (either finite or infinite), and potentially a return value when all values have been generated. An object is an iterator when it implements a next() method with the following semantics: next() A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface (see below). If a non-object value gets returned (such as false or undefined ) when a built-in language feature (such as for...of ) is using the iterator, a TypeError ( "iterator.next() returned a non-object value" ) will be thrown. All iterator protocol methods ( next() , return() , and throw() ) are expected to return an object implementing the IteratorResult interface. It must have the following properties: done Optional A boolean that's false if the iterator was able to produce the next value in the sequence. (This is equivalent to not specifying the done property altogether.) Has the value true if the iterator has completed its sequence. In this case, value optionally specifies the return value of the iterator. value Optional Any JavaScript value returned by the iterator. Can be omitted when done is true . In practice, neither property is strictly required; if an object without either property is returned, it's effectively equivalent to { done: false, value: undefined } . If an iterator returns a result with done: true , any subsequent calls to next() are expected to return done: true as well, although this is not enforced on the language level. The next method can receive a value which will be made available to the method body. No built-in language feature will pass any value. The value passed to the next method of generators will become the value of the corresponding yield expression. Optionally, the iterator can also implement the return(value) and throw(exception) methods, which, when called, tells the iterator that the caller is done with iterating it and can perform any necessary cleanup (such as closing database connection). return(value) Optional A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface, typically with value equal to the value passed in and done equal to true . Calling this method tells the iterator that the caller does not intend to make any more next() calls and can perform any cleanup actions. When built-in language features call return() for cleanup, value is always undefined . throw(exception) Optional A function that accepts zero or one argument and returns an object conforming to the IteratorResult interface, typically with done equal to true . Calling this method tells the iterator that the caller detects an error condition, and exception is typically an Error instance. No built-in language feature calls throw() for cleanup purposes — it's a special feature of generators for the symmetry of return / throw . Note: It is not possible to know reflectively (i.e., without actually calling next() and validating the returned result) whether a particular object implements the iterator protocol. It is very easy to make an iterator also iterable: just implement an [Symbol.iterator]() method that returns this . js // Satisfies both the Iterator Protocol and Iterable const myIterator = { next() { // … }, [Symbol.iterator]() { return this; }, }; Such object is called an iterable iterator . Doing so allows an iterator to be consumed by the various syntaxes expecting iterables — therefore, it is seldom useful to implement the Iterator Protocol without also implementing Iterable. (In fact, almost all syntaxes and APIs expect iterables , not iterators .) The generator object is an example: js const generatorObject = (function* () { yield 1; yield 2; yield 3; })(); console.log(typeof generatorObject.next); // "function" — it has a next method (which returns the right result), so it's an iterator console.log(typeof generatorObject[Symbol.iterator]); // "function" — it has an [Symbol.iterator] method (which returns the right iterator), so it's an iterable console.log(generatorObject[Symbol.iterator]() === generatorObject); // true — its [Symbol.iterator] method returns itself (an iterator), so it's an iterable iterator All built-in iterators inherit from Iterator.prototype , which implements the [Symbol.iterator]() method as returning this , so that built-in iterators are also iterable. However, when possible, it's better for iterable[Symbol.iterator]() to return different iterators that always start from the beginning, like Set.prototype[Symbol.iterator]() does. The async iterator and async iterable protocols There are another pair of protocols used for async iteration, named async iterator and async iterable protocols. They have very similar interfaces compared to the iterable and iterator protocols, except that each return value from the calls to the iterator methods is wrapped in a promise. An object implements the async iterable protocol when it implements the following methods: [Symbol.asyncIterator]() A zero-argument function that returns an object, conforming to the async iterator protocol. An object implements the async iterator protocol when it implements the following methods: next() A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's. return(value) Optional A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's. throw(exception) Optional A function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the IteratorResult interface, and the properties have the same semantics as those of the sync iterator's. Interactions between the language and iteration protocols The language specifies APIs that either produce or consume iterables and iterators. Built-in iterables String , Array , TypedArray , Map , Set , and Segments (returned by Intl.Segmenter.prototype.segment() ) are all built-in iterables, because each of their prototype objects implements an [Symbol.iterator]() method. In addition, the arguments object and some DOM collection types such as NodeList are also iterables. There is no object in the core JavaScript language that is async iterable. Some web APIs, such as ReadableStream , have the Symbol.asyncIterator method set by default. Generator functions return generator objects , which are iterable iterators. Async generator functions return async generator objects , which are async iterable iterators. The iterators returned from built-in iterables actually all inherit from a common class Iterator , which implements the aforementioned [Symbol.iterator]() { return this; } method, making them all iterable iterators. The Iterator class also provides additional helper methods in addition to the next() method required by the iterator protocol. You can inspect an iterator's prototype chain by logging it in a graphical console. console.log([][Symbol.iterator]()); Array Iterator {} [[Prototype]]: Array Iterator ==> This is the prototype shared by all array iterators next: ƒ next() Symbol(Symbol.toStringTag): "Array Iterator" [[Prototype]]: Object ==> This is the prototype shared by all built-in iterators Symbol(Symbol.iterator): ƒ [Symbol.iterator]() [[Prototype]]: Object ==> This is Object.prototype Built-in APIs accepting iterables There are many APIs that accept iterables. Some examples include: Map() WeakMap() Set() WeakSet() Promise.all() Promise.allSettled() Promise.race() Promise.any() Array.from() Object.groupBy() Map.groupBy() js const myObj = {}; new WeakSet( (function* () { yield {}; yield myObj; yield {}; })(), ).has(myObj); // true Syntaxes expecting iterables Some statements and expressions expect iterables, for example the for...of loops, array and parameter spreading , yield* , and array destructuring : js for (const value of ["a", "b", "c"]) { console.log(value); } // "a" // "b" // "c" console.log([..."abc"]); // ["a", "b", "c"] function* gen() { yield* ["a", "b", "c"]; } console.log(gen().next()); // { value: "a", done: false } [a, b, c] = new Set(["a", "b", "c"]); console.log(a); // "a" When built-in syntaxes are iterating an iterator, and the last result's done is false (i.e., the iterator is able to produce more values) but no more values are needed, the return method will get called if present. This can happen, for example, if a break or return is encountered in a for...of loop, or if all identifiers are already bound in an array destructuring. js const obj = { [Symbol.iterator]() { let i = 0; return { next() { i++; console.log("Returning", i); if (i === 3) return { done: true, value: i }; return { done: false, value: i }; }, return() { console.log("Closing"); return { done: true }; }, }; }, }; const [a] = obj; // Returning 1 // Closing const [b, c, d] = obj; // Returning 1 // Returning 2 // Returning 3 // Already reached the end (the last call returned `done: true`), // so `return` is not called console.log([b, c, d]); // [1, 2, undefined]; the value associated with `done: true` is not reachable for (const b of obj) { break; } // Returning 1 // Closing The for await...of loop and yield* in async generator functions (but not sync generator functions ) are the only ways to interact with async iterables. Using for...of , array spreading, etc. on an async iterable that's not also a sync iterable (i.e., it has [Symbol.asyncIterator]() but no [Symbol.iterator]() ) will throw a TypeError: x is not iterable. Error handling Because iteration involves transferring control back and forth between the iterator and the consumer, error handling happens in both ways: how the consumer handles errors thrown by the iterator, and how the iterator handles errors thrown by the consumer. When you are using one of the built-in ways of iteration, the language may also throw errors because the iterable breaks certain invariants . We will describe how built-in syntaxes generate and handle errors, which can be used as a guideline for your own code if you are manually stepping the iterator. Non-well-formed iterables Errors may happen when acquiring the iterator from the iterable. The language invariant enforced here is that the iterable must produce a valid iterator: It has a callable [Symbol.iterator]() method. The [Symbol.iterator]() method returns an object. The object returned by [Symbol.iterator]() has a callable next() method. When using built-in syntax to initiate iteration on a non-well-formed iterable, a TypeError is thrown. js const nonWellFormedIterable = { [Symbol.iterator]: 1 }; [...nonWellFormedIterable]; // TypeError: nonWellFormedIterable is not iterable nonWellFormedIterable[Symbol.iterator] = () => 1; [...nonWellFormedIterable]; // TypeError: [Symbol.iterator]() returned a non-object value nonWellFormedIterable[Symbol.iterator] = () => ({}); [...nonWellFormedIterable]; // TypeError: nonWellFormedIterable[Symbol.iterator]().next is not a function For async iterables, if its [Symbol.asyncIterator]() property has value undefined or null , JavaScript falls back to using the [Symbol.iterator] property instead (and wraps the resulting iterator into an async iterator by forwarding the methods). Otherwise, the [Symbol.asyncIterator] property must conform to the above invariants too. This type of errors can be prevented by first validating the iterable before attempting to iterate it. However, it's fairly rare because usually you know the type of the object you are iterating over. If you are receiving this iterable from some other code, you should just let the error propagate to the caller so they know an invalid input was provided. Errors during iteration Most errors happen when stepping the iterator (calling next() ). The language invariant enforced here is that the next() method must return an object (for async iterators, an object after awaiting). Otherwise, a TypeError is thrown. If the invariant is broken or the next() method throws an error (for async iterators, it may also return a rejected promise), the error is propagated to the caller. For built-in syntaxes, the iteration in progress is aborted without retrying or cleanup (with the assumption that if the next() method threw the error, then it has cleaned up already). If you are manually calling next() , you may catch the error and retry calling next() , but in general you should assume the iterator is already closed. If the caller decides to exit iteration for any reason other than the errors in the previous paragraph, such as when it enters an error state in its own code (for example, while handling an invalid value produced by the iterator), it should call the return() method on the iterator, if one exists. This allows the iterator to perform any cleanup. The return() method is only called for premature exits—if next() returns done: true , the return() method is not called, with the assumption that the iterator has already cleaned up. The return() method might be invalid too! The language also enforces that the return() method must return an object and throws a TypeError otherwise. If the return() method throws an error, the error is propagated to the caller. However, if the return() method is called because the caller encountered an error in its own code, then this error overrides the error thrown by the return() method. Usually, the caller implements error handling like this: js try { for (const value of iterable) { // … } } catch (e) { // Handle the error } The catch will be able to catch errors thrown when iterable is not a valid iterable, when next() throws an error, when return() throws an error (if the for loop exits early), and when the for loop body throws an error. Most iterators are implemented with generator functions, so we will demonstrate how generator functions typically handle errors: js function* gen() { try { yield doSomething(); yield doSomethingElse(); } finally { cleanup(); } } The lack of catch here causes errors thrown by doSomething() or doSomethingElse() to propagate to the caller of gen . If these errors are caught within the generator function (which is equally advisable), the generator function can decide to continue yielding values or to exit early. However, the finally block is necessary for generators that keep open resources. The finally block is guaranteed to run, either when the last next() is called or when return() is called. Forwarding errors Some built-in syntaxes wrap an iterator into another iterator. They include the iterator produced by Iterator.from() , iterator helper methods ( map() , filter() , take() , drop() , and flatMap() ), yield* , and a hidden wrapper when you use async iteration ( for await...of , Array.fromAsync ) on sync iterators. The wrapped iterator is then responsible for forwarding errors between the inner iterator and the caller. All wrapper iterators directly forward the next() method of the inner iterator, including its return value and thrown errors. Wrapper iterators generally directly forward the return() method of the inner iterator. If the return() method doesn't exist on the inner iterator, it returns { done: true, value: undefined } instead. In the case of iterator helpers: if the iterator helper's next() method has not been called, after trying to call return() on the inner iterator, the current iterator always returns { done: true, value: undefined } . This is consistent with generator functions where execution hasn't entered the yield* expression yet. yield* is the only built-in syntax that forwards the throw() method of the inner iterator. For information on how yield* forwards the return() and throw() methods, see its own reference. Examples User-defined iterables You can make your own iterables like this: js const myIterable = { *[Symbol.iterator]() { yield 1; yield 2; yield 3; }, }; console.log([...myIterable]); // [1, 2, 3] Basic iterator Iterators are stateful by nature. If you don't define it as a generator function (as the example above shows), you would likely want to encapsulate the state in a closure. js function makeIterator(array) { let nextIndex = 0; return { next() { return nextIndex < array.length ? { value: array[nextIndex++], done: false, } : { done: true, }; }, }; } const it = makeIterator(["yo", "ya"]); console.log(it.next().value); // 'yo' console.log(it.next().value); // 'ya' console.log(it.next().done); // true Infinite iterator js function idMaker() { let index = 0; return { next() { return { value: index++, done: false, }; }, }; } const it = idMaker(); console.log(it.next().value); // 0 console.log(it.next().value); // 1 console.log(it.next().value); // 2 // … Defining an iterable with a generator js function* makeGenerator(array) { let nextIndex = 0; while (nextIndex < array.length) { yield array[nextIndex++]; } } const gen = makeGenerator(["yo", "ya"]); console.log(gen.next().value); // 'yo' console.log(gen.next().value); // 'ya' console.log(gen.next().done); // true function* idMaker() { let index = 0; while (true) { yield index++; } } const it = idMaker(); console.log(it.next().value); // 0 console.log(it.next().value); // 1 console.log(it.next().value); // 2 // … Defining an iterable with a class State encapsulation can be done with private fields as well. js class SimpleClass { #data; constructor(data) { this.#data = data; } [Symbol.iterator]() { // Use a new index for each iterator. This makes multiple // iterations over the iterable safe for non-trivial cases, // such as use of break or nested looping over the same iterable. let index = 0; return { // Note: using an arrow function allows `this` to point to the // one of `[Symbol.iterator]()` instead of `next()` next: () => { if (index >= this.#data.length) { return { done: true }; } return { value: this.#data[index++], done: false }; }, }; } } const simple = new SimpleClass([1, 2, 3, 4, 5]); for (const val of simple) { console.log(val); // 1 2 3 4 5 } Overriding built-in iterables For example, a String is a built-in iterable object: js const someString = "hi"; console.log(typeof someString[Symbol.iterator]); // "function" String 's default iterator returns the string's code points one by one: js const iterator = someString[Symbol.iterator](); console.log(`${iterator}`); // "[object String Iterator]" console.log(iterator.next()); // { value: "h", done: false } console.log(iterator.next()); // { value: "i", done: false } console.log(iterator.next()); // { value: undefined, done: true } You can redefine the iteration behavior by supplying our own [Symbol.iterator]() : js // need to construct a String object explicitly to avoid auto-boxing const someString = new String("hi"); someString[Symbol.iterator] = function () { return { // this is the iterator object, returning a single element (the string "bye") next() { return this._first ? { value: "bye", done: (this._first = false) } : { done: true }; }, _first: true, }; }; Notice how redefining [Symbol.iterator]() affects the behavior of built-in constructs that use the iteration protocol: js console.log([...someString]); // ["bye"] console.log(`${someString}`); // "hi" Concurrent modifications when iterating Almost all iterables have the same underlying semantic: they don't copy the data at the time when iteration starts. Rather, they keep a pointer and move it around. Therefore, if you add, delete, or modify elements in the collection while iterating over the collection, you may inadvertently change whether other unchanged elements in the collection are visited. This is very similar to how iterative array methods work. Consider the following case using a URLSearchParams : js const searchParams = new URLSearchParams( "deleteme1=value1&key2=value2&key3=value3", ); // Delete unwanted keys for (const [key, value] of searchParams) { console.log(key); if (key.startsWith("deleteme")) { searchParams.delete(key); } } // Output: // deleteme1 // key3 Note how it never logs key2 . This is because a URLSearchParams is underlyingly a list of key-value pairs. When deleteme1 is visited and deleted, all other entries are shifted to the left by one, so key2 occupies the position that deleteme1 used to be in, and when the pointer moves to the next key, it lands on key3 . Certain iterable implementations avoid this problem by setting "tombstone" values to avoid shifting the remaining values. Consider the similar code using a Map : js const myMap = new Map([ ["deleteme1", "value1"], ["key2", "value2"], ["key3", "value3"], ]); for (const [key, value] of myMap) { console.log(key); if (key.startsWith("deleteme")) { myMap.delete(key); } } // Output: // deleteme1 // key2 // key3 Note how it logs all keys. This is because Map doesn't shift the remaining keys when one is deleted. If you want to implement something similar, here's how it may look: js const tombstone = Symbol("tombstone"); class MyIterable { #data; constructor(data) { this.#data = data; } delete(deletedKey) { for (let i = 0; i < this.#data.length; i++) { if (this.#data[i][0] === deletedKey) { this.#data[i] = tombstone; return true; } } return false; } *[Symbol.iterator]() { for (const data of this.#data) { if (data !== tombstone) { yield data; } } } } const myIterable = new MyIterable([ ["deleteme1", "value1"], ["key2", "value2"], ["key3", "value3"], ]); for (const [key, value] of myIterable) { console.log(key); if (key.startsWith("deleteme")) { myIterable.delete(key); } } Warning: Concurrent modifications, in general, are very bug-prone and confusing. Unless you know precisely how the iterable is implemented, it's best to avoid modifying the collection while iterating over it. Specifications Specification ECMAScript® 2026 Language Specification # sec-iteration See also Iterators and generators guide function* Symbol.iterator Iterator Help improve MDN Was this page helpful to you? Yes No Learn how to contribute This page was last modified on ⁨Aug 19, 2025⁩ by MDN contributors . View this page on GitHub • Report a problem with this content Filter sidebar JavaScript Tutorials and guides JavaScript Guide Introduction Grammar and types Control flow and error handling Loops and iteration Functions Expressions and operators Numbers and strings Representing dates & times Regular expressions Indexed collections Keyed collections Working with objects Using classes Using promises JavaScript typed arrays Iterators and generators Resource management Internationalization JavaScript modules Intermediate Language overview JavaScript data structures Equality comparisons and sameness Enumerability and ownership of properties Closures Advanced Inheritance and the prototype chain Meta programming Memory Management References Built-in objects AggregateError Array ArrayBuffer AsyncDisposableStack AsyncFunction AsyncGenerator AsyncGeneratorFunction AsyncIterator Atomics BigInt BigInt64Array BigUint64Array Boolean DataView Date decodeURI() decodeURIComponent() DisposableStack encodeURI() encodeURIComponent() Error escape() Deprecated eval() EvalError FinalizationRegistry Float16Array Float32Array Float64Array Function Generator GeneratorFunction globalThis Infinity Int8Array Int16Array Int32Array InternalError Non-standard Intl isFinite() isNaN() Iterator JSON Map Math NaN Number Object parseFloat() parseInt() Promise Proxy RangeError ReferenceError Reflect RegExp Set SharedArrayBuffer String SuppressedError Symbol SyntaxError Temporal Experimental TypedArray TypeError Uint8Array Uint8ClampedArray Uint16Array Uint32Array undefined unescape() Deprecated URIError WeakMap WeakRef WeakSet Expressions & operators Addition (+) Addition assignment (+=) Assignment (=) async function expression async function* expression await Bitwise AND (&) Bitwise AND assignment (&=) Bitwise NOT (~) Bitwise OR (|) Bitwise OR assignment (|=) Bitwise XOR (^) Bitwise XOR assignment (^=) class expression Comma operator (,) Conditional (ternary) operator Decrement (--) delete Destructuring Division (/) Division assignment (/=) Equality (==) Exponentiation (**) Exponentiation assignment (**=) function expression function* expression Greater than (>) Greater than or equal (>=) Grouping operator ( ) import.meta import.meta.resolve() import() in Increment (++) Inequality (!=) instanceof Left shift (<<) Left shift assignment (<<=) Less than (<) Less than or equal (<=) Logical AND (&&) Logical AND assignment (&&=) Logical NOT (!) Logical OR (||) Logical OR assignment (||=) Multiplication (*) Multiplication assignment (*=) new new.target null Nullish coalescing assignment (??=) Nullish coalescing operator (??) Object initializer Operator precedence Optional chaining (?.) Property accessors Remainder (%) Remainder assignment (%=) Right shift (>>) Right shift assignment (>>=) Spread syntax (...) Strict equality (===) Strict inequality (!==) Subtraction (-) Subtraction assignment (-=) super this typeof Unary negation (-) Unary plus (+) Unsigned right shift (>>>) Unsigned right shift assignment (>>>=) void operator yield yield* Statements & declarations async function async function* await using Block statement break class const continue debugger do...while Empty statement export Expression statement for for await...of for...in for...of function function* if...else import Import attributes Labeled statement let return switch throw try...catch using var while with Deprecated Functions Arrow function expressions Default parameters get Method definitions Rest parameters set The arguments object [Symbol.iterator]() callee Deprecated length Classes constructor extends Private elements Public class fields static Static initialization blocks Regular expressions Backreference: \1, \2 Capturing group: (...) Character class escape: \d, \D, \w, \W, \s, \S Character class: [...], [^...] Character escape: \n, \u{...} Disjunction: | Input boundary assertion: ^, $ Literal character: a, b Lookahead assertion: (?=...), (?!...) Lookbehind assertion: (?<=...), (?<!...) Modifier: (?ims-ims:...) Named backreference: \k<name> Named capturing group: (?<name>...) Non-capturing group: (?:...) Quantifier: *, +, ?, {n}, {n,}, {n,m} Unicode character class escape: \p{...}, \P{...} Wildcard: . Word boundary assertion: \b, \B Errors AggregateError: No Promise in Promise.any was resolved Error: Permission denied to access property "x" InternalError: too much recursion RangeError: argument is not a valid code point RangeError: BigInt division by zero RangeError: BigInt negative exponent RangeError: form must be one of 'NFC', 'NFD', 'NFKC', or 'NFKD' RangeError: invalid array length RangeError: invalid date RangeError: precision is out of range RangeError: radix must be an integer RangeError: repeat count must be less than infinity RangeError: repeat count must be non-negative RangeError: x can't be converted to BigInt because it isn't an integer ReferenceError: "x" is not defined ReferenceError: assignment to undeclared variable "x" ReferenceError: can't access lexical declaration 'X' before initialization ReferenceError: must call super constructor before using 'this' in derived class constructor ReferenceError: super() called twice in derived class constructor SyntaxError: 'arguments'/'eval' can't be defined or assigned to in strict mode code SyntaxError: "0"-prefixed octal literals are deprecated SyntaxError: "use strict" not allowed in function with non-simple parameters SyntaxError: "x" is a reserved identifier SyntaxError: \ at end of pattern SyntaxError: a declaration in the head of a for-of loop can't have an initializer SyntaxError: applying the 'delete' operator to an unqualified name is deprecated SyntaxError: arguments is not valid in fields SyntaxError: await is only valid in async functions, async generators and modules SyntaxError: await/yield expression can't be used in parameter SyntaxError: cannot use `??` unparenthesized within `||` and `&&` expressions SyntaxError: character class escape cannot be used in class range in regular expression SyntaxError: continue must be inside loop SyntaxError: duplicate capture group name in regular expression SyntaxError: duplicate formal argument x SyntaxError: for-in loop head declarations may not have initializers SyntaxError: function statement requires a name SyntaxError: functions cannot be labelled SyntaxError: getter and setter for private name #x should either be both static or non-static SyntaxError: getter functions must have no arguments SyntaxError: identifier starts immediately after numeric literal SyntaxError: illegal character SyntaxError: import declarations may only appear at top level of a module SyntaxError: incomplete quantifier in regular expression SyntaxError: invalid assignment left-hand side SyntaxError: invalid BigInt syntax SyntaxError: invalid capture group name in regular expression SyntaxError: invalid character in class in regular expression SyntaxError: invalid class set operation in regular expression SyntaxError: invalid decimal escape in regular expression SyntaxError: invalid identity escape in regular expression SyntaxError: invalid named capture reference in regular expression SyntaxError: invalid property name in regular expression SyntaxError: invalid range in character class SyntaxError: invalid regexp group SyntaxError: invalid regular expression flag "x" SyntaxError: invalid unicode escape in regular expression SyntaxError: JSON.parse: bad parsing SyntaxError: label not found SyntaxError: missing : after property id SyntaxError: missing ) after argument list SyntaxError: missing ) after condition SyntaxError: missing ] after element list SyntaxError: missing } after function body SyntaxError: missing } after property list SyntaxError: missing = in const declaration SyntaxError: missing formal parameter SyntaxError: missing name after . operator SyntaxError: missing variable name SyntaxError: negated character class with strings in regular expression SyntaxError: new keyword cannot be used with an optional chain SyntaxError: nothing to repeat SyntaxError: numbers out of order in {} quantifier. SyntaxError: octal escape sequences can't be used in untagged template literals or in strict mode code SyntaxError: parameter after rest parameter SyntaxError: private fields can't be deleted SyntaxError: property name __proto__ appears more than once in object literal SyntaxError: raw bracket is not allowed in regular expression with unicode flag SyntaxError: redeclaration of formal parameter "x" SyntaxError: reference to undeclared private field or method #x SyntaxError: rest parameter may not have a default SyntaxError: return not in function SyntaxError: setter functions must have one argument SyntaxError: string literal contains an unescaped line break SyntaxError: super() is only valid in derived class constructors SyntaxError: tagged template cannot be used with optional chain SyntaxError: Unexpected '#' used outside of class body SyntaxError: Unexpected token SyntaxError: unlabeled break must be inside loop or switch SyntaxError: unparenthesized unary expression can't appear on the left-hand side of '**' SyntaxError: use of super property/member accesses only valid within methods or eval code within methods SyntaxError: Using //@ to indicate sourceURL pragmas is deprecated. Use //# instead TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed TypeError: 'x' is not iterable TypeError: "x" is (not) "y" TypeError: "x" is not a constructor TypeError: "x" is not a function TypeError: "x" is not a non-null object TypeError: "x" is read-only TypeError: already executing generator TypeError: BigInt value can't be serialized in JSON TypeError: calling a builtin X constructor without new is forbidden TypeError: can't access/set private field or method: object is not the right class TypeError: can't assign to property "x" on "y": not an object TypeError: can't convert BigInt to number TypeError: can't convert x to BigInt TypeError: can't define property "x": "obj" is not extensible TypeError: can't delete non-configurable array element TypeError: can't redefine non-configurable property "x" TypeError: can't set prototype of this object TypeError: can't set prototype: it would cause a prototype chain cycle TypeError: cannot use 'in' operator to search for 'x' in 'y' TypeError: class constructors must be invoked with 'new' TypeError: cyclic object value TypeError: derived class constructor returned invalid value x TypeError: getting private setter-only property TypeError: Initializing an object twice is an error with private fields/methods TypeError: invalid 'instanceof' operand 'x' TypeError: invalid Array.prototype.sort argument TypeError: invalid assignment to const "x" TypeError: Iterator/AsyncIterator constructor can't be used directly TypeError: matchAll/replaceAll must be called with a global RegExp TypeError: More arguments needed TypeError: null/undefined has no properties TypeError: property "x" is non-configurable and can't be deleted TypeError: Reduce of empty array with no initial value TypeError: setting getter-only property "x" TypeError: WeakSet key/WeakMap value 'x' must be an object or an unregistered symbol TypeError: X.prototype.y called on incompatible type URIError: malformed URI sequence Warning: -file- is being assigned a //# sourceMappingURL, but already has one Warning: unreachable code after return statement Misc JavaScript technologies overview Execution model Lexical grammar Iteration protocols Strict mode Template literals Trailing commas Deprecated features Your blueprint for a better internet. MDN About Blog Mozilla careers Advertise with us MDN Plus Product help Contribute MDN Community Community resources Writing guidelines MDN Discord MDN on GitHub Developers Web technologies Learn web development Guides Tutorials Glossary Hacks blog Website Privacy Notice Telemetry Settings Legal Community Participation Guidelines Visit Mozilla Corporation’s not-for-profit parent, the Mozilla Foundation . Portions of this content are ©1998–⁨2025⁩ by individual mozilla.org contributors. Content available under a Creative Commons license .