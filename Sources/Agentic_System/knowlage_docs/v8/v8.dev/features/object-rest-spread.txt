Object rest and spread properties Â· V8 V8 Show navigation Home Blog Docs Tools JS/Wasm features Research Object rest and spread properties Published 06 June 2017 Â· Tagged with ECMAScript ES2018 Before discussing object rest and spread properties , letâ€™s take a trip down memory lane and remind ourselves of a very similar feature. ES2015 array rest and spread elements # Good olâ€™ ECMAScript 2015 introduced rest elements for array destructuring assignment and spread elements for array literals. // Rest elements for array destructuring assignment: const primes = [ 2 , 3 , 5 , 7 , 11 ] ; const [ first , second , ... rest ] = primes ; console . log ( first ) ; // 2 console . log ( second ) ; // 3 console . log ( rest ) ; // [5, 7, 11] // Spread elements for array literals: const primesCopy = [ first , second , ... rest ] ; console . log ( primesCopy ) ; // [2, 3, 5, 7, 11] Chrome: supported since version 47 Firefox: supported since version 16 Safari: supported since version 8 Node.js: supported since version 6 Babel: supported about this feature support listing ES2018: object rest and spread properties ðŸ†• # So whatâ€™s new, then? Well, a proposal enables rest and spread properties for object literals, too. // Rest properties for object destructuring assignment: const person = { firstName : 'Sebastian' , lastName : 'MarkbÃ¥ge' , country : 'USA' , state : 'CA' , } ; const { firstName , lastName , ... rest } = person ; console . log ( firstName ) ; // Sebastian console . log ( lastName ) ; // MarkbÃ¥ge console . log ( rest ) ; // { country: 'USA', state: 'CA' } // Spread properties for object literals: const personCopy = { firstName , lastName , ... rest } ; console . log ( personCopy ) ; // { firstName: 'Sebastian', lastName: 'MarkbÃ¥ge', country: 'USA', state: 'CA' } Spread properties offer a more elegant alternative to Object.assign() in many situations: // Shallow-clone an object: const data = { x : 42 , y : 27 , label : 'Treasure' } ; // The old way: const clone1 = Object . assign ( { } , data ) ; // The new way: const clone2 = { ... data } ; // Either results in: // { x: 42, y: 27, label: 'Treasure' } // Merge two objects: const defaultSettings = { logWarnings : false , logErrors : false } ; const userSettings = { logErrors : true } ; // The old way: const settings1 = Object . assign ( { } , defaultSettings , userSettings ) ; // The new way: const settings2 = { ... defaultSettings , ... userSettings } ; // Either results in: // { logWarnings: false, logErrors: true } However, there are some subtle differences in how spreading handles setters: Object.assign() triggers setters; spread doesnâ€™t. You can stop Object.assign() from creating own properties via inherited read-only properties, but not the spread operator. Axel Rauschmayerâ€™s write-up explains these gotchas in more detail. Chrome: supported since version 60 Firefox: supported since version 55 Safari: supported since version 11.1 Node.js: supported since version 8.6 Babel: supported about this feature support listing Posted by Mathias Bynens ( @mathias ). Retweet this article! Branding Terms Privacy Twitter Edit this page on GitHub Except as otherwise noted, any code samples from the V8 project are licensed under V8â€™s BSD-style license . Other content on this page is licensed under the Creative Commons Attribution 3.0 License . For details, see our site policies .