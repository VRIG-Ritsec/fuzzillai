from smolagents import tool
from common_tools import *
from rag_tools import * # deal with this later

@tool
def tree(directory: str = ".", options: str = "") -> str:
    """
    Display directory structure using tree command to explore project layout.
    
    Args:
        directory (str, optional): The directory to explore. Defaults to current directory ".".
        options (str, optional): Additional tree command options. Common options include:
            -L NUM: Limit depth to NUM levels
            -f: Show full path prefix 
    
    Returns:
        str: Tree structure showing directories and files in the specified path.
    """
    return get_output(run_command(f"tree {options} {directory}"))

@tool 
def run_d8(target: str, options: str = "") -> str:
    f"""
    Run the target program using d8 to test for syntactical correctness
    and test for coverage. 

    Args:
        --print-maglev-code (print maglev code)
        --trace-maglev-graph-building (trace maglev graph building)
        --print-maglev-graph (print the final maglev graph)
        --print-maglev-graphs (print maglev graph across all phases)
        --maglev-stats (print Maglev statistics)
        --jit-fuzzing (Set JIT tiering thresholds suitable for JIT fuzzing)
        --print-bytecode (print bytecode generated by ignition interpreter)
        --trace-turbo (trace generated TurboFan IR)
        --trace-turbo-path (directory to dump generated TurboFan IR to) 
            Ex: --trace-turbo-path=/tmp/turbofan_ir
        --trace-turbo-graph (trace generated TurboFan graphs)
        --turbo-stats (print TurboFan statistics)
        --trace-wasm-compiler (trace compiling of wasm code)
        --trace-wasm (trace wasm function calls)

        AT ANY POINT IN TIME YOU CAN ONLY PICK UP TO 4 OF THESE OPTIONS.

        WHENEVER --trace-turob-graph is passed MAKE SURE --trace-turbo-path is ALSO passed in
        IF --trace-turbo-path is passed, MAKE SURE the output directory is {OUTPUT_DIRECTORY}/{target}
    """ 
    completed_process = run_command(f"{D8_PATH} {target} {options}")
    if not completed_process:
        return

    try:
        os.makedirs(OUTPUT_DIRECTORY)
    except FileExistsError:
        pass

    with open(f"{OUTPUT_DIRECTORY}/{target}.out") as file:
        file.write(p_stdout)

    with open(f"{OUTPUT_DIRECTORY}/{target}.err") as file:
        file.write(p_stderr)

# TODO: @Tanush - good luck
@tool
def get_call_graph(target: str) -> str:
    """
    Get the call graph of the target program using d8 to test for syntactical correctness
    and test for coverage. 
    """
    return get_output(run_command(f""))  # Database access wrappere

@tool
def decode_b64(str_base64: str) -> str:
    """
    Decode a base64 encoded string

    Args:
        str_base64 (str): The base64 encoded string to be decoded
    
    Returns:
        str: Decoded base64 string
    """
    return get_output(run_command(f"echo '{str_base64.strip()}' | base64 -d"))
