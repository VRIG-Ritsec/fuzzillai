From 2458d5c6f80310f5af5af98c88de5c4fb944717e Mon Sep 17 00:00:00 2001
From: Zia-Rashid <kamdinomaribembry@gmail.com>
Date: Fri, 10 Oct 2025 13:25:10 +0000
Subject: [PATCH] add optimization tracing bitmap and integrated w/ shmem

---
 src/codegen/optimized-compilation-info.h | 85 ++++++++++++++++++++++++
 src/compiler/pipeline.cc                 | 50 ++++++++++++++
 src/fuzzilli/cov.cc                      | 11 ++-
 src/fuzzilli/cov.h                       |  4 +-
 4 files changed, 142 insertions(+), 8 deletions(-)

diff --git a/src/codegen/optimized-compilation-info.h b/src/codegen/optimized-compilation-info.h
index cf7dd4d6..8f2c456f 100755
--- a/src/codegen/optimized-compilation-info.h
+++ b/src/codegen/optimized-compilation-info.h
@@ -6,6 +6,7 @@
 #define V8_CODEGEN_OPTIMIZED_COMPILATION_INFO_H_
 
 #include <memory>
+#include <array>
 
 #include "src/base/vector.h"
 #include "src/codegen/bailout-reason.h"
@@ -99,6 +100,87 @@ class V8_EXPORT_PRIVATE OptimizedCompilationInfo final {
   FLAGS(DEF_SETTER)
 #undef DEF_SETTER
 
+  // Optimization tracing bitmap
+  //
+  // This bitmap tracks which compiler optimizations/passes are ran for a given
+  // optimized compilation. Bits correspond to major TurboFan/TurboShaft
+  // pipeline phases.
+  //
+  // phases (from pipeline passes in src/compiler/pipeline.cc):
+  // - BrokerInitAndSerialization: HeapBrokerInitializationPhase
+  // - GraphCreation:
+  //   - GraphBuilderPhase
+  //   - InliningPhase
+  // - Lowering and typed optimizations:
+  //   - EarlyGraphTrimmingPhase
+  //   - TyperPhase
+  //   - TypedLoweringPhase
+  //   - LoopPeelingPhase or LoopExitEliminationPhase
+  //   - LoadEliminationPhase
+  //   - EscapeAnalysisPhase
+  //   - TypeAssertionsPhase
+  //   - SimplifiedLoweringPhase
+  // - JS <-> Wasm related (conditional):
+  //   - JSWasmInliningPhase
+  //   - WasmTypingPhase
+  //   - WasmGCOptimizationPhase
+  //   - JSWasmLoweringPhase
+  //   - WasmOptimizationPhase
+  // - Post-typing cleanup:
+  //   - UntyperPhase (debug-only)
+  // - Generic lowering and early block optimizations:
+  //   - GenericLoweringPhase
+  //   - EarlyOptimizationPhase
+  // - Backend (scheduling/ISel/RA/codegen):
+  //   - ComputeScheduledGraph/Scheduling
+  //   - InstructionSelection
+  //   - RegisterAllocation
+  //   - CodeGeneration
+  //
+  enum class OptimizationBit : int {
+    kBrokerInitAndSerialization = 0,
+    kGraphBuilder,
+    kInlining,
+    kEarlyGraphTrimming,
+    kTyper,
+    kTypedLowering,
+    kLoopPeeling,
+    kLoopExitElimination,
+    kLoadElimination,
+    kEscapeAnalysis,
+    kTypeAssertions,
+    kSimplifiedLowering,
+    kJSWasmInlining,
+    kWasmTyping,
+    kWasmGCOptimization,
+    kJSWasmLowering,
+    kWasmOptimization,
+    kUntyper,
+    kGenericLowering,
+    kEarlyOptimization,
+    kScheduling,
+    kInstructionSelection,
+    kRegisterAllocation,
+    kCodeGeneration,
+    kCount
+  };
+
+  // set a bit indicating an optimization phase ran during this compilation
+  void SetOptimizationBit(OptimizationBit bit) {
+    const int index = static_cast<int>(bit);
+    const int word = index / 64;
+    const int offset = index % 64;
+    optimization_bits_[word] |= (uint64_t{1} << offset);
+  }
+
+  // query whether a given optimization phase bit is set
+  bool HasOptimizationBit(OptimizationBit bit) const {
+    const int index = static_cast<int>(bit);
+    const int word = index / 64;
+    const int offset = index % 64;
+    return (optimization_bits_[word] & (uint64_t{1} << offset)) != 0;
+  }
+
   // Construct a compilation info for optimized compilation.
   OptimizedCompilationInfo(Zone* zone, Isolate* isolate,
                            IndirectHandle<SharedFunctionInfo> shared,
@@ -354,6 +436,9 @@ class V8_EXPORT_PRIVATE OptimizedCompilationInfo final {
   // handles above. The only difference is that is created in the
   // CanonicalHandleScope(i.e step 1) is different).
   std::unique_ptr<CanonicalHandlesMap> canonical_handles_;
+
+  // Two 64-bit words give space for up to 128 optimization bits.
+  std::array<uint64_t, 2> optimization_bits_ = {0, 0};
 };
 
 }  // namespace internal
diff --git a/src/compiler/pipeline.cc b/src/compiler/pipeline.cc
index 1234c13b..f7019159 100755
--- a/src/compiler/pipeline.cc
+++ b/src/compiler/pipeline.cc
@@ -104,6 +104,7 @@
 #include "src/logging/counters.h"
 #include "src/logging/runtime-call-stats-scope.h"
 #include "src/logging/runtime-call-stats.h"
+#include "src/fuzzilli/cov.h"
 #include "src/objects/code-kind.h"
 #include "src/objects/shared-function-info.h"
 #include "src/objects/string-inl.h"
@@ -492,6 +493,9 @@ TurbofanPipelineStatistics* CreatePipelineStatistics(
   // Run Turboshaft instruction selection.
   if (!turboshaft_pipeline.PrepareForInstructionSelection()) return false;
   if (!turboshaft_pipeline.SelectInstructions(linkage)) return false;
+  // Mark instruction selection complete.
+  turbofan_pipeline->info()->SetOptimizationBit(OptimizedCompilationInfo::OptimizationBit::kInstructionSelection);
+  cov_set_turbofan_optimization_bits(1ull << static_cast<int>(OptimizedCompilationInfo::OptimizationBit::kInstructionSelection));
   // We can release the graph now.
   turboshaft_data->ClearGraphComponent();
 
@@ -499,9 +503,13 @@ TurbofanPipelineStatistics* CreatePipelineStatistics(
           linkage->GetIncomingDescriptor())) {
     return false;
   }
+  turbofan_pipeline->info()->SetOptimizationBit(OptimizedCompilationInfo::OptimizationBit::kRegisterAllocation);
+  cov_set_turbofan_optimization_bits(1ull << static_cast<int>(OptimizedCompilationInfo::OptimizationBit::kRegisterAllocation));
   if (!turboshaft_pipeline.AssembleCode(linkage)) {
     return false;
   }
+  turbofan_pipeline->info()->SetOptimizationBit(OptimizedCompilationInfo::OptimizationBit::kCodeGeneration);
+  cov_set_turbofan_optimization_bits(1ull << static_cast<int>(OptimizedCompilationInfo::OptimizationBit::kCodeGeneration));
   return true;
 }
 
@@ -1952,6 +1960,8 @@ bool PipelineImpl::InitializeHeapBroker() {
   }
 
   RUN_MAYBE_ABORT(HeapBrokerInitializationPhase);
+  info()->SetOptimizationBit(OptimizedCompilationInfo::OptimizationBit::kBrokerInitAndSerialization);
+  cov_set_turbofan_optimization_bits(1ull << static_cast<int>(OptimizedCompilationInfo::OptimizationBit::kBrokerInitAndSerialization));
   data->broker()->StopSerializing();
   data->EndPhaseKind();
   return !info()->was_cancelled();
@@ -1966,10 +1976,14 @@ bool PipelineImpl::CreateGraph(Linkage* linkage) {
 
   RUN_MAYBE_ABORT(GraphBuilderPhase, linkage);
   RunPrintAndVerify(GraphBuilderPhase::phase_name(), true);
+  info()->SetOptimizationBit(OptimizedCompilationInfo::OptimizationBit::kGraphBuilder);
+  cov_set_turbofan_optimization_bits(1ull << static_cast<int>(OptimizedCompilationInfo::OptimizationBit::kGraphBuilder));
 
   // Perform function context specialization and inlining (if enabled).
   RUN_MAYBE_ABORT(InliningPhase);
   RunPrintAndVerify(InliningPhase::phase_name(), true);
+  info()->SetOptimizationBit(OptimizedCompilationInfo::OptimizationBit::kInlining);
+  cov_set_turbofan_optimization_bits(1ull << static_cast<int>(OptimizedCompilationInfo::OptimizationBit::kInlining));
 
   // Determine the Typer operation flags.
   {
@@ -2000,37 +2014,53 @@ bool PipelineImpl::OptimizeTurbofanGraph(Linkage* linkage) {
   // Trim the graph before typing to ensure all nodes are typed.
   RUN_MAYBE_ABORT(EarlyGraphTrimmingPhase);
   RunPrintAndVerify(EarlyGraphTrimmingPhase::phase_name(), true);
+  info()->SetOptimizationBit(OptimizedCompilationInfo::OptimizationBit::kEarlyGraphTrimming);
+  cov_set_turbofan_optimization_bits(1ull << static_cast<int>(OptimizedCompilationInfo::OptimizationBit::kEarlyGraphTrimming));
 
   // Type the graph and keep the Typer running such that new nodes get
   // automatically typed when they are created.
   RUN_MAYBE_ABORT(TyperPhase, data->CreateTyper());
   RunPrintAndVerify(TyperPhase::phase_name());
+  info()->SetOptimizationBit(OptimizedCompilationInfo::OptimizationBit::kTyper);
+  cov_set_turbofan_optimization_bits(1ull << static_cast<int>(OptimizedCompilationInfo::OptimizationBit::kTyper));
 
   RUN_MAYBE_ABORT(TypedLoweringPhase);
   RunPrintAndVerify(TypedLoweringPhase::phase_name());
+  info()->SetOptimizationBit(OptimizedCompilationInfo::OptimizationBit::kTypedLowering);
+  cov_set_turbofan_optimization_bits(1ull << static_cast<int>(OptimizedCompilationInfo::OptimizationBit::kTypedLowering));
 
   if (data->info()->loop_peeling()) {
     RUN_MAYBE_ABORT(LoopPeelingPhase);
     RunPrintAndVerify(LoopPeelingPhase::phase_name(), true);
+    info()->SetOptimizationBit(OptimizedCompilationInfo::OptimizationBit::kLoopPeeling);
+    cov_set_turbofan_optimization_bits(1ull << static_cast<int>(OptimizedCompilationInfo::OptimizationBit::kLoopPeeling));
   } else {
     RUN_MAYBE_ABORT(LoopExitEliminationPhase);
     RunPrintAndVerify(LoopExitEliminationPhase::phase_name(), true);
+    info()->SetOptimizationBit(OptimizedCompilationInfo::OptimizationBit::kLoopExitElimination);
+    cov_set_turbofan_optimization_bits(1ull << static_cast<int>(OptimizedCompilationInfo::OptimizationBit::kLoopExitElimination));
   }
 
   if (v8_flags.turbo_load_elimination) {
     RUN_MAYBE_ABORT(LoadEliminationPhase);
     RunPrintAndVerify(LoadEliminationPhase::phase_name());
+    info()->SetOptimizationBit(OptimizedCompilationInfo::OptimizationBit::kLoadElimination);
+    cov_set_turbofan_optimization_bits(1ull << static_cast<int>(OptimizedCompilationInfo::OptimizationBit::kLoadElimination));
   }
   data->DeleteTyper();
 
   if (v8_flags.turbo_escape) {
     RUN_MAYBE_ABORT(EscapeAnalysisPhase);
     RunPrintAndVerify(EscapeAnalysisPhase::phase_name());
+    info()->SetOptimizationBit(OptimizedCompilationInfo::OptimizationBit::kEscapeAnalysis);
+    cov_set_turbofan_optimization_bits(1ull << static_cast<int>(OptimizedCompilationInfo::OptimizationBit::kEscapeAnalysis));
   }
 
   if (v8_flags.assert_types) {
     RUN_MAYBE_ABORT(TypeAssertionsPhase);
     RunPrintAndVerify(TypeAssertionsPhase::phase_name());
+    info()->SetOptimizationBit(OptimizedCompilationInfo::OptimizationBit::kTypeAssertions);
+    cov_set_turbofan_optimization_bits(1ull << static_cast<int>(OptimizedCompilationInfo::OptimizationBit::kTypeAssertions));
   }
 
   // Perform simplified lowering. This has to run w/o the Typer decorator,
@@ -2038,30 +2068,42 @@ bool PipelineImpl::OptimizeTurbofanGraph(Linkage* linkage) {
   // types might even conflict with the representation/truncation logic.
   RUN_MAYBE_ABORT(SimplifiedLoweringPhase, linkage);
   RunPrintAndVerify(SimplifiedLoweringPhase::phase_name(), true);
+  info()->SetOptimizationBit(OptimizedCompilationInfo::OptimizationBit::kSimplifiedLowering);
+  cov_set_turbofan_optimization_bits(1ull << static_cast<int>(OptimizedCompilationInfo::OptimizationBit::kSimplifiedLowering));
 
 #if V8_ENABLE_WEBASSEMBLY
   if (data->has_js_wasm_calls()) {
     DCHECK(data->info()->inline_js_wasm_calls());
     RUN_MAYBE_ABORT(JSWasmInliningPhase);
     RunPrintAndVerify(JSWasmInliningPhase::phase_name(), true);
+    info()->SetOptimizationBit(OptimizedCompilationInfo::OptimizationBit::kJSWasmInlining);
+    cov_set_turbofan_optimization_bits(1ull << static_cast<int>(OptimizedCompilationInfo::OptimizationBit::kJSWasmInlining));
 
     RUN_MAYBE_ABORT(WasmTypingPhase, -1);
     RunPrintAndVerify(WasmTypingPhase::phase_name(), true);
+    info()->SetOptimizationBit(OptimizedCompilationInfo::OptimizationBit::kWasmTyping);
+    cov_set_turbofan_optimization_bits(1ull << static_cast<int>(OptimizedCompilationInfo::OptimizationBit::kWasmTyping));
 
     if (v8_flags.wasm_opt) {
       RUN_MAYBE_ABORT(WasmGCOptimizationPhase,
                       data->wasm_native_module_for_inlining()->module(),
                       data->jsgraph());
       RunPrintAndVerify(WasmGCOptimizationPhase::phase_name(), true);
+      info()->SetOptimizationBit(OptimizedCompilationInfo::OptimizationBit::kWasmGCOptimization);
+      cov_set_turbofan_optimization_bits(1ull << static_cast<int>(OptimizedCompilationInfo::OptimizationBit::kWasmGCOptimization));
     }
     RUN_MAYBE_ABORT(JSWasmLoweringPhase);
     RunPrintAndVerify(JSWasmLoweringPhase::phase_name(), true);
+    info()->SetOptimizationBit(OptimizedCompilationInfo::OptimizationBit::kJSWasmLowering);
+    cov_set_turbofan_optimization_bits(1ull << static_cast<int>(OptimizedCompilationInfo::OptimizationBit::kJSWasmLowering));
 
     if (v8_flags.turbo_optimize_inlined_js_wasm_wrappers && v8_flags.wasm_opt) {
       wasm::WasmDetectedFeatures detected({wasm::WasmDetectedFeature::gc});
       RUN_MAYBE_ABORT(WasmOptimizationPhase,
                       MachineOperatorReducer::kSilenceSignallingNan, detected);
       RunPrintAndVerify(WasmOptimizationPhase::phase_name(), true);
+      info()->SetOptimizationBit(OptimizedCompilationInfo::OptimizationBit::kWasmOptimization);
+      cov_set_turbofan_optimization_bits(1ull << static_cast<int>(OptimizedCompilationInfo::OptimizationBit::kWasmOptimization));
     }
   }
 #endif  // V8_ENABLE_WEBASSEMBLY
@@ -2077,11 +2119,15 @@ bool PipelineImpl::OptimizeTurbofanGraph(Linkage* linkage) {
 #ifdef DEBUG
   RUN_MAYBE_ABORT(UntyperPhase);
   RunPrintAndVerify(UntyperPhase::phase_name(), true);
+  info()->SetOptimizationBit(OptimizedCompilationInfo::OptimizationBit::kUntyper);
+  cov_set_turbofan_optimization_bits(1ull << static_cast<int>(OptimizedCompilationInfo::OptimizationBit::kUntyper));
 #endif
 
   // Run generic lowering pass.
   RUN_MAYBE_ABORT(GenericLoweringPhase);
   RunPrintAndVerify(GenericLoweringPhase::phase_name(), true);
+  info()->SetOptimizationBit(OptimizedCompilationInfo::OptimizationBit::kGenericLowering);
+  cov_set_turbofan_optimization_bits(1ull << static_cast<int>(OptimizedCompilationInfo::OptimizationBit::kGenericLowering));
 
   data->BeginPhaseKind("V8.TFBlockBuilding");
 
@@ -2090,6 +2136,8 @@ bool PipelineImpl::OptimizeTurbofanGraph(Linkage* linkage) {
   // Run early optimization pass.
   RUN_MAYBE_ABORT(EarlyOptimizationPhase);
   RunPrintAndVerify(EarlyOptimizationPhase::phase_name(), true);
+  info()->SetOptimizationBit(OptimizedCompilationInfo::OptimizationBit::kEarlyOptimization);
+  cov_set_turbofan_optimization_bits(1ull << static_cast<int>(OptimizedCompilationInfo::OptimizationBit::kEarlyOptimization));
 
   data->source_positions()->RemoveDecorator();
   if (data->info()->trace_turbo_json()) {
@@ -3546,6 +3594,8 @@ bool PipelineImpl::ComputeScheduledGraph() {
 
   RUN_MAYBE_ABORT(ComputeSchedulePhase);
   TraceScheduleAndVerify(data->info(), data, data->schedule(), "schedule");
+  data->info()->SetOptimizationBit(OptimizedCompilationInfo::OptimizationBit::kScheduling);
+  cov_set_turbofan_optimization_bits(1ull << static_cast<int>(OptimizedCompilationInfo::OptimizationBit::kScheduling));
   return true;
 }
 
diff --git a/src/fuzzilli/cov.cc b/src/fuzzilli/cov.cc
index 50026108..7ffd962e 100755
--- a/src/fuzzilli/cov.cc
+++ b/src/fuzzilli/cov.cc
@@ -43,8 +43,8 @@ struct shmem_data {
   uint32_t num_edges;
   uint32_t feedback_nexus_count; 
   uint32_t max_feedback_nexus;
-  uint32_t turbofan_optimization_bits; // Bits representing various optimization passes for turbofan
-  uint32_t maglev_optimization_bits; // Bits representing various optimization passes for maglev
+  uint32_t turbofan_flags;
+  uint64_t turbofan_optimization_bits;
   FeedbackNexusData feedback_nexus_data[MAX_FEEDBACK_NEXUS];
   unsigned char edges[];
 };
@@ -240,13 +240,12 @@ void cov_add_feedback_nexus(v8::internal::FeedbackNexus* nexus) {
   shmem->feedback_nexus_count++;
 }
 
-void cov_set_turbofan_optimization_bits(uint32_t bit) {
+void cov_set_turbofan_optimization_bits(uint64_t bit) {
   if (!shmem) return;
   shmem->turbofan_optimization_bits |= bit;
 }
 
-void cov_set_maglev_optimization_bits(uint32_t bit) {
-  if (!shmem) return;
-  shmem->maglev_optimization_bits |= bit;
+void cov_set_maglev_optimization_bits(uint64_t /*bit*/) {
+  // No-op: maglev bitmap is not exported in shmem layout.
 }
 // }  // namespace v8
diff --git a/src/fuzzilli/cov.h b/src/fuzzilli/cov.h
index 4f7caafe..090ac491 100755
--- a/src/fuzzilli/cov.h
+++ b/src/fuzzilli/cov.h
@@ -30,7 +30,7 @@ class FeedbackNexus;
 void cov_add_feedback_nexus(v8::internal::FeedbackNexus* nexus);
 
 // Track optimization passes for maglev and turbofan
-void cov_set_turbofan_optimization_bits(uint32_t bit);
-void cov_set_maglev_optimization_bits(uint32_t bit);
+void cov_set_turbofan_optimization_bits(uint64_t bit);
+void cov_set_maglev_optimization_bits(uint64_t bit);
 
 #endif  // V8_FUZZILLI_COV_H_
-- 
2.49.1

