// Minimizing D5F2B66A-79C1-46F3-BFE2-43DE525B8EBA
class C2 {
}
const v3 = [-9223372036854775807,31754,-1583478162,2061316964,-4096,-9007199254740990,65535,-1857689020,-9223372036854775807,9];
const v4 = ~v3;
Uint8ClampedArray.prototype = Uint8ClampedArray;
let v6;
try { v6 = new Uint8ClampedArray(v4); } catch (e) {}
v6 ?? v6;
const v8 = new Float64Array(2);
const v11 = new Float64Array(186);
Float64Array.e = Float64Array;
const v14 = new Float64Array(3);
try { ("setBigInt64").trimEnd(); } catch (e) {}
function F19(a21, a22, a23, a24) {
    if (!new.target) { throw 'must be called with new'; }
    this.p6 = 1e-15;
    this.c = a21;
}
for (let i28 = 0, i29 = 10;
    (() => {
        const v30 = i28 < i29;
        !v30;
        return v30;
    })();
    i29 + i29, i29--) {
}
function f39() {
    return Float64Array;
}
try { f39.constructor("toZonedDateTime"); } catch (e) {}
function F41(a43, a44) {
    if (!new.target) { throw 'must be called with new'; }
    const v45 = this?.constructor;
    try { new v45(this, Float64Array); } catch (e) {}
    a44.e = a44;
    this.h = a43;
    this.b = f39;
}
F41.length;
const v48 = new F41(v8, Float64Array);
new F41(v14, Float64Array);
const v50 = new F41(v11, Float64Array);
v50.e = v50;
-1828752785 >> -1828752785;
745.8806114719878 - 745.8806114719878;
const v56 = class {
    get g() {
        new Float64Array(1078);
        +v3;
        function F65(a67, a68, a69) {
            if (!new.target) { throw 'must be called with new'; }
            this.g = a69;
        }
        class C70 {
        }
        class C71 extends C70 {
        }
        const v72 = [-1073741824,476388605,536870912];
        try { v72.reduce(476388605); } catch (e) {}
        [-1073741824,v72,476388605,-1073741824];
    }
    static #a;
    constructor(a76) {
        a76 ?? a76;
    }
    d;
    o(a79) {
    }
    #b;
    o(a81) {
    }
}
const v82 = new v56();
const v83 = new v56(v82);
const v84 = new v56(v56);
v84.d = v84;
function f85() {
    return f85;
}
try { f85(); } catch (e) {}
function F87(a89, a90, a91) {
    if (!new.target) { throw 'must be called with new'; }
    const v92 = a90?.d;
    try { new v92(); } catch (e) {}
    a91.propertyIsEnumerable(-1828752785);
    this.a = v84;
}
try { F87.bind(-1828752785); } catch (e) {}
F87.prototype;
const v97 = new F87(v84, v84, v83);
const v98 = v97.constructor;
try { new v98(v84, 186, 1e-15); } catch (e) {}
const v100 = new F87(v82, v83, v82);
v100.a;
const v103 = Math?.tan;
try { new v103(v56); } catch (e) {}
v82.b = Math.sin();
function f106() {
}
function f107() {
    const v143 = {
        e: f106,
        __proto__: f106,
        ...f106,
        f: f106,
        6: f106,
        set b(a109) {
            let v110 = super[f106];
            v110 &&= a109;
            function f117(a118, a119) {
                const v123 = {
                    ["a"]: "a",
                    g: a119,
                    [a119]: "10000",
                    n(a121, a122) {
                        return this;
                    },
                    f: a118,
                };
                return v123;
            }
            f117(f117(f117(), "a"), "a");
            [4294967296,128,-373826824,-1420021067,-2147483648,5,127];
            const v128 = [9007199254740990,10000,14204,65536,4096];
            let v130 = 64;
            -256 > "PbD";
            for (let v132 = 0; v132 < 25; v132++) {
                v130 = v132;
                v128.__proto__ = "a";
                Uint8Array.of(72, 50, 89, 67, 175, 125, 179).toHex();
            }
        },
        ...f106,
    };
    return v143;
}
function f146() {
    return "toString";
}
f146.prototype;
const v175 = {
    __proto__: f146,
    [v11](a149, a150, a151, a152) {
    },
    valueOf(a154, a155, a156) {
        for (let i159 = 0, i160 = 10; i159 < i160; i159++, i160--) {
        }
        super["bigint"] = a154;
        ("setBigInt64").length;
        return a156;
    },
    9: -1073741824,
    b: "toString",
    c: f146,
    set b(a174) {
    },
    9: "bigint",
    maxByteLength: 3,
};
new F87(v82, v82, v84);
for (let i179 = 0, i180 = 10;
    i179 < i180;
    (() => {
        i179++;
        const v185 = i180--;
        v185 ^ v185;
    })()) {
}
const v190 = [];
try { v190.map(v48); } catch (e) {}
let v192;
try { v192 = v190.map(8n); } catch (e) {}
Number.length;
const v195 = Number.isNaN(-1073741824);
v195 && v195;
const v197 = v195 && v192;
v197 && v197;
const v199 = [];
const v205 = Symbol.iterator;
const v207 = {
    [v205]() {
    },
};
v207.a = v207;
let v210;
try { v210 = new Float32Array(Uint16Array, v84, -1828752785); } catch (e) {}
v210.length = v210;
const v212 = /Qa(?!bbb|bb)c\u0060?/dsm;
v212.ignoreCase;
let v216;
try { v216 = new Uint8Array(2, v212, v212); } catch (e) {}
try { v216.includes(v83); } catch (e) {}
v216[1];
const v237 = {
    toString(a220, a221, a222) {
        return a222;
    },
    [Symbol]() {
        const v236 = {
            next() {
                const v235 = {
                    valueOf(a226, a227, a228) {
                    },
                    get d() {
                        const v230 = {};
                    },
                    [v199](a232, a233, a234) {
                    },
                };
            },
        };
    },
};
// Program is interesting due to new coverage: 188 newly discovered edges in the CFG of the target
