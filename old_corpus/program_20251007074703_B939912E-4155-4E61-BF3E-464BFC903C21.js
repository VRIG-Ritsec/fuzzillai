// Minimizing C634F3F0-8BC2-49F2-BA73-BC5FD743D2FD
new Int32Array(2098);
new Float64Array(2098);
function f6() {
    return false;
}
function F7(a9, a10) {
    if (!new.target) { throw 'must be called with new'; }
    this.d = a10;
    this.a = a9;
    this.f = a10;
}
const v11 = new F7(f6, f6);
new F7(F7, v11);
new F7(f6, Int32Array);
const v17 = new Uint16Array([9.88496591383436e+307,-0.0,9.645811590416322,-2.2250738585072014e-308,-882877.4954994294,NaN,7.540716606719762,781.9769262846953,-7.004326735250661e+306]);
v17.a = 684504293;
new Uint16Array(1000);
function f30() {
}
function F31(a33, a34) {
    if (!new.target) { throw 'must be called with new'; }
    a34.arguments;
    class C38 {
    }
    const v39 = [-9223372036854775807,31754,-1583478162,2061316964,-4096,-9007199254740990,65535,-1857689020,-9223372036854775807,9];
    const v40 = ~v39;
    Uint8ClampedArray.prototype = Uint8ClampedArray;
    let v42;
    try { v42 = new Uint8ClampedArray(v40); } catch (e) {}
    v42 ?? v42;
    const v44 = new Float64Array(2);
    const v47 = new Float64Array(186);
    Float64Array.e = Float64Array;
    const v50 = new Float64Array(3);
    ("setBigInt64").trimEnd();
    function F55(a57, a58, a59, a60) {
        if (!new.target) { throw 'must be called with new'; }
        this.p6 = 1e-15;
        this.c = a57;
    }
    for (let i64 = 0, i65 = 10;
        (() => {
            const v66 = i64 < i65;
            !v66;
            return v66;
        })();
        i65 + i65, i65--) {
    }
    function f75() {
        return Float64Array;
    }
    f75.constructor("toZonedDateTime");
    function F77(a79, a80) {
        if (!new.target) { throw 'must be called with new'; }
        const v81 = this?.constructor;
        try { new v81(this, Float64Array); } catch (e) {}
        a80.e = a80;
        this.h = a79;
        this.b = f75;
    }
    F77.length;
    const v84 = new F77(v44, Float64Array);
    new F77(v50, Float64Array);
    const v86 = new F77(v47, Float64Array);
    v86.e = v86;
    -1828752785 >> -1828752785;
    745.8806114719878 - 745.8806114719878;
    const v92 = class {
        get g() {
            new Float64Array(1078);
            +v39;
            function F101(a103, a104, a105) {
                if (!new.target) { throw 'must be called with new'; }
                this.g = a105;
            }
            class C106 {
            }
            class C107 extends C106 {
            }
            const v108 = [-1073741824,476388605,536870912];
            v108.reduce(476388605);
            [-1073741824,v108,476388605,-1073741824];
        }
        static #a;
        constructor(a112) {
            a112 ?? a112;
        }
        d;
        #b;
    }
    const v114 = new v92();
    const v115 = new v92(v114);
    const v116 = new v92(v92);
    v116.d = v116;
    function f117() {
        return f117;
    }
    f117();
    function F119(a121, a122, a123) {
        if (!new.target) { throw 'must be called with new'; }
        const v124 = a122.d;
        try { new v124(); } catch (e) {}
        a123.propertyIsEnumerable(-1828752785);
        this.a = v116;
    }
    try { F119.bind(-1828752785); } catch (e) {}
    F119.prototype;
    const v129 = new F119(v116, v116, v115);
    const t109 = v129.constructor;
    new t109(v116, 186, 1e-15);
    const v132 = new F119(v114, v115, v114);
    v132.a;
    const v135 = Math?.tan;
    try { new v135(v92); } catch (e) {}
    v114.b = Math.sin();
    function f138() {
    }
    function f139() {
    }
    function f142() {
        return "toString";
    }
    new F119(v114, v114, v116);
    for (let i146 = 0, i147 = 10;
        i146 < i147;
        (() => {
            i146++;
            const v152 = i147--;
            v152 ^ v152;
        })()) {
    }
    const v157 = [];
    try { v157.map(v84); } catch (e) {}
    let v159;
    try { v159 = v157.map(8n); } catch (e) {}
    Number.length;
    const v162 = Number.isNaN(-1073741824);
    v162 && v162;
    const v164 = v162 && v159;
    v164 && v164;
    [];
    Symbol.iterator;
    const v173 = {};
    v173.a = v173;
    let v176;
    try { v176 = new Float32Array(Uint16Array, v116, -1828752785); } catch (e) {}
    v176.length = v176;
    const v178 = /Qa(?!bbb|bb)c\u0060?/dsm;
    v178.ignoreCase;
    const v182 = new Uint8Array(2, v178, v178);
    try { v182.includes(v115); } catch (e) {}
    v182[1];
    const v185 = {};
}
new F31(-14, f30);
const v187 = new Int32Array(15);
class C188 {
    h = Int8Array;
    #b;
    static [Int8Array];
    static [1000] = Int8Array;
}
new C188();
/[(?:a+)+]/dygimu;
const v191 = /foo(?=bar)bazc(a)X?/dgmu;
String.prototype.includes.call(v191);
v187.buffer;
function F198(a200, a201, a202, a203) {
    if (!new.target) { throw 'must be called with new'; }
    this.p6 = 1e-15;
    this.c = a200;
}
const v204 = new F198();
for (let v205 = 0; v205 < 10; v205++) {
    v204[F31 + v205] = F198;
}
// Program is interesting due to new coverage: 90 newly discovered edges in the CFG of the target
